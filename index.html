<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>Операция "Заброшка"</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#000;font-family:'Segoe UI',Arial,sans-serif;user-select:none}
canvas#gl{width:100%;height:100%;display:block}
#ui{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none}
#crosshair{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:28px;height:28px}
#crosshair::before,#crosshair::after{content:'';position:absolute;background:#0f0;box-shadow:0 0 8px #0f0,0 0 2px #fff}
#crosshair::before{width:2px;height:28px;left:13px;top:0;clip-path:polygon(0 0,100% 0,100% 38%,0 38%,0 62%,100% 62%,100% 100%,0 100%)}
#crosshair::after{width:28px;height:2px;top:13px;left:0;clip-path:polygon(0 0,38% 0,38% 100%,0 100%,0 0,62% 0,62% 100%,100% 100%,100% 0,62% 0)}
#hpBar{position:absolute;top:20px;left:20px;width:260px;height:22px;background:rgba(0,0,0,.75);border:2px solid #f33;border-radius:4px;box-shadow:0 0 12px rgba(255,0,0,.3),inset 0 1px 3px rgba(0,0,0,.5)}
#hpFill{width:100%;height:100%;background:linear-gradient(90deg,#c00,#f44);border-radius:2px;transition:width .3s ease-out;box-shadow:0 0 8px rgba(255,50,50,.4)}
#hpTxt{position:absolute;top:21px;left:290px;color:#fff;font-size:16px;font-weight:bold;text-shadow:0 0 8px #f00,0 1px 3px rgba(0,0,0,.8)}
#ammoTxt{position:absolute;bottom:40px;right:40px;color:#fff;font-size:26px;text-shadow:0 0 10px #0ff,0 0 20px rgba(0,255,255,.2);font-weight:bold;font-family:'Courier New',monospace}
#objTxt{position:absolute;top:55px;left:20px;color:#ffe066;font-size:15px;text-shadow:0 0 6px rgba(170,170,0,.6),0 1px 3px rgba(0,0,0,.8);line-height:1.7}
#timerTxt{position:absolute;top:12%;left:50%;transform:translateX(-50%);color:#f33;font-size:48px;font-weight:bold;text-shadow:0 0 20px #f00,0 0 40px rgba(255,0,0,.3);display:none;font-family:'Courier New',monospace;letter-spacing:3px}
#bloodOverlay{position:absolute;top:0;left:0;width:100%;height:100%;background:radial-gradient(ellipse,transparent 40%,rgba(180,0,0,.6));opacity:0;transition:opacity .4s;pointer-events:none}
#hitMarker{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#f22;font-size:32px;font-weight:bold;opacity:0;pointer-events:none;text-shadow:0 0 10px #f00,0 0 20px rgba(255,0,0,.3)}
#infoTxt{position:absolute;bottom:100px;left:50%;transform:translateX(-50%);color:#ffe066;font-size:17px;text-shadow:0 0 10px rgba(255,230,0,.5),0 1px 4px rgba(0,0,0,.8);display:none;text-align:center;padding:8px 20px;background:rgba(0,0,0,.45);border-radius:6px;backdrop-filter:blur(3px)}
#medkitTxt{position:absolute;bottom:50px;left:20px;color:#0f0;font-size:16px;padding:6px 14px;background:rgba(0,0,0,.65);border:1px solid rgba(0,255,0,.2);border-radius:6px;display:none;text-shadow:0 0 6px #0f0}
#staminaBar{position:absolute;bottom:20px;left:50%;transform:translateX(-50%);width:200px;height:7px;background:rgba(0,0,0,.7);border:1px solid rgba(0,200,255,.4);border-radius:3px;display:none;box-shadow:0 0 6px rgba(0,180,255,.15)}
#staminaFill{width:100%;height:100%;background:linear-gradient(90deg,#0af,#0ff);border-radius:2px;transition:width .15s ease-out;box-shadow:0 0 4px rgba(0,220,255,.3)}
#scopeOverlay{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;display:none;z-index:50}
#scopeOverlay canvas{width:100%;height:100%}
#reloadBar{position:absolute;bottom:72px;right:40px;width:130px;height:7px;background:rgba(0,0,0,.7);border:1px solid #0ff;display:none;border-radius:3px;box-shadow:0 0 6px rgba(0,255,255,.15)}
#reloadFill{width:0%;height:100%;background:linear-gradient(90deg,#08c,#0ff);border-radius:2px;transition:width .05s linear;box-shadow:0 0 4px rgba(0,255,255,.3)}
.screen{position:absolute;top:0;left:0;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;background:rgba(0,0,0,.92);z-index:200;pointer-events:auto}
.screen h1{font-size:46px;margin-bottom:10px;letter-spacing:4px}
.screen h2{font-size:18px;color:#aaa;margin-bottom:30px;letter-spacing:6px}
.screen p{font-size:15px;max-width:420px;text-align:center;margin-bottom:25px;line-height:1.5}
.screen button{padding:14px 50px;font-size:18px;background:transparent;border:2px solid;cursor:pointer;text-transform:uppercase;letter-spacing:3px;transition:all .3s;margin:10px;min-width:280px;border-radius:4px;backdrop-filter:blur(4px)}
#menuScreen h1{color:#f44;text-shadow:0 0 30px #f00}
#menuScreen button{color:#0f0;border-color:#0f0}
#menuScreen button:hover{background:#0f0;color:#000;box-shadow:0 0 30px #0f0,0 0 60px rgba(0,255,0,.2)}
#deathScreen{display:none}
#deathScreen h1{color:#f00;text-shadow:0 0 30px #f00,0 0 60px rgba(255,0,0,.2)}
#deathScreen p{color:#fbb;font-size:16px;line-height:1.6}
#deathScreen button{color:#f66;border-color:#f66}
#deathScreen button:hover{background:#f66;color:#000;box-shadow:0 0 30px #f66,0 0 60px rgba(255,100,100,.2)}
#winScreen{display:none}
#winScreen h1{color:#0f0;text-shadow:0 0 30px #0f0,0 0 60px rgba(0,255,0,.2)}
#winScreen p{color:#bfb;font-size:18px;line-height:1.6}
#winScreen button{color:#0f0;border-color:#0f0}
#winScreen button:hover{background:#0f0;color:#000;box-shadow:0 0 30px #0f0,0 0 60px rgba(0,255,0,.2)}
#minimap{position:absolute;bottom:16px;left:16px;width:150px;height:150px;border:2px solid rgba(0,255,0,.45);background:rgba(0,0,0,.7);image-rendering:pixelated;border-radius:4px;box-shadow:0 0 10px rgba(0,255,0,.1),0 2px 8px rgba(0,0,0,.5)}
#shopScreen,#tradeScreen{display:none;overflow-y:auto}
.shopItem{width:148px;padding:14px 12px;border:2px solid rgba(0,255,0,.5);background:rgba(0,40,0,.45);text-align:center;cursor:pointer;transition:all .3s;pointer-events:auto;border-radius:6px;backdrop-filter:blur(3px)}
.shopItem:hover{background:rgba(0,100,0,.5);box-shadow:0 0 20px rgba(0,255,0,.3);border-color:#0f0;transform:translateY(-2px)}
.sName{color:#0f0;font-size:15px;margin-bottom:6px;font-weight:bold;text-shadow:0 0 4px rgba(0,255,0,.3)}
.sPrice{color:#ffe066;font-size:14px;font-weight:bold}
.sDesc{color:#aaa;font-size:12px;margin-top:4px;line-height:1.3}
#helmetOverlay{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;display:none;z-index:10;
  background:
    radial-gradient(ellipse at center,transparent 50%,rgba(0,0,0,0.35) 80%,rgba(0,0,0,0.65) 100%),
    linear-gradient(180deg,rgba(10,20,10,0.18) 0%,rgba(5,15,5,0.08) 30%,rgba(5,15,5,0.08) 70%,rgba(10,20,10,0.22) 100%);
  border:4px solid rgba(30,40,30,0.35);border-radius:8px;
  box-shadow:inset 0 0 80px rgba(0,0,0,0.3),inset 0 0 20px rgba(20,40,20,0.15)}
#helmetCrackCanvas{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;display:none;z-index:11}
#headshotTxt{position:absolute;top:42%;left:50%;transform:translate(-50%,-50%);color:#ff0;font-size:30px;font-weight:bold;opacity:0;pointer-events:none;text-shadow:0 0 12px #ff0,0 0 30px rgba(255,255,0,.5),0 0 50px rgba(255,200,0,.2);z-index:60;letter-spacing:4px}
#jugHud{position:absolute;top:55px;right:20px;color:#fa0;font-size:16px;text-shadow:0 0 8px #fa0,0 1px 3px rgba(0,0,0,.8);display:none;text-align:right;line-height:1.7;font-family:'Courier New',monospace}
#bodycamOverlay{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:8}
#bodycamRec{position:absolute;top:16px;right:16px;font-size:14px;font-family:'Courier New',monospace;color:#f44;text-shadow:0 0 8px rgba(255,0,0,.6);letter-spacing:2px}
#bodycamRec .recDot{display:inline-block;width:8px;height:8px;border-radius:50%;background:#f00;margin-right:5px;box-shadow:0 0 6px #f00;animation:recBlink 1s infinite}
@keyframes recBlink{0%,100%{opacity:1}50%{opacity:0.2}}
#bodycamTime{position:absolute;bottom:16px;right:16px;font-size:12px;font-family:'Courier New',monospace;color:rgba(255,255,255,.55);text-shadow:0 0 4px rgba(255,255,255,.2);letter-spacing:1px}
#bodycamId{position:absolute;top:16px;left:16px;font-size:11px;font-family:'Courier New',monospace;color:rgba(255,255,255,.4);text-shadow:0 0 3px rgba(255,255,255,.15);letter-spacing:1px}
#scanLines{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;
  background:repeating-linear-gradient(0deg,transparent,transparent 2px,rgba(0,0,0,0.03) 2px,rgba(0,0,0,0.03) 4px);z-index:9}
#allyLabels{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:12;overflow:hidden}
.allyLabel{position:absolute;color:#0f0;font-size:14px;font-family:'Courier New',monospace;text-align:center;text-shadow:0 0 8px #0f0,0 1px 4px rgba(0,0,0,.9);transform:translateX(-50%);white-space:nowrap;font-weight:bold;letter-spacing:1px}
.allyLabel.medic{color:#4af;text-shadow:0 0 6px #4af,0 1px 3px rgba(0,0,0,.8)}
.allyLabel.dumb{color:#f8a;text-shadow:0 0 6px #f8a,0 1px 3px rgba(0,0,0,.8)}
.allyLabel.dead{color:#888;text-decoration:line-through;font-size:13px}
.allyLabel.defender{color:#0f0}
.allyHpBar{width:58px;height:5px;background:rgba(0,0,0,.75);margin:3px auto;border:1px solid rgba(0,255,0,.4);border-radius:2px;box-shadow:0 0 3px rgba(0,0,0,.5)}
.allyHpFill{height:100%;background:#0f0;transition:width .3s ease-out;border-radius:1px}
.allyLabel.medic .allyHpBar{border-color:rgba(80,160,255,.4)}
.allyLabel.medic .allyHpFill{background:#4af}
.gfxRow{display:flex;align-items:center;gap:12px;margin:6px 0;width:360px;justify-content:space-between}
.gfxRow label{color:#ccc;font-size:14px;min-width:110px;text-align:left}
.gfxRow input[type=range]{flex:1;accent-color:#0f0;cursor:pointer;height:6px}
.gfxRow .gfxVal{color:#0f0;font-size:14px;min-width:50px;text-align:right;font-family:'Courier New',monospace;font-weight:bold}
#droneOverlay{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;display:none;z-index:25;border:3px solid #0f0;box-shadow:inset 0 0 50px rgba(0,255,0,0.15),inset 0 0 120px rgba(0,255,0,0.05)}
#droneHud{position:absolute;top:50px;left:50%;transform:translateX(-50%);color:#0f0;font-size:15px;font-family:'Courier New',monospace;text-shadow:0 0 8px #0f0,0 1px 3px rgba(0,0,0,.8);display:none;z-index:26;text-align:center}
#commandWheel{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);width:220px;height:220px;display:none;z-index:30;pointer-events:auto}
.cmdOpt{position:absolute;padding:10px 16px;background:rgba(0,0,0,.88);border:1px solid #0f0;color:#0f0;font-size:13px;cursor:pointer;font-family:'Courier New',monospace;text-shadow:0 0 4px #0f0;white-space:nowrap;transition:all .2s;border-radius:4px;backdrop-filter:blur(3px)}
.cmdOpt:hover{background:rgba(0,100,0,.5);box-shadow:0 0 15px rgba(0,255,0,.4);border-color:#4f4}
#woundHud{position:absolute;top:65px;right:20px;color:#f55;font-size:13px;font-family:'Courier New',monospace;text-shadow:0 0 6px #f00,0 1px 3px rgba(0,0,0,.8);display:none;line-height:1.6;padding:4px 8px;background:rgba(40,0,0,.3);border-radius:4px}
#equipHud{position:absolute;top:46px;left:290px;color:#bbb;font-size:12px;font-family:'Courier New',monospace;display:none;line-height:1.5;text-shadow:0 1px 3px rgba(0,0,0,.8)}
#zoneWarning{position:absolute;top:15%;left:50%;transform:translateX(-50%);color:#f22;font-size:32px;font-weight:bold;text-shadow:0 0 20px #f00,0 0 40px rgba(255,0,0,.3);display:none;animation:zoneFlash 1s infinite;z-index:20;letter-spacing:3px}
@keyframes zoneFlash{0%,100%{opacity:1}50%{opacity:.4}}
#mineIndicator{position:absolute;bottom:55px;left:150px;color:#fa0;font-size:12px;font-family:'Courier New',monospace;display:none;text-shadow:0 0 5px #fa0}
#weatherHud{position:absolute;top:8px;left:50%;transform:translateX(-50%);color:#bbddff;font-size:13px;font-family:'Courier New',monospace;display:none;text-shadow:0 0 6px #48f,0 1px 3px rgba(0,0,0,.8)}
#mapEditorScreen{display:none;overflow:auto}
#mapEditorScreen canvas{border:2px solid #0f0;cursor:crosshair;image-rendering:pixelated}
.edTool{padding:8px 14px;margin:3px;background:rgba(0,40,0,.5);border:1px solid #0f0;color:#0f0;cursor:pointer;font-size:13px;display:inline-block;border-radius:4px;transition:all .2s}
.edTool:hover{background:rgba(0,80,0,.5)}
.edTool.active{background:rgba(0,100,0,.5);box-shadow:0 0 10px #0f0}
#gravGunHud{position:absolute;bottom:120px;right:40px;color:#af0;font-size:13px;font-family:'Courier New',monospace;display:none;text-shadow:0 0 5px #af0}
</style>
</head>
<body>
<canvas id="gl"></canvas>
<div id="ui">
 <div id="crosshair"></div>
 <div id="hpBar"><div id="hpFill"></div></div>
 <div id="hpTxt">100 HP</div>
 <div id="ammoTxt">30 / 90</div>
 <div id="objTxt"></div>
 <div id="timerTxt"></div>
 <div id="bloodOverlay"></div>
 <div id="hitMarker">X</div>
 <div id="infoTxt"></div>
 <div id="medkitTxt"></div>
 <div id="reloadBar"><div id="reloadFill"></div></div>
 <div id="staminaBar"><div id="staminaFill"></div></div>
 <div id="scopeOverlay"><canvas id="scopeCanvas"></canvas></div>
 <canvas id="minimap" width="140" height="140"></canvas>
 <div id="helmetOverlay"></div>
 <canvas id="helmetCrackCanvas"></canvas>
 <div id="headshotTxt">HEADSHOT</div>
 <div id="jugHud"></div>
 <div id="bodycamOverlay">
  <div id="bodycamRec"><span class="recDot"></span>REC</div>
  <div id="bodycamId">CAM-01 UNIT-7</div>
  <div id="bodycamTime"></div>
 </div>
 <div id="scanLines"></div>
 <div id="allyLabels"></div>
 <div id="mathHud" style="display:none;position:absolute;top:80px;left:50%;transform:translateX(-50%);font-size:42px;color:#0ff;font-family:'Courier New',monospace;text-shadow:0 0 15px #0ff,0 0 30px #08f;text-align:center;pointer-events:none;z-index:20">
  <div id="mathProblem"></div>
  <div id="mathTimer" style="font-size:24px;color:#ff0;margin-top:8px"></div>
 </div>
 <canvas id="screenBloodCanvas" style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:15"></canvas>
 <div id="weaponHud" style="position:absolute;bottom:68px;right:40px;color:#bbb;font-size:14px;font-family:'Courier New',monospace;text-shadow:0 0 6px #08f,0 1px 3px rgba(0,0,0,.8);pointer-events:none"></div>
 <div id="xpHud" style="position:absolute;top:46px;left:20px;pointer-events:none">
  <div style="width:260px;height:7px;background:rgba(0,0,0,.7);border:1px solid rgba(100,200,255,.4);border-radius:3px;box-shadow:0 0 4px rgba(0,150,255,.1)"><div id="xpFill" style="width:0%;height:100%;background:linear-gradient(90deg,#08f,#0ff);border-radius:2px;transition:width .3s ease-out;box-shadow:0 0 4px rgba(0,200,255,.3)"></div></div>
  <span id="xpTxt" style="color:#0ff;font-size:12px;text-shadow:0 0 5px #08f,0 1px 2px rgba(0,0,0,.8);font-weight:bold">LV 1 | 0/100 XP</span>
 </div>
 <div id="bulletTimeBar" style="position:absolute;bottom:32px;left:50%;transform:translateX(-50%);width:120px;height:4px;background:rgba(0,0,0,.6);border:1px solid rgba(255,200,0,.4);border-radius:2px;display:none"><div id="bulletTimeFill" style="width:100%;height:100%;background:#fa0;border-radius:1px"></div></div>
 <div id="nightVisionOverlay" style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;display:none;z-index:7;background:rgba(0,40,0,0.3);mix-blend-mode:multiply"></div>
 <div id="neonOverlay" style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;display:none;z-index:7;background:linear-gradient(135deg,rgba(255,0,255,0.04),rgba(0,255,255,0.04),rgba(255,255,0,0.03));box-shadow:inset 0 0 120px rgba(0,255,255,0.12),inset 0 0 60px rgba(255,0,255,0.08)"></div>
 <div id="vignetteOverlay" style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:5;background:radial-gradient(ellipse at center,transparent 50%,rgba(0,0,0,0.7) 100%);opacity:0"></div>
 <canvas id="rainCanvas" style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:6;display:none"></canvas>
 <div id="shieldHud" style="position:absolute;bottom:95px;right:40px;color:#4af;font-size:13px;font-family:'Courier New',monospace;display:none;pointer-events:none"></div>
 <div id="droneOverlay"></div>
 <div id="droneHud"></div>
 <div id="commandWheel">
  <div class="cmdOpt" data-cmd="follow" style="top:0;left:50%;transform:translateX(-50%)">1: За мной</div>
  <div class="cmdOpt" data-cmd="hold" style="top:50%;right:0;transform:translateY(-50%)">2: Стой</div>
  <div class="cmdOpt" data-cmd="attack" style="bottom:0;left:50%;transform:translateX(-50%)">3: Атакуй</div>
  <div class="cmdOpt" data-cmd="heal" style="top:50%;left:0;transform:translateY(-50%)">4: Лечи</div>
 </div>
 <div id="woundHud"></div>
 <div id="equipHud"></div>
 <div id="zoneWarning">ВНЕ ЗОНЫ! УРОН!</div>
 <div id="mineIndicator"></div>
 <div id="weatherHud"></div>
 <div id="gravGunHud"></div>
</div>

<div id="menuScreen" class="screen">
 <h1>ОПЕРАЦИЯ "ЗАБРОШКА"</h1>
 <h2>Operation Abandoned</h2>
 <div id="menuCoins" style="color:#ff0;font-size:18px;text-shadow:0 0 10px #ff0;margin:6px">Монеты: 0</div>
 <button id="btnStart">НАЧАТЬ МИССИЮ</button>
 <button id="btnShop" style="color:#0f0;border-color:#0f0">МАГАЗИН</button>
 <button id="btnTrade" style="color:#ff0;border-color:#ff0">ТОРГОВЛЯ</button>
 <button id="btnJuggernaut" style="color:#fa0;border-color:#fa0;display:none;text-shadow:0 0 10px #fa0">ДЖАГГЕРНАУТ</button>
 <button id="btnMath" style="color:#0ff;border-color:#0ff;text-shadow:0 0 10px #0ff">ТАБЛИЦА УМНОЖЕНИЯ</button>
 <button id="btnZombie" style="color:#a44;border-color:#a44;text-shadow:0 0 10px #a44">ЗОМБИ-ВОЛНЫ</button>
 <button id="btnBattleRoyale" style="color:#f0a;border-color:#f0a;text-shadow:0 0 10px #f0a">КОРОЛЕВСКАЯ БИТВА</button>
 <button id="btnWaveDefense" style="color:#0af;border-color:#0af;text-shadow:0 0 10px #0af">ВОЛНА ОБОРОНЫ</button>
 <button id="btnInfection" style="color:#4a0;border-color:#4a0;text-shadow:0 0 10px #4a0">ЗАРАЖЕНИЕ</button>
 <button id="btnMapEditor" style="color:#888;border-color:#888">РЕДАКТОР КАРТ</button>
 <button id="btnSettings" style="color:#aaa;border-color:#aaa">НАСТРОЙКИ</button>
 <button id="btnHelp" onclick="window.open('help.html','_blank')" style="color:#0ff;border-color:#0ff;text-shadow:0 0 10px #0ff;pointer-events:auto">ПОМОЩЬ</button>
</div>
<div id="settingsScreen" class="screen" style="display:none;overflow-y:auto">
 <h1 style="color:#aaa;text-shadow:0 0 20px #888">НАСТРОЙКИ</h1>
 <!-- Graphics preset -->
 <button id="btnGfxPreset" style="color:#0f0;border-color:#0f0;margin:10px;font-size:16px">КАЧЕСТВО: ВЫСОКАЯ</button>
 <!-- Individual graphics sliders -->
 <div style="margin:8px 0;padding:12px 20px;border:1px solid rgba(0,255,0,.2);background:rgba(0,40,0,.3);border-radius:6px">
  <div style="color:#0f0;font-size:12px;margin-bottom:8px;letter-spacing:2px;text-align:center">ГРАФИКА</div>
  <div class="gfxRow"><label>Разрешение</label><input type="range" id="gfxResRange" min="25" max="100" value="100" step="5"><span class="gfxVal" id="gfxResVal">100%</span></div>
  <div class="gfxRow"><label>Частицы</label><input type="range" id="gfxPartRange" min="30" max="500" value="300" step="10"><span class="gfxVal" id="gfxPartVal">300</span></div>
  <div class="gfxRow"><label>Туман</label><input type="range" id="gfxFogRange" min="15" max="100" value="55" step="5"><span class="gfxVal" id="gfxFogVal">55</span></div>
  <div class="gfxRow"><label>Декали крови</label><input type="range" id="gfxDecalRange" min="0" max="300" value="150" step="10"><span class="gfxVal" id="gfxDecalVal">150</span></div>
  <div class="gfxRow"><label>Куски</label><input type="range" id="gfxGibRange" min="0" max="60" value="30" step="5"><span class="gfxVal" id="gfxGibVal">30</span></div>
  <button id="btnGfxShadows" style="color:#aaa;border-color:#aaa;margin:6px;padding:6px 20px;font-size:13px">ТЕНИ: ВКЛ</button>
 </div>
 <div style="margin:8px 0;padding:12px 20px;border:1px solid rgba(0,200,255,.2);background:rgba(0,20,40,.3);border-radius:6px">
  <div style="color:#0ff;font-size:12px;margin-bottom:8px;letter-spacing:2px;text-align:center">ВИЗУАЛЬНЫЕ ЭФФЕКТЫ</div>
  <div class="gfxRow"><label>Яркость</label><input type="range" id="gfxBrightRange" min="50" max="150" value="100" step="5"><span class="gfxVal" id="gfxBrightVal">100%</span></div>
  <div class="gfxRow"><label>Контраст</label><input type="range" id="gfxContrastRange" min="50" max="150" value="105" step="5"><span class="gfxVal" id="gfxContrastVal">105%</span></div>
  <div class="gfxRow"><label>Насыщенность</label><input type="range" id="gfxSatRange" min="0" max="200" value="105" step="5"><span class="gfxVal" id="gfxSatVal">105%</span></div>
  <div class="gfxRow"><label>Виньетка</label><input type="range" id="gfxVigRange" min="0" max="100" value="15" step="5"><span class="gfxVal" id="gfxVigVal">15%</span></div>
 </div>
 <button id="btnNeon" style="color:#f0f;border-color:#f0f;margin:10px">НЕОН: ВЫКЛ</button>
 <button id="btnRain" style="color:#48f;border-color:#48f;margin:10px">ДОЖДЬ: ВЫКЛ</button>
 <div style="margin:14px;text-align:center">
  <div style="color:#888;font-size:13px;margin-bottom:8px">ЧИТ-КОД</div>
  <input id="cheatInput" type="text" style="padding:10px 18px;font-size:15px;background:rgba(0,0,0,.8);border:2px solid #555;color:#0f0;text-align:center;width:340px;font-family:'Courier New',monospace;letter-spacing:1px;outline:none" placeholder="Введите код..." autocomplete="off">
  <button id="btnCheat" style="padding:10px 24px;font-size:15px;background:transparent;border:2px solid #0f0;color:#0f0;cursor:pointer;margin-left:8px;text-transform:uppercase;letter-spacing:2px;transition:all .3s;vertical-align:middle">ВВЕСТИ</button>
  <div id="cheatMsg" style="color:#0f0;font-size:14px;min-height:22px;margin-top:8px"></div>
 </div>
 <button onclick="window.open('help.html','_blank')" style="color:#0ff;border-color:#0ff;text-shadow:0 0 10px #0ff;pointer-events:auto;margin-top:6px">ПОМОЩЬ</button>
 <button id="btnSettingsBack" style="color:#aaa;border-color:#aaa;margin-top:10px">НАЗАД</button>
</div>
<div id="confirmGore" style="display:none;position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.88);z-index:300;pointer-events:auto;flex-direction:column;align-items:center;justify-content:center">
 <div style="border:2px solid #f44;padding:35px 55px;background:rgba(40,0,0,.9);text-align:center;max-width:420px;border-radius:8px;box-shadow:0 0 40px rgba(255,50,50,.15)">
  <p style="color:#f99;font-size:19px;margin-bottom:24px;line-height:1.5">Вы уверены что хотите это включить?</p>
  <button id="confirmGoreYes" style="padding:12px 36px;font-size:16px;background:transparent;border:2px solid #f44;color:#f44;cursor:pointer;margin:8px;text-transform:uppercase;letter-spacing:2px;border-radius:4px;transition:all .3s">ДА</button>
  <button id="confirmGoreNo" style="padding:12px 36px;font-size:16px;background:transparent;border:2px solid #aaa;color:#aaa;cursor:pointer;margin:8px;text-transform:uppercase;letter-spacing:2px;border-radius:4px;transition:all .3s">НЕТ</button>
 </div>
</div>
<div id="shopScreen" class="screen">
 <h1 style="color:#0f0;text-shadow:0 0 20px #0f0">МАГАЗИН</h1>
 <div id="shopCoins" style="color:#ff0;font-size:18px;text-shadow:0 0 10px #ff0;margin:6px">Монеты: 0</div>
 <div id="shopMsg" style="color:#0f0;font-size:14px;min-height:20px;margin:4px"></div>
 <div style="display:flex;gap:12px;flex-wrap:wrap;justify-content:center;margin:12px;max-width:650px">
  <div class="shopItem" id="buy_ammo"><div class="sName">Патроны x60</div><div class="sPrice">5 монет</div><div class="sDesc">+60 запасных</div></div>
  <div class="shopItem" id="buy_medkit"><div class="sName">Аптечка</div><div class="sPrice">10 монет</div><div class="sDesc">Лечит 50HP (H)</div></div>
  <div class="shopItem" id="buy_armor"><div class="sName">Бронежилет+</div><div class="sPrice">15 монет</div><div class="sDesc" id="armorDesc">+50 макс HP</div></div>
  <div class="shopItem" id="buy_weapon"><div class="sName">Улучш. Автомат</div><div class="sPrice">25 монет</div><div class="sDesc">+15 урон</div></div>
  <div class="shopItem" id="buy_bag"><div class="sName">Мешок</div><div class="sPrice">8 монет</div><div class="sDesc">На голову врагу</div></div>
  <div class="shopItem" id="buy_cuffs"><div class="sName">Наручники</div><div class="sPrice">12 монет</div><div class="sDesc">Обездвижить врага</div></div>
  <div class="shopItem" id="buy_double"><div class="sName">×2 Награда</div><div class="sPrice">15 монет</div><div class="sDesc">40 монет за ответ</div></div>
  <div class="shopItem" id="buy_freeze"><div class="sName">Заморозка</div><div class="sPrice">12 монет</div><div class="sDesc">Враги стоят 15с</div></div>
  <div class="shopItem" id="buy_grenade"><div class="sName">Гранаты ×3</div><div class="sPrice">10 монет</div><div class="sDesc">Взрыв (клав. T)</div></div>
  <div class="shopItem" id="buy_pierce"><div class="sName">Бронебойные</div><div class="sPrice">20 монет</div><div class="sDesc">Урон ×2, 1 миссия</div></div>
  <div class="shopItem" id="buy_gold"><div class="sName">Золотой скин</div><div class="sPrice">50 монет</div><div class="sDesc">Золотое оружие</div></div>
  <div class="shopItem" id="buy_camo"><div class="sName">Камуфляж</div><div class="sPrice">15 монет</div><div class="sDesc">Разная форма врагов</div></div>
  <div class="shopItem" id="buy_shotgun"><div class="sName">Дробовик</div><div class="sPrice">30 монет</div><div class="sDesc">8 дробин, клав 2</div></div>
  <div class="shopItem" id="buy_pistol"><div class="sName">Пистолет</div><div class="sPrice">10 монет</div><div class="sDesc">Быстрый, клав 3</div></div>
  <div class="shopItem" id="buy_sniper"><div class="sName">Снайперка</div><div class="sPrice">40 монет</div><div class="sDesc">200 урон, клав 4</div></div>
  <div class="shopItem" id="buy_shield"><div class="sName">Щит</div><div class="sPrice">20 монет</div><div class="sDesc">ПКМ блок 200HP</div></div>
  <div class="shopItem" id="buy_bullettime"><div class="sName">Замедление</div><div class="sPrice">15 монет</div><div class="sDesc">Z — время ×0.3</div></div>
  <div class="shopItem" id="buy_nvg"><div class="sName">Ночное зрение</div><div class="sPrice">18 монет</div><div class="sDesc">N — зелёный фильтр</div></div>
  <div class="shopItem" id="buy_flashlight"><div class="sName">Фонарик</div><div class="sPrice">8 монет</div><div class="sDesc">F — подсветка</div></div>
  <div class="shopItem" id="buy_glitch" style="display:none"><div class="sName">Глитч-пушка</div><div class="sPrice">500 монет</div><div class="sDesc">Враги → союзники [5]</div></div>
  <div class="shopItem" id="buy_mine"><div class="sName">Мины ×3</div><div class="sPrice">12 монет</div><div class="sDesc">Ставь [C], 120 урон</div></div>
  <div class="shopItem" id="buy_akimbo"><div class="sName">Двойн. Пистолет</div><div class="sPrice">25 монет</div><div class="sDesc">2× скорость, [M]</div></div>
  <div class="shopItem" id="buy_eqhelmet"><div class="sName">Каска</div><div class="sPrice">20 монет</div><div class="sDesc">Голова -50% урон</div></div>
  <div class="shopItem" id="buy_eqvest"><div class="sName">Бронежилет ТАК</div><div class="sPrice">25 монет</div><div class="sDesc">Тело -40% урон</div></div>
  <div class="shopItem" id="buy_eqknees"><div class="sName">Наколенники</div><div class="sPrice">15 монет</div><div class="sDesc">Ноги -30% урон</div></div>
  <div class="shopItem" id="buy_drone"><div class="sName">Дрон</div><div class="sPrice">30 монет</div><div class="sDesc">[V] разведка 10с</div></div>
  <div class="shopItem" id="buy_gravgun"><div class="sName">Грав. Пушка</div><div class="sPrice">35 монет</div><div class="sDesc">[6] кидать объекты</div></div>
 </div>
 <button id="btnShopBack" style="color:#0f0;border-color:#0f0">НАЗАД</button>
</div>
<div id="tradeScreen" class="screen">
 <h1 style="color:#ff0;text-shadow:0 0 20px #ff0">ТОРГОВЛЯ</h1>
 <div id="tradeCoins" style="color:#ff0;font-size:18px;text-shadow:0 0 10px #ff0;margin:6px">Монеты: 0</div>
 <div id="tradeMsg" style="color:#ff0;font-size:14px;min-height:20px;margin:4px"></div>
 <div id="tradeItems" style="text-align:center;margin:12px"><p style="color:#888">Собирай лут с трупов врагов [F] и продавай тут!</p></div>
 <button id="btnSellAll" style="color:#ff0;border-color:#ff0;display:none">ПРОДАТЬ ВСЁ</button>
 <button id="btnTradeBack" style="color:#ff0;border-color:#ff0;margin-top:8px">НАЗАД</button>
</div>
<div id="deathScreen" class="screen">
 <h1>ТЫ ПОГИБ</h1>
 <p>Ты умер от выстрелов, машина уехала и оставила тебя помирать</p>
 <p id="deathKills" style="color:#fa0;font-size:16px;display:none"></p>
 <button id="btnRetry">НАЧАТЬ ЗАНОВО</button>
 <button id="btnDeathMenu" style="color:#aaa;border-color:#aaa">В МЕНЮ</button>
 <button onclick="window.open('help.html','_blank')" style="color:#0ff;border-color:#0ff;text-shadow:0 0 10px #0ff;pointer-events:auto">ПОМОЩЬ</button>
</div>
<div id="winScreen" class="screen">
 <h1>ПОБЕДА!</h1>
 <p>Эвакуация успешна! +40 монет</p>
 <button id="btnNext">ИГРАТЬ СНОВА</button>
 <button id="btnWinMenu" style="color:#aaa;border-color:#aaa">В МЕНЮ</button>
 <button onclick="window.open('help.html','_blank')" style="color:#0ff;border-color:#0ff;text-shadow:0 0 10px #0ff;pointer-events:auto">ПОМОЩЬ</button>
</div>

<div id="mapEditorScreen" class="screen" style="display:none">
 <h1 style="color:#0f0;text-shadow:0 0 20px #0f0;font-size:28px">РЕДАКТОР КАРТ</h1>
 <div style="margin:8px">
  <span class="edTool active" data-t="1">Стена</span>
  <span class="edTool" data-t="0">Пусто</span>
  <span class="edTool" data-t="2">Ящик</span>
  <span class="edTool" data-t="3">Враг</span>
  <span class="edTool" data-t="4">Деньги</span>
  <span class="edTool" data-t="5">Машина</span>
  <span class="edTool" data-t="6">Спавн</span>
 </div>
 <canvas id="editorCanvas" width="440" height="340"></canvas>
 <div style="margin:8px">
  <button id="btnEdSave" style="color:#0f0;border-color:#0f0;padding:8px 20px;font-size:13px">СОХРАНИТЬ</button>
  <button id="btnEdLoad" style="color:#ff0;border-color:#ff0;padding:8px 20px;font-size:13px">ЗАГРУЗИТЬ</button>
  <button id="btnEdReset" style="color:#f44;border-color:#f44;padding:8px 20px;font-size:13px">СБРОС</button>
  <button id="btnEdPlay" style="color:#0ff;border-color:#0ff;padding:8px 20px;font-size:13px">ИГРАТЬ</button>
  <button id="btnEdBack" style="color:#aaa;border-color:#aaa;padding:8px 20px;font-size:13px">НАЗАД</button>
 </div>
 <div id="editorMsg" style="color:#0f0;font-size:13px;min-height:18px;margin:4px"></div>
</div>
<script>
"use strict";

/* ============================================================
   CONFIG
   ============================================================ */
const CELL = 4;
const WALL_H = 4;
const CRATE_H = 2;
const PLAYER_R = 0.45;
const PLAYER_H = 1.7;
const GRAVITY = 18;
const JUMP_V = 7;
const MOVE_SPEED = 7;
const MOUSE_SENS = 0.002;
const BULLET_DMG = 35;
const ENEMY_DMG = 20;
const BLEED_DPS = 1;
const MAX_HP = 100;
const MAG_SIZE = 30;
const RESERVE_AMMO = 90;
const RELOAD_TIME = 2.0;
const SHOOT_CD = 0.12;
const SPRINT_MULT = 1.6;
const STAMINA_MAX = 100;
const STAMINA_DRAIN = 25; // per sec while sprinting
const STAMINA_REGEN = 15; // per sec while not sprinting
const EVAC_TIME = 45;
const FOG_DIST = 55;

/* ============================================================
   LEVEL MAP
   0=empty 1=wall 2=crate 3=enemy 4=money 5=car 6=spawn
   ============================================================ */
const MAP = [
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
[1,6,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
[1,0,0,0,1,0,3,0,0,0,0,1,0,0,0,0,3,0,0,0,0,1],
[1,0,0,0,0,0,0,0,2,0,0,0,0,0,2,0,0,0,0,4,0,1],
[1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,0,0,1,0,0,0,0,0,2,0,0,1,1,1,0,1,1,1,1,1],
[1,0,3,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,0,0,0,1],
[1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,3,0,0,4,0,1],
[1,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,1,1,1,0,0,0,0,2,2,0,0,0,1,1,0,1,1,1,1,1,1],
[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
[1,0,4,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,3,0,0,1],
[1,0,0,0,1,1,0,1,1,1,1,0,0,0,0,2,0,0,0,0,0,1],
[1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,2,0,0,0,0,0,1],
[1,3,0,0,1,0,5,5,0,0,1,0,0,0,0,0,0,0,3,0,0,1],
[1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1],
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];
const MAP_H = MAP.length, MAP_W = MAP[0].length;

/* ============================================================
   GL INIT
   ============================================================ */
// gfxResScale declared early so resize() works before game state init
var _gfxRes=1.0;
const canvas = document.getElementById('gl');
const gl = canvas.getContext('webgl', {antialias:true, alpha:false});
if (!gl) { alert('WebGL not supported'); throw 'no gl'; }

function resize() {
  canvas.width = Math.round(window.innerWidth*_gfxRes);
  canvas.height = Math.round(window.innerHeight*_gfxRes);
  gl.viewport(0, 0, canvas.width, canvas.height);
}
window.addEventListener('resize', resize);
resize();

gl.enable(gl.DEPTH_TEST);
gl.clearColor(0.05, 0.05, 0.12, 1);

/* ============================================================
   SHADER HELPERS
   ============================================================ */
function compileShader(src, type) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
    const err = gl.getShaderInfoLog(s);
    console.error('Shader error:', err);
    document.title = 'SHADER ERROR: ' + err;
    return null;
  }
  return s;
}
function createProgram(vsSrc, fsSrc) {
  const vs = compileShader(vsSrc, gl.VERTEX_SHADER);
  const fs = compileShader(fsSrc, gl.FRAGMENT_SHADER);
  if (!vs || !fs) return null;
  const p = gl.createProgram();
  gl.attachShader(p, vs);
  gl.attachShader(p, fs);
  gl.linkProgram(p);
  if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
    const err = gl.getProgramInfoLog(p);
    console.error('Program link error:', err);
    document.title = 'LINK ERROR: ' + err;
    return null;
  }
  return p;
}
function getUniforms(prog, names) {
  const u = {};
  for (const n of names) u[n] = gl.getUniformLocation(prog, n);
  return u;
}

/* ============================================================
   SHADERS
   ============================================================ */
// World shader
const worldVS = `
attribute vec3 aP;
attribute vec2 aU;
attribute vec3 aN;
uniform mat4 uVP;
uniform float uFog;
varying vec2 vU;
varying float vL;
varying float vF;
void main(){
  vU=aU;
  vec3 ld=normalize(vec3(0.3,1.0,0.2));
  vL=0.55+0.45*max(dot(aN,ld),0.0);
  vec4 p=uVP*vec4(aP,1.0);
  vF=clamp(p.w/uFog,0.0,1.0);
  gl_Position=p;
}`;
const worldFS = `
precision mediump float;
uniform sampler2D uTex;
varying vec2 vU;
varying float vL;
varying float vF;
void main(){
  vec4 c=texture2D(uTex,vU);
  vec3 fog=vec3(0.05,0.05,0.12);
  gl_FragColor=vec4(mix(c.rgb*vL,fog,vF),1.0);
}`;

// Billboard shader (enemies)
const billVS = `
attribute vec2 aP;
attribute vec2 aU;
uniform mat4 uVP;
uniform vec3 uPos;
uniform vec2 uSize;
uniform vec3 uRight;
uniform vec3 uUp;
uniform float uFog;
varying vec2 vU;
varying float vF;
void main(){
  vec3 wp=uPos+uRight*aP.x*uSize.x+uUp*aP.y*uSize.y;
  vec4 p=uVP*vec4(wp,1.0);
  vU=aU;
  vF=clamp(p.w/uFog,0.0,1.0);
  gl_Position=p;
}`;
const billFS = `
precision mediump float;
uniform sampler2D uTex;
uniform float uFlash;
varying vec2 vU;
varying float vF;
void main(){
  vec4 c=texture2D(uTex,vU);
  if(c.a<0.3)discard;
  vec3 fog=vec3(0.05,0.05,0.12);
  vec3 col=mix(c.rgb,vec3(1.0,0.2,0.2),uFlash);
  gl_FragColor=vec4(mix(col,fog,vF),1.0);
}`;

// Particle shader (point sprites)
const partVS = `
attribute vec3 aP;
attribute vec4 aCol;
attribute float aSize;
uniform mat4 uVP;
varying vec4 vC;
void main(){
  vec4 p=uVP*vec4(aP,1.0);
  gl_Position=p;
  gl_PointSize=aSize*300.0/max(p.w,1.0);
  vC=aCol;
}`;
const partFS = `
precision mediump float;
varying vec4 vC;
void main(){
  vec2 d=gl_PointCoord-0.5;
  float a=1.0-length(d)*2.0;
  if(a<0.0)discard;
  gl_FragColor=vec4(vC.rgb,vC.a*a);
}`;

// Entity shader (3D box enemies with colored parts)
const entityVS = `
attribute vec3 aP;
attribute vec3 aN;
uniform mat4 uVP;
uniform mat4 uM;
uniform float uFog;
uniform float uAO;
varying float vL;
varying float vF;
void main(){
  vec4 wp=uM*vec4(aP,1.0);
  vec3 wn=normalize(mat3(uM)*aN);
  vec3 ld=normalize(vec3(0.3,1.0,0.2));
  float ao=1.0-uAO*0.3*max(-wn.y,0.0);
  vL=(0.55+0.45*max(dot(wn,ld),0.0))*ao;
  vec4 p=uVP*wp;
  vF=clamp(p.w/uFog,0.0,1.0);
  gl_Position=p;
}`;
const entityFS = `
precision mediump float;
uniform vec3 uCol;
uniform float uFlash;
varying float vL;
varying float vF;
void main(){
  vec3 fog=vec3(0.05,0.05,0.12);
  vec3 c=mix(uCol,vec3(1.0,0.2,0.2),uFlash);
  gl_FragColor=vec4(mix(c*vL,fog,vF),1.0);
}`;

// Create programs
const worldProg = createProgram(worldVS, worldFS);
const worldU = getUniforms(worldProg, ['uVP','uTex','uFog']);
const worldAP = gl.getAttribLocation(worldProg, 'aP');
const worldAU = gl.getAttribLocation(worldProg, 'aU');
const worldAN = gl.getAttribLocation(worldProg, 'aN');

const billProg = createProgram(billVS, billFS);
const billU = getUniforms(billProg, ['uVP','uTex','uPos','uSize','uRight','uUp','uFlash','uFog']);
const billAP = gl.getAttribLocation(billProg, 'aP');
const billAU = gl.getAttribLocation(billProg, 'aU');

const partProg = createProgram(partVS, partFS);
const partU = getUniforms(partProg, ['uVP']);
const partAP = gl.getAttribLocation(partProg, 'aP');
const partAC = gl.getAttribLocation(partProg, 'aCol');
const partAS = gl.getAttribLocation(partProg, 'aSize');

const entityProg = createProgram(entityVS, entityFS);
const entityU = getUniforms(entityProg, ['uVP','uM','uCol','uFlash','uFog','uAO']);
const entityAP = gl.getAttribLocation(entityProg, 'aP');
const entityAN = gl.getAttribLocation(entityProg, 'aN');

/* ============================================================
   MATH
   ============================================================ */
function perspective(fov, asp, near, far) {
  const f = 1 / Math.tan(fov / 2), nf = 1 / (near - far);
  return new Float32Array([f/asp,0,0,0, 0,f,0,0, 0,0,(far+near)*nf,-1, 0,0,2*far*near*nf,0]);
}
function viewMatrix(px,py,pz,yaw,pitch) {
  const cy=Math.cos(yaw),sy=Math.sin(yaw),cp=Math.cos(pitch),sp=Math.sin(pitch);
  const fx=-sy*cp, fy=sp, fz=-cy*cp;
  const rx=cy, ry=0, rz=-sy;
  const ux=ry*fz-rz*fy, uy=rz*fx-rx*fz, uz=rx*fy-ry*fx;
  return new Float32Array([
    rx,ux,-fx,0, ry,uy,-fy,0, rz,uz,-fz,0,
    -(rx*px+ry*py+rz*pz),-(ux*px+uy*py+uz*pz),(fx*px+fy*py+fz*pz),1
  ]);
}
function mat4Mul(a, b) {
  const r = new Float32Array(16);
  for (let j=0;j<4;j++) for (let i=0;i<4;i++)
    r[i+j*4]=a[i]*b[j*4]+a[i+4]*b[j*4+1]+a[i+8]*b[j*4+2]+a[i+12]*b[j*4+3];
  return r;
}
function mat4T(tx,ty,tz){return new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, tx,ty,tz,1]);}
function mat4S(sx,sy,sz){return new Float32Array([sx,0,0,0, 0,sy,0,0, 0,0,sz,0, 0,0,0,1]);}
function mat4RY(a){const c=Math.cos(a),s=Math.sin(a);return new Float32Array([c,0,s,0, 0,1,0,0, -s,0,c,0, 0,0,0,1]);}
function mat4RX(a){const c=Math.cos(a),s=Math.sin(a);return new Float32Array([1,0,0,0, 0,c,-s,0, 0,s,c,0, 0,0,0,1]);}
function mat4RZ(a){const c=Math.cos(a),s=Math.sin(a);return new Float32Array([c,-s,0,0, s,c,0,0, 0,0,1,0, 0,0,0,1]);}

/* ============================================================
   PROCEDURAL TEXTURES
   ============================================================ */
function makeTex(w,h,fn){
  const c=document.createElement('canvas');c.width=w;c.height=h;
  const ctx=c.getContext('2d');fn(ctx,w,h);
  const tex=gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D,tex);
  gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,c);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR_MIPMAP_LINEAR);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.REPEAT);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.REPEAT);
  gl.generateMipmap(gl.TEXTURE_2D);
  return tex;
}
function addNoise(ctx,w,h,n,a){
  for(let i=0;i<n;i++){
    const v=Math.random()*40|0;
    ctx.fillStyle=`rgba(${v},${v},${v},${a})`;
    ctx.fillRect(Math.random()*w|0,Math.random()*h|0,2,2);
  }
}

const texWall = makeTex(128,128,(ctx,w,h)=>{
  ctx.fillStyle='#899';ctx.fillRect(0,0,w,h);
  addNoise(ctx,w,h,3000,0.4);
  ctx.strokeStyle='rgba(0,0,0,0.25)';ctx.lineWidth=1;
  for(let i=0;i<6;i++){ctx.beginPath();ctx.moveTo(Math.random()*w,Math.random()*h);ctx.lineTo(Math.random()*w,Math.random()*h);ctx.stroke();}
  // Brick pattern
  ctx.strokeStyle='rgba(0,0,0,0.15)';ctx.lineWidth=1;
  for(let y=0;y<h;y+=16){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(w,y);ctx.stroke();}
  for(let y=0;y<h;y+=32)for(let x=(y%64===0)?0:32;x<w;x+=64){ctx.beginPath();ctx.moveTo(x,y);ctx.lineTo(x,y+16);ctx.stroke();}
});

const texFloor = makeTex(128,128,(ctx,w,h)=>{
  ctx.fillStyle='#555';ctx.fillRect(0,0,w,h);
  ctx.strokeStyle='#666';ctx.lineWidth=1;
  for(let i=0;i<=w;i+=32){ctx.beginPath();ctx.moveTo(i,0);ctx.lineTo(i,h);ctx.stroke();ctx.beginPath();ctx.moveTo(0,i);ctx.lineTo(w,i);ctx.stroke();}
  addNoise(ctx,w,h,2000,0.25);
});

const texCeil = makeTex(128,128,(ctx,w,h)=>{
  ctx.fillStyle='#667';ctx.fillRect(0,0,w,h);
  ctx.strokeStyle='#778';ctx.lineWidth=1;
  for(let i=0;i<=w;i+=64){ctx.beginPath();ctx.moveTo(i,0);ctx.lineTo(i,h);ctx.stroke();ctx.beginPath();ctx.moveTo(0,i);ctx.lineTo(w,i);ctx.stroke();}
  addNoise(ctx,w,h,1500,0.2);
});

const texCrate = makeTex(128,128,(ctx,w,h)=>{
  ctx.fillStyle='#764';ctx.fillRect(0,0,w,h);
  ctx.strokeStyle='rgba(0,0,0,0.15)';
  for(let y=0;y<h;y+=3){ctx.beginPath();ctx.moveTo(0,y+Math.sin(y*0.1)*2);ctx.lineTo(w,y+Math.sin(y*0.1+1)*2);ctx.stroke();}
  ctx.strokeStyle='#543';ctx.lineWidth=3;ctx.strokeRect(4,4,120,120);
  ctx.beginPath();ctx.moveTo(64,4);ctx.lineTo(64,124);ctx.moveTo(4,64);ctx.lineTo(124,64);ctx.stroke();
  addNoise(ctx,w,h,1000,0.2);
});

const texCar = makeTex(128,128,(ctx,w,h)=>{
  ctx.fillStyle='#335';ctx.fillRect(0,0,w,h);
  ctx.fillStyle='#224';ctx.fillRect(10,10,108,108);
  ctx.strokeStyle='#0af';ctx.lineWidth=2;ctx.strokeRect(10,10,108,108);
  ctx.fillStyle='#0af';ctx.font='bold 20px sans-serif';ctx.textAlign='center';ctx.fillText('EXIT',64,70);
  addNoise(ctx,w,h,500,0.15);
});

// Enemy texture
const texEnemy = makeTex(64,128,(ctx,w,h)=>{
  ctx.clearRect(0,0,w,h);
  // Boots
  ctx.fillStyle='#222';ctx.fillRect(16,108,12,20);ctx.fillRect(36,108,12,20);
  // Legs
  ctx.fillStyle='#343';ctx.fillRect(18,72,10,38);ctx.fillRect(36,72,10,38);
  // Body
  ctx.fillStyle='#465';ctx.fillRect(14,36,36,38);
  // Vest
  ctx.fillStyle='#555';ctx.fillRect(16,40,32,24);
  // Arms
  ctx.fillStyle='#465';ctx.fillRect(6,40,10,24);ctx.fillRect(48,40,10,24);
  // Head
  ctx.fillStyle='#454';ctx.beginPath();ctx.arc(32,22,14,0,Math.PI*2);ctx.fill();
  // Balaclava
  ctx.fillStyle='#222';ctx.beginPath();ctx.arc(32,24,10,0,Math.PI*2);ctx.fill();
  // Eyes
  ctx.fillStyle='#fff';ctx.fillRect(27,21,4,3);ctx.fillRect(33,21,4,3);
  // Red shirt visible
  ctx.fillStyle='#a33';ctx.fillRect(22,60,20,14);
  // Weapon
  ctx.fillStyle='#333';ctx.fillRect(48,48,14,3);ctx.fillRect(48,45,3,8);
});

const texEnemyDead = makeTex(128,32,(ctx,w,h)=>{
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle='#343';ctx.fillRect(10,8,108,16);
  ctx.fillStyle='#222';ctx.beginPath();ctx.arc(14,16,8,0,Math.PI*2);ctx.fill();
  ctx.fillStyle='#a33';ctx.fillRect(40,10,30,12);
});

/* ============================================================
   LEVEL GEOMETRY
   ============================================================ */
const levelVerts = {wall:[],floor:[],ceil:[],crate:[],car:[]};

function pushQuad(arr, x0,y0,z0, x1,y1,z1, x2,y2,z2, x3,y3,z3, nx,ny,nz, us,vs){
  // tri 1: 0-1-2, tri 2: 0-2-3
  const d=[[x0,y0,z0,0,0],[x1,y1,z1,0,vs],[x2,y2,z2,us,vs],[x0,y0,z0,0,0],[x2,y2,z2,us,vs],[x3,y3,z3,us,0]];
  for(const v of d) arr.push(v[0],v[1],v[2],v[3],v[4],nx,ny,nz);
}

function buildLevel(){
  for(let z=0;z<MAP_H;z++) for(let x=0;x<MAP_W;x++){
    const c=MAP[z][x];
    const wx=x*CELL, wz=z*CELL;
    if(c===1||c===2){
      const h=c===2?CRATE_H:WALL_H;
      const arr=c===2?levelVerts.crate:levelVerts.wall;
      // +X face
      if(x===MAP_W-1||MAP[z][x+1]===0||MAP[z][x+1]>=3){
        pushQuad(arr,wx+CELL,0,wz+CELL, wx+CELL,h,wz+CELL, wx+CELL,h,wz, wx+CELL,0,wz, 1,0,0,1,1);
      }
      // -X face
      if(x===0||MAP[z][x-1]===0||MAP[z][x-1]>=3){
        pushQuad(arr,wx,0,wz, wx,h,wz, wx,h,wz+CELL, wx,0,wz+CELL, -1,0,0,1,1);
      }
      // +Z face
      if(z===MAP_H-1||MAP[z+1][x]===0||MAP[z+1][x]>=3){
        pushQuad(arr,wx,0,wz+CELL, wx,h,wz+CELL, wx+CELL,h,wz+CELL, wx+CELL,0,wz+CELL, 0,0,1,1,1);
      }
      // -Z face
      if(z===0||MAP[z-1][x]===0||MAP[z-1][x]>=3){
        pushQuad(arr,wx+CELL,0,wz, wx+CELL,h,wz, wx,h,wz, wx,0,wz, 0,0,-1,1,1);
      }
      // Top face
      pushQuad(arr,wx,h,wz, wx,h,wz+CELL, wx+CELL,h,wz+CELL, wx+CELL,h,wz, 0,1,0,1,1);
    } else if(c===5){
      // Car marker - draw as special floor
      pushQuad(levelVerts.car,wx,0.01,wz, wx,0.01,wz+CELL, wx+CELL,0.01,wz+CELL, wx+CELL,0.01,wz, 0,1,0,1,1);
    }
    // Floor for non-wall cells
    if(c!==1){
      pushQuad(levelVerts.floor,wx,0,wz, wx,0,wz+CELL, wx+CELL,0,wz+CELL, wx+CELL,0,wz, 0,1,0,1,1);
      pushQuad(levelVerts.ceil,wx,WALL_H,wz+CELL, wx,WALL_H,wz, wx+CELL,WALL_H,wz, wx+CELL,WALL_H,wz+CELL, 0,-1,0,1,1);
    }
  }
}
buildLevel();

// Upload buffers
function makeVBO(data){
  const buf=gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER,buf);
  gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(data),gl.STATIC_DRAW);
  return {buf, count:data.length/8};
}

let vboWall=makeVBO(levelVerts.wall);
let vboFloor=makeVBO(levelVerts.floor);
let vboCeil=makeVBO(levelVerts.ceil);
let vboCrate=makeVBO(levelVerts.crate);
let vboCar=makeVBO(levelVerts.car);

function rebuildLevel(){
  levelVerts.wall.length=0;levelVerts.floor.length=0;levelVerts.ceil.length=0;levelVerts.crate.length=0;levelVerts.car.length=0;
  buildLevel();
  vboWall=makeVBO(levelVerts.wall);vboFloor=makeVBO(levelVerts.floor);vboCeil=makeVBO(levelVerts.ceil);vboCrate=makeVBO(levelVerts.crate);vboCar=makeVBO(levelVerts.car);
}

// Billboard quad buffer (unit quad)
const billQuad=gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER,billQuad);
gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([
  -0.5,0, 0,1, -0.5,1, 0,0, 0.5,1, 1,0, -0.5,0, 0,1, 0.5,1, 1,0, 0.5,0, 1,1
]),gl.STATIC_DRAW);

// Unit cube VBO (centered, -0.5 to 0.5) with normals
const cubeVBO=(()=>{
  const v=[];
  const F=[
    [[-.5,-.5,.5],[.5,-.5,.5],[.5,.5,.5],[-.5,.5,.5],[0,0,1]],
    [[.5,-.5,-.5],[-.5,-.5,-.5],[-.5,.5,-.5],[.5,.5,-.5],[0,0,-1]],
    [[.5,-.5,.5],[.5,-.5,-.5],[.5,.5,-.5],[.5,.5,.5],[1,0,0]],
    [[-.5,-.5,-.5],[-.5,-.5,.5],[-.5,.5,.5],[-.5,.5,-.5],[-1,0,0]],
    [[-.5,.5,.5],[.5,.5,.5],[.5,.5,-.5],[-.5,.5,-.5],[0,1,0]],
    [[-.5,-.5,-.5],[.5,-.5,-.5],[.5,-.5,.5],[-.5,-.5,.5],[0,-1,0]]
  ];
  for(const[a,b,c,d,n]of F){
    v.push(...a,...n,...b,...n,...c,...n,...a,...n,...c,...n,...d,...n);
  }
  const buf=gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER,buf);
  gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(v),gl.STATIC_DRAW);
  return{buf,count:36};
})();

// Particle buffer (dynamic)
const MAX_PARTS = 500;
const partData = new Float32Array(MAX_PARTS * 8); // x,y,z,r,g,b,a,size
const partBuf = gl.createBuffer();

/* ============================================================
   COLLISION
   ============================================================ */
function isWall(cx,cz){
  if(cx<0||cz<0||cx>=MAP_W||cz>=MAP_H) return true;
  const v=MAP[cz][cx];
  return v===1||v===2;
}

function collide(px,pz,r){
  const cx0=Math.floor(px/CELL), cz0=Math.floor(pz/CELL);
  let nx=px, nz=pz;
  for(let dz=-1;dz<=1;dz++) for(let dx=-1;dx<=1;dx++){
    const cx=cx0+dx, cz=cz0+dz;
    if(!isWall(cx,cz)) continue;
    const minX=cx*CELL, minZ=cz*CELL, maxX=(cx+1)*CELL, maxZ=(cz+1)*CELL;
    const clX=Math.max(minX,Math.min(nx,maxX));
    const clZ=Math.max(minZ,Math.min(nz,maxZ));
    const ddx=nx-clX, ddz=nz-clZ;
    const d=Math.sqrt(ddx*ddx+ddz*ddz);
    if(d<r && d>0.001){
      const push=r-d;
      nx+=ddx/d*push;
      nz+=ddz/d*push;
    } else if(d<0.001){
      nx=px; nz=pz;
    }
  }
  return {x:nx,z:nz};
}

function lineOfSight(x1,z1,x2,z2){
  const dx=x2-x1, dz=z2-z1;
  const dist=Math.sqrt(dx*dx+dz*dz);
  const steps=Math.ceil(dist/1.5);
  for(let i=1;i<steps;i++){
    const t=i/steps;
    const cx=Math.floor((x1+dx*t)/CELL);
    const cz=Math.floor((z1+dz*t)/CELL);
    if(isWall(cx,cz)) return false;
  }
  return true;
}
// Camera ray collision: raycast from player to desired cam pos, stop before wall
function cameraRayCollide(fx,fy,fz,tx,ty,tz){
  const dx=tx-fx,dy=ty-fy,dz=tz-fz;
  const dist=Math.sqrt(dx*dx+dy*dy+dz*dz);
  if(dist<0.1) return {x:tx,y:ty,z:tz};
  const steps=Math.ceil(dist/0.25);
  let lx=fx,ly=fy,lz=fz;
  for(let i=1;i<=steps;i++){
    const t=i/steps;
    const x=fx+dx*t, y=fy+dy*t, z=fz+dz*t;
    const gx=Math.floor(x/CELL),gz=Math.floor(z/CELL);
    if(isWall(gx,gz)||y<0.3||y>WALL_H-0.3) return {x:lx,y:ly,z:lz};
    lx=x;ly=y;lz=z;
  }
  return {x:tx,y:ty,z:tz};
}

/* ============================================================
   RAGDOLL PHYSICS (Verlet Integration)
   ============================================================ */
const RAGDOLL_OFFSETS = [
  [0, 1.76, 0],      // 0: HEAD
  [0, 1.52, 0],      // 1: NECK
  [0, 1.30, 0],      // 2: CHEST
  [0, 0.92, 0],      // 3: SPINE (hips)
  [-0.30, 1.30, 0],  // 4: SHOULDER_L
  [0.30, 1.30, 0],   // 5: SHOULDER_R
  [-0.30, 0.96, 0],  // 6: ELBOW_L
  [0.30, 0.96, 0],   // 7: ELBOW_R
  [-0.30, 0.62, 0],  // 8: HAND_L
  [0.30, 0.62, 0],   // 9: HAND_R
  [-0.12, 0.50, 0],  // 10: KNEE_L
  [0.12, 0.50, 0],   // 11: KNEE_R
  [-0.12, 0.05, 0],  // 12: FOOT_L
  [0.12, 0.05, 0],   // 13: FOOT_R
];
const RH=0,RN=1,RC=2,RS=3,RSL=4,RSR=5,REL=6,RER=7,RHL=8,RHR=9,RKL=10,RKR=11,RFL=12,RFR=13;
const RAGDOLL_CONSTRAINTS = [
  [RH,RN],[RN,RC],[RC,RS],[RC,RSL],[RC,RSR],
  [RSL,REL],[RSR,RER],[REL,RHL],[RER,RHR],
  [RS,RKL],[RS,RKR],[RKL,RFL],[RKR,RFR],
  [RSL,RSR],[RKL,RKR],[RH,RC],[RSL,RS],[RSR,RS],[RC,RKL],[RC,RKR],[RS,RN],
];
const RAGDOLL_REST_LENGTHS = RAGDOLL_CONSTRAINTS.map(([a,b])=>{
  const dx=RAGDOLL_OFFSETS[a][0]-RAGDOLL_OFFSETS[b][0];
  const dy=RAGDOLL_OFFSETS[a][1]-RAGDOLL_OFFSETS[b][1];
  const dz=RAGDOLL_OFFSETS[a][2]-RAGDOLL_OFFSETS[b][2];
  return Math.sqrt(dx*dx+dy*dy+dz*dz);
});
const RAG_GRAVITY = 9.8;

function createRagdoll(entity, bdx, bdy, bdz, hitIdx){
  const ca=Math.cos(-entity.angle), sa=Math.sin(-entity.angle);
  const particles = RAGDOLL_OFFSETS.map(([ox,oy,oz])=>{
    const rx = ox*ca - oz*sa + entity.x;
    const ry = oy;
    const rz = ox*sa + oz*ca + entity.z;
    return {x:rx,y:ry,z:rz, ox:rx+(Math.random()-0.5)*0.05, oy:ry+(Math.random()-0.5)*0.02, oz:rz+(Math.random()-0.5)*0.05};
  });
  const impulse = hitIdx===RH ? 1.8 : 1.2;
  const hp = particles[hitIdx];
  hp.ox -= bdx*impulse;
  hp.oy -= bdy*impulse;
  hp.oz -= bdz*impulse;
  const constraints = RAGDOLL_CONSTRAINTS.map(([a,b],i)=>({a,b,rest:RAGDOLL_REST_LENGTHS[i]}));
  return {
    particles, constraints,
    sleeping:false, sleepFrames:0,
    rifleX: entity.x+Math.sin(entity.angle+0.5)*0.7,
    rifleZ: entity.z+Math.cos(entity.angle+0.5)*0.7,
    rifleAngle: entity.angle,
    headGone: false, armLGone: false, armRGone: false, legLGone: false, legRGone: false
  };
}

function updateRagdoll(rag, dt){
  if(rag.sleeping) return;
  const dtSq = dt*dt;
  const ps = rag.particles;
  // Verlet integration
  for(let i=0;i<ps.length;i++){
    const p=ps[i];
    let vx=p.x-p.ox, vy=p.y-p.oy, vz=p.z-p.oz;
    p.ox=p.x; p.oy=p.y; p.oz=p.z;
    p.x+=vx*0.95; p.y+=vy*0.95; p.z+=vz*0.95;
    p.y-=RAG_GRAVITY*dtSq;
  }
  // Interleaved constraint solve + collision (8 iterations)
  for(let iter=0;iter<8;iter++){
    for(let i=0;i<rag.constraints.length;i++){
      const c=rag.constraints[i];
      const pa=ps[c.a], pb=ps[c.b];
      const cdx=pb.x-pa.x, cdy=pb.y-pa.y, cdz=pb.z-pa.z;
      const dist=Math.sqrt(cdx*cdx+cdy*cdy+cdz*cdz);
      if(dist<0.001) continue;
      const diff=(dist-c.rest)/dist*0.5;
      pa.x+=cdx*diff; pa.y+=cdy*diff; pa.z+=cdz*diff;
      pb.x-=cdx*diff; pb.y-=cdy*diff; pb.z-=cdz*diff;
    }
    for(let i=0;i<ps.length;i++){
      const p=ps[i];
      if(p.y<0.05) p.y=0.05;
      const cc=collide(p.x,p.z,0.1);
      p.x=cc.x; p.z=cc.z;
    }
  }
  // Sleep detection
  let totalMove=0;
  for(let i=0;i<ps.length;i++){
    const p=ps[i];
    totalMove+=Math.abs(p.x-p.ox)+Math.abs(p.y-p.oy)+Math.abs(p.z-p.oz);
  }
  if(totalMove<0.005) rag.sleepFrames++; else rag.sleepFrames=0;
  if(rag.sleepFrames>30) rag.sleeping=true;
}

function boneMat(rag, idxA, idxB){
  const a=rag.particles[idxA], b=rag.particles[idxB];
  const dx=b.x-a.x, dy=b.y-a.y, dz=b.z-a.z;
  const len=Math.sqrt(dx*dx+dy*dy+dz*dz)||0.01;
  const mx=(a.x+b.x)/2, my=(a.y+b.y)/2, mz=(a.z+b.z)/2;
  const ux=dx/len, uy=dy/len, uz=dz/len;
  let rx,ry,rz;
  if(Math.abs(uy)>0.99){ rx=1;ry=0;rz=0; } else {
    const il=1/Math.sqrt(ux*ux+uz*uz);
    rx=-uz*il; ry=0; rz=ux*il;
  }
  const fx=uy*rz-uz*ry, fy=uz*rx-ux*rz, fz=ux*ry-uy*rx;
  // Y-axis scaled by bone length (cube is -0.5..0.5, so vertex*len reaches ±len/2 from midpoint = particles A,B)
  // Column-major: col0=right, col1=bone dir*len, col2=forward, col3=midpoint
  return new Float32Array([rx,ry,rz,0, ux*len,uy*len,uz*len,0, fx,fy,fz,0, mx,my,mz,1]);
}

function particleMat(rag, idx){
  const p=rag.particles[idx];
  return mat4T(p.x,p.y,p.z);
}

/* ============================================================
   SOUND (Web Audio)
   ============================================================ */
let audioCtx = null;
function initAudio(){ if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }

function playSound(type){
  if(!audioCtx) return;
  const ctx=audioCtx;
  const t=ctx.currentTime;
  if(type==='shoot'){
    const dur=0.15;
    const buf=ctx.createBuffer(1,ctx.sampleRate*dur|0,ctx.sampleRate);
    const d=buf.getChannelData(0);
    for(let i=0;i<d.length;i++){
      const p=i/d.length;
      d[i]=(Math.random()*2-1)*Math.exp(-p*8)*0.6;
    }
    const src=ctx.createBufferSource();src.buffer=buf;
    const filt=ctx.createBiquadFilter();filt.type='lowpass';filt.frequency.value=3000;filt.frequency.exponentialRampToValueAtTime(300,t+dur);
    const g=ctx.createGain();g.gain.value=0.4;
    src.connect(filt);filt.connect(g);g.connect(ctx.destination);
    src.start(t);
  } else if(type==='hit'){
    const dur=0.08;
    const buf=ctx.createBuffer(1,ctx.sampleRate*dur|0,ctx.sampleRate);
    const d=buf.getChannelData(0);
    for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*Math.exp(-i/d.length*6)*0.3;
    const src=ctx.createBufferSource();src.buffer=buf;
    const g=ctx.createGain();g.gain.value=0.3;src.connect(g);g.connect(ctx.destination);src.start(t);
  } else if(type==='reload'){
    const osc=ctx.createOscillator();osc.type='square';osc.frequency.value=800;
    const g=ctx.createGain();g.gain.value=0.1;g.gain.exponentialRampToValueAtTime(0.001,t+0.1);
    osc.connect(g);g.connect(ctx.destination);osc.start(t);osc.stop(t+0.1);
  } else if(type==='enemyShoot'){
    const dur=0.12;
    const buf=ctx.createBuffer(1,ctx.sampleRate*dur|0,ctx.sampleRate);
    const d=buf.getChannelData(0);
    for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*Math.exp(-i/d.length*10)*0.25;
    const src=ctx.createBufferSource();src.buffer=buf;
    const filt=ctx.createBiquadFilter();filt.type='lowpass';filt.frequency.value=2000;
    const g=ctx.createGain();g.gain.value=0.2;
    src.connect(filt);filt.connect(g);g.connect(ctx.destination);src.start(t);
  } else if(type==='death'){
    const osc=ctx.createOscillator();osc.type='sawtooth';osc.frequency.value=200;osc.frequency.exponentialRampToValueAtTime(50,t+1.5);
    const g=ctx.createGain();g.gain.value=0.15;g.gain.exponentialRampToValueAtTime(0.001,t+1.5);
    osc.connect(g);g.connect(ctx.destination);osc.start(t);osc.stop(t+1.5);
  } else if(type==='win'){
    [523,659,784].forEach((f,i)=>{
      const osc=ctx.createOscillator();osc.type='sine';osc.frequency.value=f;
      const g=ctx.createGain();g.gain.value=0.15;g.gain.exponentialRampToValueAtTime(0.001,t+0.3+i*0.15);
      osc.connect(g);g.connect(ctx.destination);osc.start(t+i*0.15);osc.stop(t+0.4+i*0.15);
    });
  } else if(type==='step'){
    const dur=0.06;
    const buf=ctx.createBuffer(1,ctx.sampleRate*dur|0,ctx.sampleRate);
    const d=buf.getChannelData(0);
    for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*Math.exp(-i/d.length*12)*0.08;
    const src=ctx.createBufferSource();src.buffer=buf;
    const filt=ctx.createBiquadFilter();filt.type='lowpass';filt.frequency.value=400;
    const g=ctx.createGain();g.gain.value=0.15;
    src.connect(filt);filt.connect(g);g.connect(ctx.destination);src.start(t);
  } else if(type==='dismember'){
    const dur=0.25;
    const buf=ctx.createBuffer(1,ctx.sampleRate*dur|0,ctx.sampleRate);
    const d=buf.getChannelData(0);
    for(let i=0;i<d.length;i++){
      const p=i/d.length;
      d[i]=(Math.random()*2-1)*Math.exp(-p*4)*0.5 + Math.sin(p*120)*Math.exp(-p*6)*0.3;
    }
    const src=ctx.createBufferSource();src.buffer=buf;
    const filt=ctx.createBiquadFilter();filt.type='lowpass';filt.frequency.value=600;
    const g=ctx.createGain();g.gain.value=0.5;
    src.connect(filt);filt.connect(g);g.connect(ctx.destination);src.start(t);
  } else if(type==='explode'){
    const dur=0.5;
    const buf=ctx.createBuffer(1,ctx.sampleRate*dur|0,ctx.sampleRate);
    const d=buf.getChannelData(0);
    for(let i=0;i<d.length;i++){
      const p=i/d.length;
      d[i]=(Math.random()*2-1)*Math.exp(-p*4)*0.7+Math.sin(p*80)*Math.exp(-p*6)*0.4;
    }
    const src=ctx.createBufferSource();src.buffer=buf;
    const filt=ctx.createBiquadFilter();filt.type='lowpass';filt.frequency.value=800;
    const g=ctx.createGain();g.gain.value=0.6;
    src.connect(filt);filt.connect(g);g.connect(ctx.destination);src.start(t);
  } else if(type==='pickup'){
    const osc=ctx.createOscillator();osc.type='sine';osc.frequency.value=880;osc.frequency.exponentialRampToValueAtTime(1200,t+0.15);
    const g=ctx.createGain();g.gain.value=0.12;g.gain.exponentialRampToValueAtTime(0.001,t+0.2);
    osc.connect(g);g.connect(ctx.destination);osc.start(t);osc.stop(t+0.2);
  }
}

/* Voice lines (Speech Synthesis API) - global cooldown prevents spam */
let globalVoiceCd=0, lastVoiceLine='';
function playVoice(text){
  try{
    if(!window.speechSynthesis||globalVoiceCd>0||text===lastVoiceLine) return;
    if(speechSynthesis.speaking) return;
    const u=new SpeechSynthesisUtterance(text);
    u.lang='en-US';u.rate=1.0;u.pitch=0.7;u.volume=0.7;
    speechSynthesis.speak(u);
    globalVoiceCd=6; lastVoiceLine=text;
    setTimeout(()=>{lastVoiceLine='';},10000);
  }catch(e){console.warn('Voice failed:',e);}
}

/* ============================================================
   PARTICLES
   ============================================================ */
const particles = [];

function spawnParticles(x,y,z,type){
  const count = type==='muzzle'?10 : type==='blood'?25 : type==='gore'?40 : type==='dismember'?30 : type==='impact'?8 : 4;
  for(let i=0;i<count;i++){
    const p = {x,y,z,vx:0,vy:0,vz:0,life:1,maxLife:1,r:1,g:1,b:1,a:1,size:1,grav:0};
    if(type==='muzzle'){
      p.vx=(Math.random()-0.5)*5;p.vy=(Math.random()-0.5)*5;p.vz=(Math.random()-0.5)*5;
      p.life=p.maxLife=0.08+Math.random()*0.12;p.r=1;p.g=0.8;p.b=0.2;p.size=0.35;
    } else if(type==='blood'){
      p.vx=(Math.random()-0.5)*8;p.vy=Math.random()*5+1;p.vz=(Math.random()-0.5)*8;
      p.life=p.maxLife=0.6+Math.random()*0.8;p.r=0.6+Math.random()*0.3;p.g=0;p.b=0;p.size=0.12+Math.random()*0.15;p.grav=10;p.isBlood=true;
    } else if(type==='gore'){
      p.vx=(Math.random()-0.5)*14;p.vy=Math.random()*8+3;p.vz=(Math.random()-0.5)*14;
      p.life=p.maxLife=0.8+Math.random()*1.0;p.r=0.5+Math.random()*0.4;p.g=0;p.b=0;p.size=0.18+Math.random()*0.25;p.grav=12;p.isBlood=true;
    } else if(type==='dismember'){
      p.vx=(Math.random()-0.5)*12;p.vy=Math.random()*6+2;p.vz=(Math.random()-0.5)*12;
      p.life=p.maxLife=0.7+Math.random()*0.9;p.r=0.55+Math.random()*0.35;p.g=0;p.b=0;p.size=0.10+Math.random()*0.20;p.grav=11;p.isBlood=true;
    } else if(type==='impact'){
      p.vx=(Math.random()-0.5)*7;p.vy=Math.random()*5;p.vz=(Math.random()-0.5)*7;
      p.life=p.maxLife=0.3+Math.random()*0.3;p.r=1;p.g=0.6;p.b=0.2;p.size=0.12;p.grav=6;
    }
    particles.push(p);
  }
}

// Directional blood: cone-shaped exit wound spray with varied shades
function spawnDirectionalBlood(x,y,z,bdx,bdy,bdz,count){
  for(let i=0;i<count;i++){
    // Tight core for first 40%, wider splatter for rest
    const cone=i<count*0.4?0.25:0.55;
    const rx=(Math.random()-0.5)*cone, ry=(Math.random()-0.5)*cone, rz=(Math.random()-0.5)*cone;
    const speed=4+Math.random()*10;
    const p={x:x+(Math.random()-0.5)*0.1, y:y+(Math.random()-0.5)*0.1, z:z+(Math.random()-0.5)*0.1,
      vx:(bdx+rx)*speed, vy:(bdy+ry)*speed+Math.random()*2, vz:(bdz+rz)*speed,
      life:0,maxLife:0,r:0,g:0,b:0,a:1,size:0,grav:14,isBlood:true};
    p.life=p.maxLife=0.6+Math.random()*1.0;
    // Varied red: bright → dark coagulated
    const shade=Math.random();
    if(shade<0.3){p.r=0.9+Math.random()*0.1;p.g=0.02;p.b=0;}
    else if(shade<0.6){p.r=0.55+Math.random()*0.25;p.g=0;p.b=0;}
    else if(shade<0.85){p.r=0.35+Math.random()*0.15;p.g=0.02;p.b=0.02;}
    else{p.r=0.29;p.g=0;p.b=0;}
    p.size=0.06+Math.random()*0.24;
    particles.push(p);
  }
}

// Spawn wall blood decal: raycast in bullet dir from hit point, find wall within 2m
function trySpawnWallDecal(hx,hy,hz,bdx,bdy,bdz){
  for(let t=0.3;t<2.0;t+=0.3){
    const wx=hx+bdx*t, wz=hz+bdz*t;
    const cx=Math.floor(wx/CELL), cz=Math.floor(wz/CELL);
    if(isWall(cx,cz)){
      // Determine which face was hit (snap to cell edge)
      const cellCx=(cx+0.5)*CELL, cellCz=(cz+0.5)*CELL;
      let nx=0,nz=0;
      if(Math.abs(bdx)>Math.abs(bdz)){nx=bdx>0?-1:1;}else{nz=bdz>0?-1:1;}
      const sx=nx!==0?(nx>0?cx*CELL:(cx+1)*CELL):wx;
      const sz=nz!==0?(nz>0?cz*CELL:(cz+1)*CELL):wz;
      const sy=Math.max(0.1,Math.min(WALL_H-0.1,hy+bdy*t));
      bloodDecals.push({x:sx+nx*0.01,y:sy,z:sz+nz*0.01,nx,nz,ny:0,size:0.15+Math.random()*0.35,life:30,rot:Math.random()*Math.PI*2});
      return;
    }
  }
}

// Spawn severed limb as multiple tumbling physics chunks
function spawnGiblet(x,y,z,bdx,bdy,bdz,r,g,b,len){
  const chunks=2+Math.floor(Math.random()*3); // 2-4 chunks per dismemberment
  for(let c=0;c<chunks;c++){
    const speed=14+Math.random()*14;
    const spread=3+Math.random()*5;
    const vx=bdx*speed+(Math.random()-0.5)*spread;
    const vy=bdy*speed+4+Math.random()*8;
    const vz=bdz*speed+(Math.random()-0.5)*spread;
    const hl=(len||0.2)*(0.5+Math.random()*0.5);
    const sx=0.04+Math.random()*0.08;
    const ox=x+(Math.random()-0.5)*0.15, oy=y+(Math.random()-0.5)*0.1, oz=z+(Math.random()-0.5)*0.15;
    const p1={x:ox,y:oy,z:oz, ox:ox-vx*0.016,oy:oy-vy*0.016,oz:oz-vz*0.016};
    // Tumble spin — fast rotation
    const spinVx=(Math.random()-0.5)*18, spinVy=(Math.random()-0.5)*14, spinVz=(Math.random()-0.5)*18;
    const p2={x:ox+hl*(Math.random()-0.5),y:oy+hl,z:oz+hl*(Math.random()-0.5),
      ox:ox-vx*0.016+hl*(Math.random()-0.5)-spinVx*0.016,
      oy:oy+hl-vy*0.016-spinVy*0.016,
      oz:oz-vz*0.016+hl*(Math.random()-0.5)-spinVz*0.016};
    // Vary chunk color slightly (meat/bone/cloth)
    const cr=r*(0.7+Math.random()*0.3)+(c===0?0:Math.random()*0.15);
    const cg=g*(0.7+Math.random()*0.3);
    const cb=b*(0.7+Math.random()*0.3);
    giblets.push({particles:[p1,p2],rest:hl,r:Math.min(1,cr),g:Math.min(1,cg),b:Math.min(1,cb),
      life:10+Math.random()*8,sx:sx,trailTimer:0});
  }
  // Also spawn blood mist at origin
  spawnDirectionalBlood(x,y,z,bdx,bdy,bdz,15);
}

function updateGiblets(dt){
  const dtSq=dt*dt;
  while(giblets.length>gfxGibletCap) giblets.shift(); // cap giblets
  for(let i=giblets.length-1;i>=0;i--){
    const g=giblets[i];
    g.life-=dt;
    if(g.life<=0){giblets.splice(i,1);continue;}
    for(const p of g.particles){
      let vx=p.x-p.ox,vy=p.y-p.oy,vz=p.z-p.oz;
      p.ox=p.x;p.oy=p.y;p.oz=p.z;
      p.x+=vx*0.99;p.y+=vy*0.99;p.z+=vz*0.99;
      p.y-=9.8*dtSq;
      // Floor bounce
      if(p.y<0.03){
        p.y=0.03;
        const bvy=p.y-p.oy;
        if(bvy<-0.01) p.oy=p.y+bvy*0.35; // bounce with 35% restitution
        else p.oy=p.y;
        // Spawn floor decal on impact
        if(Math.abs(bvy)>0.02){
          bloodDecals.push({x:p.x,y:0.005,z:p.z,nx:0,nz:0,ny:1,
            size:0.08+Math.random()*0.15,life:25+Math.random()*10,rot:Math.random()*Math.PI*2});
        }
      }
      const cc=collide(p.x,p.z,0.05);p.x=cc.x;p.z=cc.z;
    }
    // Constraint
    const pa=g.particles[0],pb=g.particles[1];
    const cdx=pb.x-pa.x,cdy=pb.y-pa.y,cdz=pb.z-pa.z;
    const dist=Math.sqrt(cdx*cdx+cdy*cdy+cdz*cdz)||0.01;
    const diff=(dist-g.rest)/dist*0.5;
    pa.x+=cdx*diff;pa.y+=cdy*diff;pa.z+=cdz*diff;
    pb.x-=cdx*diff;pb.y-=cdy*diff;pb.z-=cdz*diff;
    // Trailing blood drips while airborne
    g.trailTimer-=dt;
    if(g.trailTimer<=0 && g.life>3){
      g.trailTimer=0.15;
      const mx=(pa.x+pb.x)/2, my=(pa.y+pb.y)/2, mz=(pa.z+pb.z)/2;
      if(my>0.15){
        particles.push({x:mx,y:my,z:mz,vx:(Math.random()-0.5)*0.5,vy:-1,vz:(Math.random()-0.5)*0.5,
          life:0.5+Math.random()*0.3,maxLife:0.8,r:0.4+Math.random()*0.2,g:0,b:0,a:1,
          size:0.04+Math.random()*0.06,grav:12,isBlood:true});
      }
    }
  }
}

function updateGrenades(dt){
  for(let i=grenades.length-1;i>=0;i--){
    const g=grenades[i];
    g.x+=g.vx*dt; g.y+=g.vy*dt; g.z+=g.vz*dt;
    g.vy-=GRAVITY*dt;
    // Floor bounce
    if(g.y<0.15){g.y=0.15;g.vy=Math.abs(g.vy)*0.3;g.vx*=0.7;g.vz*=0.7;}
    // Wall collision
    const gc=collide(g.x,g.z,0.15);g.x=gc.x;g.z=gc.z;
    g.timer-=dt;
    if(g.timer<=0){
      // EXPLODE
      playSound('explode');
      screenShake=1.0;
      spawnParticles(g.x,g.y+0.3,g.z,'muzzle');
      spawnParticles(g.x,g.y+0.5,g.z,'muzzle');
      // Damage enemies in radius
      const radius=6;
      for(const e of enemies){
        if(e.hp<=0) continue;
        const ddx=e.x-g.x,ddz=e.z-g.z;
        const dd=Math.sqrt(ddx*ddx+ddz*ddz);
        if(dd<radius){
          const dmg=Math.floor(150*(1-dd/radius));
          e.hp-=dmg;
          if(e.state!=='hurt') e._prevState=e.state;
          e.state='hurt';e.hurtTimer=0.5;e.flash=1;
          if(goreEnabled) spawnDirectionalBlood(e.x,1.0,e.z,ddx/(dd||1),0.5,ddz/(dd||1),8);
        }
      }
      // Damage player if close
      const pd=Math.sqrt((player.x-g.x)**2+(player.z-g.z)**2);
      if(pd<radius) player.hp-=Math.floor(80*(1-pd/radius));
      grenades.splice(i,1);
      continue;
    }
    // Smoke trail
    if(Math.random()<0.3) particles.push({x:g.x,y:g.y,z:g.z,vx:(Math.random()-0.5)*0.5,vy:1,vz:(Math.random()-0.5)*0.5,life:0.4,maxLife:0.4,r:0.5,g:0.5,b:0.5,a:0.6,size:0.08,grav:0});
  }
}

function updateParticles(dt){
  while(particles.length>gfxMaxParticles) particles.shift();
  for(let i=particles.length-1;i>=0;i--){
    const p=particles[i];
    p.life-=dt;
    if(p.life<=0){particles.splice(i,1);continue;}
    p.vy-=p.grav*dt;
    p.x+=p.vx*dt;p.y+=p.vy*dt;p.z+=p.vz*dt;
    // Blood particle → floor decal conversion
    if(p.isBlood && p.y<=0.01){
      p.y=0;
      bloodDecals.push({x:p.x,y:0.005,z:p.z,nx:0,nz:0,ny:1,
        size:0.05+Math.random()*0.18,life:20+Math.random()*15,rot:Math.random()*Math.PI*2});
      particles.splice(i,1);continue;
    }
    // Blood particle → wall decal conversion
    if(p.isBlood && p.y>0.05){
      const gx=Math.floor(p.x/CELL),gz=Math.floor(p.z/CELL);
      if(isWall(gx,gz)){
        const cx2=(gx+0.5)*CELL,cz2=(gz+0.5)*CELL;
        let wnx=0,wnz=0;
        const lx=p.x-cx2,lz=p.z-cz2;
        if(Math.abs(lx)>Math.abs(lz)){wnx=lx>0?1:-1;}else{wnz=lz>0?1:-1;}
        const sx2=wnx!==0?(wnx>0?(gx+1)*CELL:gx*CELL):p.x;
        const sz2=wnz!==0?(wnz>0?(gz+1)*CELL:gz*CELL):p.z;
        bloodDecals.push({x:sx2+wnx*0.01,y:p.y,z:sz2+wnz*0.01,nx:wnx,nz:wnz,ny:0,
          size:0.06+Math.random()*0.2,life:20+Math.random()*15,rot:Math.random()*Math.PI*2});
        particles.splice(i,1);continue;
      }
    }
    if(p.y<0)p.y=0;
    p.a=p.life/p.maxLife;
  }
  // Decay screen shake
  screenShake*=Math.max(0,1-dt*5);
  if(screenShake<0.001) screenShake=0;
  // Decay blood decals + cap
  while(bloodDecals.length>gfxDecalCap) bloodDecals.shift();
  for(let i=bloodDecals.length-1;i>=0;i--){
    bloodDecals[i].life-=dt;
    if(bloodDecals[i].life<=0) bloodDecals.splice(i,1);
  }
}

/* ============================================================
   GAME STATE
   ============================================================ */
let state = 'menu'; // menu, playing, dead, win
const keys = {};
let mouseDown = false;
let mouseRightDown = false;
let player, enemies, moneyBags, evacTimer, evacActive, allEnemiesDead, allMoneyCollected;
let ammo, reserveAmmo, reloading, reloadTimer, shootCd, recoil, stepTimer;
let hitMarkerTimer, headshotTimer=0;
let bleeding, bleedTimer;
let playerCoins=0, playerMedkits=0, weaponBonus=0, armorBonus=0, lootCount=0;
let playerBags=0, playerCuffs=0;
let capturedEnemy=null;
// Juggernaut mode
let jugUnlocked=false, gameMode='normal'; // 'normal' | 'juggernaut'
let goreEnabled=false;
let armorBuyCount=0;
let menuCharAngle=0;
let jugKills=0, jugWave=0, jugWaveTimer=0;
let mathDoubleReward=false, mathFreezeTimer=0;
let playerGrenades=0, grenades=[];
let armorPiercing=false, goldSkin=false, enemyCamo=false;
// Weapon switching: 0=rifle, 1=shotgun, 2=pistol, 3=sniper
let currentWeapon=0, hasShotgun=false, hasPistol=false, hasSniper=false, hasShield=false, hasDrone=false, hasGravGun=false;
const WEAPONS=[
  {name:'Автомат',mag:30,reserve:90,reload:1.8,firerate:0.12,dmg:35,spread:0.02,pellets:1,zoom:0.4},
  {name:'Дробовик',mag:6,reserve:30,reload:2.5,firerate:0.8,dmg:15,spread:0.12,pellets:8,zoom:0},
  {name:'Пистолет',mag:12,reserve:999,reload:1.0,firerate:0.18,dmg:20,spread:0.03,pellets:1,zoom:0},
  {name:'Снайперка',mag:5,reserve:25,reload:2.8,firerate:1.2,dmg:200,spread:0,pellets:1,zoom:0.2},
  {name:'Глитч-пушка',mag:20,reserve:100,reload:1.5,firerate:0.2,dmg:45,spread:0.03,pellets:1,zoom:0,glitch:true}
];
let shieldHP=0, shieldActive=false;
// XP / Level system
let playerXP=0, playerLevel=1;
const XP_PER_LEVEL=100;
// Bullet time
let bulletTimeLeft=0, bulletTimeCd=0, hasBulletTime=false;
// Night vision
let nightVision=false, hasNightVision=false;
// Neon mode
let neonMode=false;
// Rain
let rainParticles=[], rainEnabled=false;
// Flashlight
let hasFlashlight=false, flashlightOn=false;
// Cheat code features
let skeletonMode=false, thirdPersonCam=false;
let hasGlitchWeapon=false, bossDefeated=false;
// Graphics settings
let gfxPreset='high'; // 'low','medium','high','ultra'
let gfxResScale=1.0;  // render resolution multiplier
let gfxMaxParticles=300; // particle cap in updateParticles
let gfxFogDist=55;    // fog distance
let gfxShadows=true;  // ambient occlusion on boxes
let gfxDecalCap=150;  // max blood decals
let gfxGibletCap=30;  // max giblets
let gfxParticleSize=1.0; // particle size multiplier
let gfxBrightness=1.0;   // CSS filter brightness
let gfxContrast=1.05;    // CSS filter contrast
let gfxSaturation=1.05;  // CSS filter saturate
let gfxVignette=0.15;    // vignette overlay opacity (0=off, 1=max)
function applyGfxPreset(preset){
  gfxPreset=preset;
  if(preset==='low'){
    gfxResScale=0.5; gfxMaxParticles=50; gfxFogDist=15;
    gfxShadows=false; gfxDecalCap=20; gfxGibletCap=5; gfxParticleSize=0.6;
    gfxBrightness=0.8; gfxContrast=0.85; gfxSaturation=0.6; gfxVignette=0.8;
  } else if(preset==='medium'){
    gfxResScale=0.75; gfxMaxParticles=150; gfxFogDist=35;
    gfxShadows=true; gfxDecalCap=60; gfxGibletCap=15; gfxParticleSize=0.85;
    gfxBrightness=0.95; gfxContrast=1.0; gfxSaturation=0.9; gfxVignette=0.4;
  } else if(preset==='high'){
    gfxResScale=1.0; gfxMaxParticles=300; gfxFogDist=55;
    gfxShadows=true; gfxDecalCap=150; gfxGibletCap=30; gfxParticleSize=1.0;
    gfxBrightness=1.0; gfxContrast=1.05; gfxSaturation=1.05; gfxVignette=0.15;
  } else { // ultra
    gfxResScale=1.0; gfxMaxParticles=500; gfxFogDist=100;
    gfxShadows=true; gfxDecalCap=250; gfxGibletCap=50; gfxParticleSize=1.3;
    gfxBrightness=1.1; gfxContrast=1.2; gfxSaturation=1.3; gfxVignette=0;
  }
  resizeGfx();
  applyGfxVisuals();
  updateGfxUI();
}
function resizeGfx(){
  _gfxRes=gfxResScale;
  resize();
  // Pixelated rendering at low resolution for obvious visual difference
  if(gfxResScale<0.9){
    canvas.style.imageRendering='pixelated';
  } else {
    canvas.style.imageRendering='';
  }
}
function applyGfxVisuals(){
  // CSS filter on WebGL canvas — dramatically changes look
  canvas.style.filter='brightness('+gfxBrightness+') contrast('+gfxContrast+') saturate('+gfxSaturation+')';
  // Vignette overlay
  const vig=document.getElementById('vignetteOverlay');
  if(vig){
    vig.style.opacity=gfxVignette;
    vig.style.background='radial-gradient(ellipse at center, transparent '+(60-gfxVignette*30)+'%, rgba(0,0,0,'+(0.4+gfxVignette*0.5)+') 100%)';
  }
}
function updateGfxUI(){
  const names={low:'НИЗКАЯ',medium:'СРЕДНЯЯ',high:'ВЫСОКАЯ',ultra:'УЛЬТРА',custom:'СВОЯ'};
  const bp=document.getElementById('btnGfxPreset');
  if(bp) bp.textContent='КАЧЕСТВО: '+names[gfxPreset];
  const sr=document.getElementById('gfxResVal');
  if(sr) sr.textContent=Math.round(gfxResScale*100)+'%';
  const sp=document.getElementById('gfxPartVal');
  if(sp) sp.textContent=gfxMaxParticles;
  const sf=document.getElementById('gfxFogVal');
  if(sf) sf.textContent=gfxFogDist;
  const sd=document.getElementById('gfxDecalVal');
  if(sd) sd.textContent=gfxDecalCap;
  const sg=document.getElementById('gfxGibVal');
  if(sg) sg.textContent=gfxGibletCap;
  const ss=document.getElementById('btnGfxShadows');
  if(ss) ss.textContent='ТЕНИ: '+(gfxShadows?'ВКЛ':'ВЫКЛ');
  // Update new visual settings displays
  const sb=document.getElementById('gfxBrightVal');
  if(sb) sb.textContent=Math.round(gfxBrightness*100)+'%';
  const sc=document.getElementById('gfxContrastVal');
  if(sc) sc.textContent=Math.round(gfxContrast*100)+'%';
  const ssa=document.getElementById('gfxSatVal');
  if(ssa) ssa.textContent=Math.round(gfxSaturation*100)+'%';
  const sv=document.getElementById('gfxVigVal');
  if(sv) sv.textContent=Math.round(gfxVignette*100)+'%';
  // Update range inputs
  const ri=document.getElementById('gfxResRange');if(ri)ri.value=gfxResScale*100;
  const pi=document.getElementById('gfxPartRange');if(pi)pi.value=gfxMaxParticles;
  const fi=document.getElementById('gfxFogRange');if(fi)fi.value=gfxFogDist;
  const di=document.getElementById('gfxDecalRange');if(di)di.value=gfxDecalCap;
  const gi=document.getElementById('gfxGibRange');if(gi)gi.value=gfxGibletCap;
  const bi=document.getElementById('gfxBrightRange');if(bi)bi.value=gfxBrightness*100;
  const ci=document.getElementById('gfxContrastRange');if(ci)ci.value=gfxContrast*100;
  const si=document.getElementById('gfxSatRange');if(si)si.value=gfxSaturation*100;
  const vi=document.getElementById('gfxVigRange');if(vi)vi.value=gfxVignette*100;
}
// Exploding barrels
let barrels=[];
// Doors [{x,z,open,openAmt}]
let doors=[];
// Defuse mode
let bombs=[], defuseTimer=0;
// Stealth
let stealthDetected=false;
// Camo palettes: [helmet, torso, pants] each [r,g,b]
const CAMO_PALETTES=[
  {helm:[.30,.33,.20],torso:[.35,.35,.35],pants:[.21,.27,.21]}, // default olive
  {helm:[.35,.25,.15],torso:[.40,.30,.20],pants:[.30,.22,.14]}, // desert tan
  {helm:[.18,.18,.22],torso:[.22,.22,.28],pants:[.15,.15,.20]}, // urban dark
  {helm:[.45,.40,.30],torso:[.50,.45,.35],pants:[.38,.33,.25]}, // sand
  {helm:[.15,.25,.15],torso:[.18,.30,.18],pants:[.12,.22,.12]}, // forest green
  {helm:[.25,.15,.15],torso:[.30,.20,.18],pants:[.22,.14,.12]}, // maroon
];
// Helmet cracks
let helmetCracks=[];
// Screen shake
let screenShake=0;
// Math mode state
let mathA=0, mathB=0, mathAnswer=0, mathTimer=0, mathScore=0;
// Wall blood decals [{x,y,z,nx,nz,size,life}]
let bloodDecals=[];
// Severed limb physics objects [{particles:[{x,y,z,ox,oy,oz}×2], rest, r,g,b, life}]
let giblets=[];
// Blood pools under dead bodies [{x,z,size,maxSize,growRate}]
let bloodPools=[];
// Screen blood droplets [{x,y,dy,size,life,maxLife,r,g,b}]
let screenBloodDrops=[];
// Lean state
let leanAmount=0; // -1 left, 0 center, +1 right (smoothed)
// Ally system
const ALLY_DEFS=[
  {name:'Диана',role:'medic'},{name:'Павел',role:'defender'},
  {name:'Матвей',role:'defender'},{name:'Глеб',role:'defender'},
  {name:'Вика Ф.',role:'medic'},{name:'Есения К.',role:'medic'},
  {name:'Саида',role:'dumb'}
];
let allies=[];
let _lastVP=null; // cached VP matrix for HUD projection

// === NEW FEATURES STATE ===
// 1. Drone
let droneActive=false, droneX=0, droneZ=0, droneBattery=0, droneMarkedEnemies=[], droneMarkTimer=0;
// 2. Battle Royale
let brZoneX=0, brZoneZ=0, brZoneRadius=0, brZoneTarget=0, brShrinkTimer=0, brPhase=0;
// 3. Weather
let weatherType='clear', weatherTimer=30; // 'clear','fog','blizzard','sandstorm'
let weatherFogMult=1.0, weatherSpeedMult=1.0;
// 4. Mines
let mines=[], playerMines=0, maxMines=5;
// 5. Akimbo
let hasAkimbo=false, akimboActive=false;
// 6. Parkour
let wallRunning=false, wallRunTimer=0, wallRunSide=0, isSliding=false, slideTimer=0;
// 7. Ally commands
let allyCommandMode='follow', commandWheelOpen=false;
// 8. Equipment
let equipHelmet=0, equipVest=0, equipKnees=0; // HP left (0=none)
let hasEquipHelmet=false, hasEquipVest=false, hasEquipKnees=false;
// 9. Wave Defense
let wdWave=0, wdPoint={x:0,z:0}, wdWaveTimer=0, wdPointHP=100;
// 10. Vehicle
let inVehicle=false, vehicleX=0, vehicleZ=0, vehicleAngle=0, vehicleSpeed=0;
// 11. Cameras
let cameras=[], cameraViewActive=false, cameraViewIndex=0;
// 12. Gravity gun
let gravHolding=null, gravDist=3;
// 13. Infection
let infectionTimer=0, infectedCount=0;
// 14. Wound system
let woundLeg=false, woundArm=false, woundBleed=false, woundLegTimer=0, woundArmTimer=0, woundBleedTimer=0;
// 15. Stealth kill
let stealthKillCd=0;
// 16. Map editor
let editorMap=null, editorTool=1;

function findSpawn(){
  for(let z=0;z<MAP_H;z++) for(let x=0;x<MAP_W;x++) if(MAP[z][x]===6) return {x:x*CELL+CELL/2, z:z*CELL+CELL/2};
  return {x:CELL*1.5, z:CELL*1.5};
}

function findItems(type){
  const items=[];
  for(let z=0;z<MAP_H;z++) for(let x=0;x<MAP_W;x++) if(MAP[z][x]===type)
    items.push({x:x*CELL+CELL/2, z:z*CELL+CELL/2, alive:true});
  return items;
}

function findCar(){
  for(let z=0;z<MAP_H;z++) for(let x=0;x<MAP_W;x++) if(MAP[z][x]===5)
    return {x:x*CELL+CELL/2, z:z*CELL+CELL/2};
  return {x:CELL*7, z:CELL*14};
}

function initGame(){
  const sp=findSpawn();
  player={x:sp.x, y:PLAYER_H, z:sp.z, vx:0, vy:0, vz:0, yaw:Math.PI, pitch:0, hp:MAX_HP+armorBonus, onGround:true, crouching:false, ads:false, sprinting:false, stamina:STAMINA_MAX, _ctrlHeld:false, _interactHeld:false, _captureHeld:false};
  enemies=findItems(3).map(e=>({
    x:e.x, z:e.z, hp:100, state:'idle', angle:Math.random()*Math.PI*2,
    shootTimer:1+Math.random()*2, hurtTimer:0, alertTimer:0, flash:0,
    walkPhase:0, speed:2.5+Math.random()*1.5, voiceCd:0
  }));
  moneyBags=findItems(4);
  ammo=MAG_SIZE; reserveAmmo=RESERVE_AMMO;
  reloading=false; reloadTimer=0; shootCd=0; recoil=0; stepTimer=0;
  hitMarkerTimer=0; headshotTimer=0; bleeding=false; bleedTimer=0;
  evacTimer=EVAC_TIME; evacActive=false; allEnemiesDead=false; allMoneyCollected=false;
  capturedEnemy=null;
  particles.length=0;
  bloodDecals.length=0;
  giblets.length=0;
  bloodPools.length=0;
  screenBloodDrops.length=0;
  screenShake=0;
  helmetCracks=[];
  grenades.length=0;
  spawnBarrels();
  spawnDoors();
  // Reset helmet crack canvas
  const hcc=document.getElementById('helmetCrackCanvas');
  if(hcc){hcc.width=hcc.width;hcc.style.display='none';}
  // Spawn allies near player (spread out in circle, avoid walls)
  allies=ALLY_DEFS.map((def,i)=>{
    const ang=Math.PI*2*i/ALLY_DEFS.length;
    let sx,sz,c;
    for(let r=4;r<=12;r+=2){
      sx=sp.x+Math.sin(ang)*r; sz=sp.z+Math.cos(ang)*r;
      const gx=Math.floor(sx/CELL), gz=Math.floor(sz/CELL);
      if(!isWall(gx,gz)){c=collide(sx,sz,0.4);break;}
    }
    if(!c) c=collide(sp.x+Math.sin(ang)*3,sp.z+Math.cos(ang)*3,0.4);
    return {name:def.name,role:def.role,x:c.x,z:c.z,
      hp:100,maxHp:100,angle:Math.random()*Math.PI*2,walkPhase:0,state:'follow',
      speed:def.role==='dumb'?1.8:5,shootTimer:0.5+Math.random(),
      hurtTimer:0,flash:0,healCd:0,_wanderTimer:0,_wanderAngle:0};
  });
}

function initJuggernaut(){
  const sp=findSpawn();
  player={x:sp.x, y:PLAYER_H, z:sp.z, vx:0, vy:0, vz:0, yaw:Math.PI, pitch:0, hp:500, onGround:true, crouching:false, ads:false, sprinting:false, stamina:STAMINA_MAX, _ctrlHeld:false, _interactHeld:false, _captureHeld:false};
  enemies=[];
  moneyBags=[];
  ammo=200; reserveAmmo=9999;
  reloading=false; reloadTimer=0; shootCd=0; recoil=0; stepTimer=0;
  hitMarkerTimer=0; headshotTimer=0; bleeding=false; bleedTimer=0;
  evacTimer=999; evacActive=false; allEnemiesDead=false; allMoneyCollected=false;
  particles.length=0;
  bloodDecals.length=0;
  giblets.length=0;
  bloodPools.length=0;
  screenBloodDrops.length=0;
  screenShake=0;
  jugKills=0; jugWave=0; jugWaveTimer=3;
  helmetCracks=[]; grenades.length=0;
  const hcc=document.getElementById('helmetCrackCanvas');
  if(hcc){hcc.width=hcc.width;hcc.style.display='none';}
  // Spawn allies in juggernaut too
  allies=ALLY_DEFS.map((def,i)=>{
    const ang=Math.PI*2*i/ALLY_DEFS.length;
    const sx=sp.x+Math.sin(ang)*5, sz=sp.z+Math.cos(ang)*5;
    const c=collide(sx,sz,0.4);
    return {name:def.name,role:def.role,x:c.x,z:c.z,
      hp:100,maxHp:100,angle:Math.random()*Math.PI*2,walkPhase:0,state:'follow',
      speed:def.role==='dumb'?1.8:5,shootTimer:0.5+Math.random(),
      hurtTimer:0,flash:0,healCd:0,_wanderTimer:0,_wanderAngle:0};
  });
}

function spawnJugWave(wave){
  const count=3+wave*2;
  const openCells=[];
  for(let z=1;z<MAP_H-1;z++) for(let x=1;x<MAP_W-1;x++){
    if(MAP[z][x]===0){
      const dx=x*CELL+CELL/2-player.x, dz=z*CELL+CELL/2-player.z;
      if(dx*dx+dz*dz>20*20) openCells.push({x:x*CELL+CELL/2,z:z*CELL+CELL/2});
    }
  }
  for(let i=0;i<count&&openCells.length>0;i++){
    const idx=Math.random()*openCells.length|0;
    const c=openCells.splice(idx,1)[0];
    enemies.push({
      x:c.x, z:c.z, hp:100+wave*20, state:'combat', angle:Math.random()*Math.PI*2,
      shootTimer:0.5+Math.random(), hurtTimer:0, alertTimer:0, flash:0,
      walkPhase:0, speed:3+Math.random()*2+wave*0.3, voiceCd:0
    });
  }
}

function initMathMode(){
  const sp=findSpawn();
  player={x:sp.x, y:PLAYER_H, z:sp.z, vx:0, vy:0, vz:0, yaw:Math.PI, pitch:0, hp:100, onGround:true, crouching:false, ads:false, sprinting:false, stamina:STAMINA_MAX, _ctrlHeld:false, _interactHeld:false, _captureHeld:false};
  mathA=2+Math.floor(Math.random()*9);
  mathB=2+Math.floor(Math.random()*9);
  mathAnswer=mathA*mathB;
  mathTimer=60;
  mathScore=0;
  const wrongAnswers=new Set();
  while(wrongAnswers.size<7){
    let wrong;
    if(Math.random()<0.5){
      wrong=mathAnswer+Math.floor(Math.random()*21)-10;
    } else {
      wrong=(2+Math.floor(Math.random()*9))*(2+Math.floor(Math.random()*9));
    }
    if(wrong!==mathAnswer && wrong>0 && !wrongAnswers.has(wrong)) wrongAnswers.add(wrong);
  }
  const allAnswers=[mathAnswer,...wrongAnswers];
  for(let i=allAnswers.length-1;i>0;i--){
    const j=Math.floor(Math.random()*(i+1));
    [allAnswers[i],allAnswers[j]]=[allAnswers[j],allAnswers[i]];
  }
  const openCells=[];
  for(let z=1;z<MAP_H-1;z++) for(let x=1;x<MAP_W-1;x++){
    if(MAP[z][x]===0){
      const dx=x*CELL+CELL/2-sp.x, dz=z*CELL+CELL/2-sp.z;
      if(dx*dx+dz*dz>10*10) openCells.push({x:x*CELL+CELL/2,z:z*CELL+CELL/2});
    }
  }
  enemies=[];
  for(let i=0;i<allAnswers.length&&openCells.length>0;i++){
    const idx=Math.random()*openCells.length|0;
    const c=openCells.splice(idx,1)[0];
    enemies.push({
      x:c.x, z:c.z, hp:100, state:'idle',
      angle:Math.random()*Math.PI*2,
      shootTimer:999, hurtTimer:0, alertTimer:0, flash:0,
      walkPhase:0, speed:1.5+Math.random()*1.0, voiceCd:0,
      _mathAnswer:allAnswers[i]
    });
  }
  moneyBags=[];
  allies=[];
  ammo=MAG_SIZE; reserveAmmo=RESERVE_AMMO;
  reloading=false; reloadTimer=0; shootCd=0; recoil=0; stepTimer=0;
  hitMarkerTimer=0; headshotTimer=0; bleeding=false; bleedTimer=0;
  evacTimer=999; evacActive=false; allEnemiesDead=false; allMoneyCollected=false;
  capturedEnemy=null;
  particles.length=0; bloodDecals.length=0; giblets.length=0;
  bloodPools.length=0; screenBloodDrops.length=0; screenShake=0;
  helmetCracks=[]; grenades.length=0;
  const hcc=document.getElementById('helmetCrackCanvas');
  if(hcc){hcc.width=hcc.width;hcc.style.display='none';}
}

function initZombieMode(){
  const sp=findSpawn();
  player={x:sp.x, y:PLAYER_H, z:sp.z, vx:0, vy:0, vz:0, yaw:Math.PI, pitch:0, hp:MAX_HP+armorBonus, onGround:true, crouching:false, ads:false, sprinting:false, stamina:STAMINA_MAX, _ctrlHeld:false, _interactHeld:false, _captureHeld:false};
  enemies=[]; moneyBags=[]; allies=[];
  ammo=MAG_SIZE; reserveAmmo=RESERVE_AMMO;
  reloading=false; reloadTimer=0; shootCd=0; recoil=0; stepTimer=0;
  hitMarkerTimer=0; headshotTimer=0; bleeding=false; bleedTimer=0;
  evacTimer=999; evacActive=false; allEnemiesDead=false; allMoneyCollected=false;
  capturedEnemy=null; particles.length=0; bloodDecals.length=0; giblets.length=0;
  bloodPools.length=0; screenBloodDrops.length=0; screenShake=0; helmetCracks=[]; grenades.length=0;
  jugKills=0; jugWave=0; jugWaveTimer=5;
  window._zombieWave=1; window._zombieWaveTimer=2;
  // Spawn initial barrels
  spawnBarrels();
  // Spawn first wave
  spawnZombieWave(1);
  const hcc=document.getElementById('helmetCrackCanvas');
  if(hcc){hcc.width=hcc.width;hcc.style.display='none';}
}

function spawnZombieWave(wave){
  const count=5+wave*3;
  const openCells=[];
  for(let z=1;z<MAP_H-1;z++) for(let x=1;x<MAP_W-1;x++){
    if(MAP[z][x]===0){
      const dx=x*CELL+CELL/2-player.x, dz=z*CELL+CELL/2-player.z;
      if(dx*dx+dz*dz>15*15) openCells.push({x:x*CELL+CELL/2,z:z*CELL+CELL/2});
    }
  }
  for(let i=0;i<count&&openCells.length>0;i++){
    const idx=Math.random()*openCells.length|0;
    const c=openCells.splice(idx,1)[0];
    enemies.push({
      x:c.x, z:c.z, hp:60+wave*10, state:'combat', angle:Math.random()*Math.PI*2,
      shootTimer:999, hurtTimer:0, alertTimer:0, flash:0,
      walkPhase:0, speed:1.5+Math.random()*0.8+wave*0.1, voiceCd:0, _zombie:true
    });
  }
}

function initBossMode(){
  const sp=findSpawn();
  // Center of map
  const cx=MAP_W*CELL/2, cz=MAP_H*CELL/2;
  player={x:cx, y:PLAYER_H, z:cz-8, vx:0, vy:0, vz:0, yaw:0, pitch:0, hp:MAX_HP+armorBonus, onGround:true, crouching:false, ads:false, sprinting:false, stamina:STAMINA_MAX, _ctrlHeld:false, _interactHeld:false, _captureHeld:false};
  enemies=[{
    x:cx, z:cz+8, hp:2000, state:'combat', angle:Math.PI,
    shootTimer:1, hurtTimer:0, alertTimer:0, flash:0,
    walkPhase:0, speed:5, voiceCd:0, _isBoss:true, _bossGlitchTimer:0
  }];
  moneyBags=[]; allies=[];
  ammo=WEAPONS[currentWeapon].mag; reserveAmmo=WEAPONS[currentWeapon].reserve;
  reloading=false; reloadTimer=0; shootCd=0; recoil=0; stepTimer=0;
  hitMarkerTimer=0; headshotTimer=0; bleeding=false; bleedTimer=0;
  evacTimer=999; evacActive=false; allEnemiesDead=false; allMoneyCollected=false;
  capturedEnemy=null; particles.length=0; bloodDecals.length=0; giblets.length=0;
  bloodPools.length=0; screenBloodDrops.length=0; screenShake=0; helmetCracks=[]; grenades.length=0;
  barrels=[]; doors=[];
  const hcc=document.getElementById('helmetCrackCanvas');
  if(hcc){hcc.width=hcc.width;hcc.style.display='none';}
}

function spawnBarrels(){
  barrels=[];
  const openCells=[];
  for(let z=1;z<MAP_H-1;z++) for(let x=1;x<MAP_W-1;x++)
    if(MAP[z][x]===0) openCells.push({x:x*CELL+CELL/2,z:z*CELL+CELL/2});
  for(let i=0;i<6&&openCells.length>0;i++){
    const idx=Math.random()*openCells.length|0;
    const c=openCells.splice(idx,1)[0];
    barrels.push({x:c.x,z:c.z,hp:30,exploded:false});
  }
}

function spawnDoors(){
  doors=[];
  // Find wall cells that have open cells on both sides (horizontal or vertical)
  for(let z=2;z<MAP_H-2;z++) for(let x=2;x<MAP_W-2;x++){
    if(MAP[z][x]!==1) continue;
    // Horizontal doorway: open cells left & right
    if(MAP[z][x-1]===0 && MAP[z][x+1]===0 && MAP[z-1][x]===1 && MAP[z+1][x]===1){
      if(doors.length<4 && Math.random()<0.15){
        doors.push({gx:x,gz:z,x:x*CELL+CELL/2,z:z*CELL+CELL/2,open:false,anim:0});
      }
    }
    // Vertical doorway: open cells top & bottom
    if(MAP[z-1][x]===0 && MAP[z+1][x]===0 && MAP[z][x-1]===1 && MAP[z][x+1]===1){
      if(doors.length<4 && Math.random()<0.15){
        doors.push({gx:x,gz:z,x:x*CELL+CELL/2,z:z*CELL+CELL/2,open:false,anim:0});
      }
    }
  }
  // Mark door cells as passable (0) in MAP when open
  // Initially doors are closed, so MAP stays as wall
}

function addXP(amount){
  playerXP+=amount;
  while(playerXP>=XP_PER_LEVEL*playerLevel){
    playerXP-=XP_PER_LEVEL*playerLevel;
    playerLevel++;
  }
}

// === NEW INIT FUNCTIONS ===
function initBattleRoyale(){
  const sp=findSpawn();
  player={x:sp.x, y:PLAYER_H, z:sp.z, vx:0, vy:0, vz:0, yaw:Math.PI, pitch:0, hp:MAX_HP+armorBonus, onGround:true, crouching:false, ads:false, sprinting:false, stamina:STAMINA_MAX, _ctrlHeld:false, _interactHeld:false, _captureHeld:false};
  // Spawn many enemies spread across map
  const openCells=[];
  for(let z=1;z<MAP_H-1;z++) for(let x=1;x<MAP_W-1;x++){
    if(MAP[z][x]===0){const dx=x*CELL+CELL/2-sp.x,dz=z*CELL+CELL/2-sp.z;if(dx*dx+dz*dz>10*10) openCells.push({x:x*CELL+CELL/2,z:z*CELL+CELL/2});}
  }
  enemies=[];
  for(let i=0;i<15&&openCells.length>0;i++){
    const idx=Math.random()*openCells.length|0;
    const c=openCells.splice(idx,1)[0];
    enemies.push({x:c.x,z:c.z,hp:100,state:'combat',angle:Math.random()*Math.PI*2,shootTimer:1+Math.random()*2,hurtTimer:0,alertTimer:0,flash:0,walkPhase:0,speed:3+Math.random()*2,voiceCd:0});
  }
  moneyBags=findItems(4); allies=[];
  ammo=MAG_SIZE; reserveAmmo=RESERVE_AMMO;
  reloading=false; reloadTimer=0; shootCd=0; recoil=0; stepTimer=0;
  hitMarkerTimer=0; headshotTimer=0; bleeding=false; bleedTimer=0;
  evacTimer=999; evacActive=false; capturedEnemy=null;
  particles.length=0; bloodDecals.length=0; giblets.length=0; bloodPools.length=0; screenBloodDrops.length=0; screenShake=0; helmetCracks=[]; grenades.length=0;
  spawnBarrels(); spawnDoors();
  // Battle royale zone
  brZoneX=MAP_W*CELL/2; brZoneZ=MAP_H*CELL/2;
  brZoneRadius=MAP_W*CELL*0.6; brZoneTarget=brZoneRadius; brShrinkTimer=30; brPhase=0;
}

function initWaveDefense(){
  const sp=findSpawn();
  player={x:sp.x, y:PLAYER_H, z:sp.z, vx:0, vy:0, vz:0, yaw:Math.PI, pitch:0, hp:MAX_HP+armorBonus, onGround:true, crouching:false, ads:false, sprinting:false, stamina:STAMINA_MAX, _ctrlHeld:false, _interactHeld:false, _captureHeld:false};
  enemies=[]; moneyBags=[]; allies=[];
  ammo=MAG_SIZE; reserveAmmo=RESERVE_AMMO*2;
  reloading=false; reloadTimer=0; shootCd=0; recoil=0; stepTimer=0;
  hitMarkerTimer=0; headshotTimer=0; bleeding=false; bleedTimer=0;
  evacTimer=999; evacActive=false; capturedEnemy=null;
  particles.length=0; bloodDecals.length=0; giblets.length=0; bloodPools.length=0; screenBloodDrops.length=0; screenShake=0; helmetCracks=[]; grenades.length=0;
  spawnBarrels(); spawnDoors();
  wdWave=0; wdPoint={x:sp.x,z:sp.z}; wdWaveTimer=5; wdPointHP=100;
  // Spawn allies to help defend
  allies=ALLY_DEFS.slice(0,4).map((def,i)=>{
    const ang=Math.PI*2*i/4;
    const c=collide(sp.x+Math.sin(ang)*4,sp.z+Math.cos(ang)*4,0.4);
    return {name:def.name,role:def.role,x:c.x,z:c.z,hp:100,maxHp:100,angle:Math.random()*Math.PI*2,walkPhase:0,state:'follow',speed:5,shootTimer:0.5+Math.random(),hurtTimer:0,flash:0,healCd:0,_wanderTimer:0,_wanderAngle:0};
  });
}

function spawnWDWave(wave){
  const count=4+wave*3;
  const openCells=[];
  for(let z=1;z<MAP_H-1;z++) for(let x=1;x<MAP_W-1;x++){
    if(MAP[z][x]===0){const dx=x*CELL+CELL/2-wdPoint.x,dz=z*CELL+CELL/2-wdPoint.z;if(dx*dx+dz*dz>18*18)openCells.push({x:x*CELL+CELL/2,z:z*CELL+CELL/2});}
  }
  for(let i=0;i<count&&openCells.length>0;i++){
    const idx=Math.random()*openCells.length|0;
    const c=openCells.splice(idx,1)[0];
    enemies.push({x:c.x,z:c.z,hp:80+wave*15,state:'combat',angle:Math.random()*Math.PI*2,shootTimer:0.5+Math.random(),hurtTimer:0,alertTimer:0,flash:0,walkPhase:0,speed:3+Math.random()*1.5+wave*0.2,voiceCd:0});
  }
}

function initInfection(){
  const sp=findSpawn();
  player={x:sp.x, y:PLAYER_H, z:sp.z, vx:0, vy:0, vz:0, yaw:Math.PI, pitch:0, hp:MAX_HP+armorBonus, onGround:true, crouching:false, ads:false, sprinting:false, stamina:STAMINA_MAX, _ctrlHeld:false, _interactHeld:false, _captureHeld:false};
  moneyBags=[]; allies=[];
  ammo=MAG_SIZE; reserveAmmo=RESERVE_AMMO;
  reloading=false; reloadTimer=0; shootCd=0; recoil=0; stepTimer=0;
  hitMarkerTimer=0; headshotTimer=0; bleeding=false; bleedTimer=0;
  evacTimer=999; evacActive=false; capturedEnemy=null;
  particles.length=0; bloodDecals.length=0; giblets.length=0; bloodPools.length=0; screenBloodDrops.length=0; screenShake=0; helmetCracks=[]; grenades.length=0;
  spawnBarrels(); spawnDoors();
  infectionTimer=90; infectedCount=0;
  // Spawn zombie and normal enemies
  const openCells=[];
  for(let z=1;z<MAP_H-1;z++) for(let x=1;x<MAP_W-1;x++){
    if(MAP[z][x]===0){const dx=x*CELL+CELL/2-sp.x,dz=z*CELL+CELL/2-sp.z;if(dx*dx+dz*dz>12*12)openCells.push({x:x*CELL+CELL/2,z:z*CELL+CELL/2});}
  }
  enemies=[];
  // 2 initial zombies
  for(let i=0;i<2&&openCells.length>0;i++){
    const idx=Math.random()*openCells.length|0;
    const c=openCells.splice(idx,1)[0];
    enemies.push({x:c.x,z:c.z,hp:120,state:'combat',angle:Math.random()*Math.PI*2,shootTimer:999,hurtTimer:0,alertTimer:0,flash:0,walkPhase:0,speed:2.5+Math.random(),voiceCd:0,_zombie:true,_infected:true});
  }
  // 8 normal enemies
  for(let i=0;i<8&&openCells.length>0;i++){
    const idx=Math.random()*openCells.length|0;
    const c=openCells.splice(idx,1)[0];
    enemies.push({x:c.x,z:c.z,hp:80,state:'idle',angle:Math.random()*Math.PI*2,shootTimer:1+Math.random()*2,hurtTimer:0,alertTimer:0,flash:0,walkPhase:0,speed:3+Math.random(),voiceCd:0});
  }
}

function spawnCameras(){
  cameras=[];
  // Place cameras in corners of open areas
  const spots=[[3,3],[MAP_W-4,3],[3,MAP_H-4],[MAP_W-4,MAP_H-4],[MAP_W/2|0,MAP_H/2|0]];
  for(const sp of spots){
    const gx=sp[0],gz=sp[1];
    if(gx>=0&&gx<MAP_W&&gz>=0&&gz<MAP_H&&MAP[gz][gx]===0){
      cameras.push({x:gx*CELL+CELL/2,z:gz*CELL+CELL/2,y:WALL_H-0.5,angle:Math.random()*Math.PI*2,alive:true});
    }
  }
}

// === MINE FUNCTIONS ===
function placeMine(){
  if(playerMines<=0||mines.length>=maxMines) return;
  playerMines--;
  mines.push({x:player.x,z:player.z,armed:false,armTimer:1.5,exploded:false});
  playSound('reload');
}
function updateMines(dt){
  for(let i=mines.length-1;i>=0;i--){
    const m=mines[i];
    if(m.exploded){mines.splice(i,1);continue;}
    if(!m.armed){m.armTimer-=dt;if(m.armTimer<=0)m.armed=true;continue;}
    // Check enemy proximity
    for(const e of enemies){
      if(e.hp<=0) continue;
      const dx=e.x-m.x,dz=e.z-m.z;
      if(dx*dx+dz*dz<2.5){
        // Explode
        m.exploded=true;
        screenShake=0.8;
        playSound('explode');
        for(let p=0;p<25;p++){
          const a=Math.random()*Math.PI*2,sp=2+Math.random()*5;
          particles.push({x:m.x,y:0.3,z:m.z,vx:Math.cos(a)*sp,vy:2+Math.random()*6,vz:Math.sin(a)*sp,life:0.4+Math.random()*0.8,maxLife:1.2,size:6+Math.random()*8,r:1,g:0.4+Math.random()*0.3,b:0,isBlood:false});
        }
        // Damage nearby
        for(const e2 of enemies){
          if(e2.hp<=0) continue;
          const dd=Math.sqrt((e2.x-m.x)**2+(e2.z-m.z)**2);
          if(dd<5){
            const dmg=Math.floor(120*(1-dd/5));
            e2.hp-=dmg;if(e2.state!=='hurt')e2._prevState=e2.state;
            e2.state='hurt';e2.hurtTimer=0.4;e2.flash=1;
            if(e2.hp<=0){e2._ragdoll=createRagdoll(e2,(e2.x-m.x)/Math.max(dd,0.1),0.5,(e2.z-m.z)/Math.max(dd,0.1),RC);addXP(15);}
          }
        }
        // Damage player
        const pd=Math.sqrt((player.x-m.x)**2+(player.z-m.z)**2);
        if(pd<5){const pdmg=Math.floor(60*(1-pd/5));player.hp-=pdmg;spawnScreenBlood(2);}
        break;
      }
    }
  }
}

// === DRONE FUNCTIONS ===
function toggleDrone(){
  if(droneActive){droneActive=false;return;}
  if(!hasDrone) return;
  droneActive=true;
  droneX=player.x; droneZ=player.z;
  droneBattery=10;
  droneMarkedEnemies=[];
}
function updateDrone(dt){
  if(!droneActive) return;
  droneBattery-=dt;
  if(droneBattery<=0){droneActive=false;return;}
  // Move drone with WASD
  const spd=20;
  if(keys['KeyW']) droneZ-=spd*dt;
  if(keys['KeyS']) droneZ+=spd*dt;
  if(keys['KeyA']) droneX-=spd*dt;
  if(keys['KeyD']) droneX+=spd*dt;
  // Mark visible enemies
  droneMarkTimer-=dt;
  if(droneMarkTimer<=0){
    droneMarkTimer=0.5;
    for(const e of enemies){
      if(e.hp<=0) continue;
      const dd=Math.sqrt((e.x-droneX)**2+(e.z-droneZ)**2);
      if(dd<25) e._droneMarked=10; // visible for 10s on minimap
    }
  }
  // Decrease mark timers
  for(const e of enemies){if(e._droneMarked>0) e._droneMarked-=dt;}
}

// === VEHICLE FUNCTIONS ===
function enterVehicle(){
  if(inVehicle){inVehicle=false;player.x=vehicleX+2;player.z=vehicleZ;const ec=collide(player.x,player.z,PLAYER_R);player.x=ec.x;player.z=ec.z;return;}
  const car=findCar();
  const dx=player.x-car.x,dz=player.z-car.z;
  if(dx*dx+dz*dz<9){
    inVehicle=true;vehicleX=car.x;vehicleZ=car.z;vehicleAngle=0;vehicleSpeed=0;
  }
}
function updateVehicle(dt){
  if(!inVehicle) return;
  // Accelerate/brake
  if(keys['KeyW']) vehicleSpeed=Math.min(25,vehicleSpeed+15*dt);
  else if(keys['KeyS']) vehicleSpeed=Math.max(-8,vehicleSpeed-20*dt);
  else vehicleSpeed*=Math.max(0,1-3*dt);
  // Steer
  if(keys['KeyA']) vehicleAngle-=2.5*dt*(Math.abs(vehicleSpeed)>1?1:0);
  if(keys['KeyD']) vehicleAngle+=2.5*dt*(Math.abs(vehicleSpeed)>1?1:0);
  // Move with proper collision
  vehicleX+=Math.sin(vehicleAngle)*vehicleSpeed*dt;
  vehicleZ+=Math.cos(vehicleAngle)*vehicleSpeed*dt;
  const vc=collide(vehicleX,vehicleZ,1.2);
  if(vc.x!==vehicleX||vc.z!==vehicleZ) vehicleSpeed*=-0.3;
  vehicleX=vc.x;vehicleZ=vc.z;
  // Player follows vehicle
  player.x=vehicleX;player.z=vehicleZ;
  // Run over enemies
  for(const e of enemies){
    if(e.hp<=0) continue;
    const dd=Math.sqrt((e.x-vehicleX)**2+(e.z-vehicleZ)**2);
    if(dd<2&&Math.abs(vehicleSpeed)>5){
      e.hp-=Math.abs(vehicleSpeed)*8;
      if(e.state!=='hurt')e._prevState=e.state;
      e.state='hurt';e.hurtTimer=0.3;e.flash=1;
      if(e.hp<=0){e._ragdoll=createRagdoll(e,Math.sin(vehicleAngle),0.5,Math.cos(vehicleAngle),RC);addXP(15);}
      vehicleSpeed*=0.7;screenShake=0.5;
    }
  }
}

// === WEATHER FUNCTIONS ===
function updateWeather(dt){
  weatherTimer-=dt;
  if(weatherTimer<=0){
    const types=['clear','clear','clear','fog','blizzard','sandstorm'];
    weatherType=types[Math.random()*types.length|0];
    weatherTimer=30+Math.random()*30;
    if(weatherType==='fog'){weatherFogMult=0.4;weatherSpeedMult=1.0;}
    else if(weatherType==='blizzard'){weatherFogMult=0.6;weatherSpeedMult=0.7;}
    else if(weatherType==='sandstorm'){weatherFogMult=0.3;weatherSpeedMult=0.85;}
    else{weatherFogMult=1.0;weatherSpeedMult=1.0;}
  }
}

// === BATTLE ROYALE ZONE ===
function updateBRZone(dt){
  brShrinkTimer-=dt;
  if(brShrinkTimer<=0){
    brPhase++;
    brZoneTarget=Math.max(8,brZoneRadius*0.65);
    brShrinkTimer=30;
  }
  // Smooth shrink
  if(brZoneRadius>brZoneTarget) brZoneRadius=Math.max(brZoneTarget,brZoneRadius-dt*3);
  // Damage outside zone
  const dx=player.x-brZoneX,dz=player.z-brZoneZ;
  const dist=Math.sqrt(dx*dx+dz*dz);
  if(dist>brZoneRadius){
    player.hp-=(5+brPhase*2)*dt;
    if(Math.random()<0.1) spawnScreenBlood(1);
  }
  // Kill enemies outside zone
  for(const e of enemies){
    if(e.hp<=0) continue;
    const ed=Math.sqrt((e.x-brZoneX)**2+(e.z-brZoneZ)**2);
    if(ed>brZoneRadius+5) e.hp-=10*dt;
  }
}

// === WOUND SYSTEM ===
function applyWound(hitZone){
  // hitZone: 'head','body','leg'
  if(hitZone==='leg'&&!woundLeg){woundLeg=true;woundLegTimer=8;}
  if(hitZone==='body'&&Math.random()<0.4){woundBleed=true;woundBleedTimer=10;}
  if(hitZone==='head'&&Math.random()<0.3){woundArm=true;woundArmTimer=6;}// disorientation
}
function updateWounds(dt){
  if(woundLeg){woundLegTimer-=dt;if(woundLegTimer<=0)woundLeg=false;}
  if(woundArm){woundArmTimer-=dt;if(woundArmTimer<=0)woundArm=false;}
  if(woundBleed){
    woundBleedTimer-=dt;player.hp-=2*dt;
    if(woundBleedTimer<=0)woundBleed=false;
  }
}

// === STEALTH KILL ===
function tryStealthKill(){
  if(stealthKillCd>0) return false;
  for(const e of enemies){
    if(e.hp<=0||e.state==='dead'||e._zombie) continue;
    const dx=e.x-player.x,dz=e.z-player.z;
    const dist=Math.sqrt(dx*dx+dz*dz);
    if(dist>2.0) continue;
    // Check if player is behind enemy
    const toPlayer=Math.atan2(-dx,-dz);
    let angleDiff=e.angle-toPlayer;
    while(angleDiff>Math.PI)angleDiff-=Math.PI*2;
    while(angleDiff<-Math.PI)angleDiff+=Math.PI*2;
    if(Math.abs(angleDiff)>Math.PI*0.6){ // player is behind
      e.hp=0;
      e._ragdoll=createRagdoll(e,0,-0.3,0,RC);
      addXP(30);
      screenShake=0.3;
      playSound('hit');
      stealthKillCd=2;
      if(goreEnabled) spawnDirectionalBlood(e.x,1.3,e.z,dx/dist,0,dz/dist,15);
      return true;
    }
  }
  return false;
}

// === GRAVITY GUN ===
function updateGravGun(dt){
  if(currentWeapon!==5||!hasGravGun) return;
  if(gravHolding){
    // Hold object in front of player
    const cp=Math.cos(player.pitch),sp2=Math.sin(player.pitch);
    const sy=Math.sin(player.yaw),cy=Math.cos(player.yaw);
    const tx=player.x-sy*cp*gravDist,ty=player.y+sp2*gravDist,tz=player.z-cy*cp*gravDist;
    if(gravHolding.type==='barrel'){
      const b=gravHolding.obj;
      b.x+=(tx-b.x)*10*dt; b.z+=(tz-b.z)*10*dt;
    } else if(gravHolding.type==='body'){
      const e=gravHolding.obj;
      if(e._ragdoll){
        const sp=e._ragdoll.particles[RS];
        sp.x+=(tx-sp.x)*8*dt; sp.y+=(ty-sp.y)*8*dt; sp.z+=(tz-sp.z)*8*dt;
        e._ragdoll.sleeping=false;e._ragdoll.sleepFrames=0;
      }
    }
    // Throw on click
    if(mouseDown){
      const throwF=20;
      if(gravHolding.type==='barrel'){
        const b=gravHolding.obj;
        // Launch barrel forward and explode on impact (just explode)
        setTimeout(()=>{if(!b.exploded){b.exploded=true;explodeBarrel(b);}},500);
      }
      gravHolding=null;
    }
  } else if(mouseRightDown){
    // Try to grab nearest object
    const cp=Math.cos(player.pitch),sp2=Math.sin(player.pitch);
    const sy=Math.sin(player.yaw),cy=Math.cos(player.yaw);
    const dx=-sy*cp,dy=sp2,dz=-cy*cp;
    // Check barrels
    for(const b of barrels){
      if(b.exploded) continue;
      const bx=b.x-player.x,bz=b.z-player.z;
      const dd=Math.sqrt(bx*bx+bz*bz);
      if(dd<6){gravHolding={type:'barrel',obj:b};break;}
    }
    // Check dead bodies
    if(!gravHolding){
      for(const e of enemies){
        if(e.hp>0||!e._ragdoll) continue;
        const bx=e.x-player.x,bz=e.z-player.z;
        const dd=Math.sqrt(bx*bx+bz*bz);
        if(dd<5){gravHolding={type:'body',obj:e};break;}
      }
    }
  }
}

// === PARKOUR FUNCTIONS ===
function checkWallRun(dt){
  if(!player.onGround&&!wallRunning){
    // Check if near wall and moving forward
    const forward={x:-Math.sin(player.yaw),z:-Math.cos(player.yaw)};
    const right={x:Math.cos(player.yaw),z:-Math.sin(player.yaw)};
    // Check right wall
    const rCheckX=player.x+right.x*0.7,rCheckZ=player.z+right.z*0.7;
    const rGX=Math.floor(rCheckX/CELL),rGZ=Math.floor(rCheckZ/CELL);
    if(isWall(rGX,rGZ)&&(keys['KeyW']||keys['ArrowUp'])){
      wallRunning=true;wallRunTimer=0.8;wallRunSide=1;
      player.vy=3;
    }
    // Check left wall
    const lCheckX=player.x-right.x*0.7,lCheckZ=player.z-right.z*0.7;
    const lGX=Math.floor(lCheckX/CELL),lGZ=Math.floor(lCheckZ/CELL);
    if(!wallRunning&&isWall(lGX,lGZ)&&(keys['KeyW']||keys['ArrowUp'])){
      wallRunning=true;wallRunTimer=0.8;wallRunSide=-1;
      player.vy=3;
    }
  }
  if(wallRunning){
    wallRunTimer-=dt;
    player.vy=Math.max(0,player.vy-5*dt); // slow gravity while wall running
    // Move forward along wall
    const forward={x:-Math.sin(player.yaw),z:-Math.cos(player.yaw)};
    player.x+=forward.x*MOVE_SPEED*1.2*dt;
    player.z+=forward.z*MOVE_SPEED*1.2*dt;
    const col=collide(player.x,player.z,PLAYER_R);
    player.x=col.x;player.z=col.z;
    if(wallRunTimer<=0||player.onGround){wallRunning=false;}
    // Jump off wall
    if(keys['Space']){
      const right={x:Math.cos(player.yaw),z:-Math.sin(player.yaw)};
      player.vy=JUMP_V*0.8;
      player.x-=right.x*wallRunSide*2;
      player.z-=right.z*wallRunSide*2;
      const wc=collide(player.x,player.z,PLAYER_R);
      player.x=wc.x;player.z=wc.z;
      wallRunning=false;
    }
  }
}
function updateSlide(dt){
  if(isSliding){
    slideTimer-=dt;
    const forward={x:-Math.sin(player.yaw),z:-Math.cos(player.yaw)};
    player.x+=forward.x*MOVE_SPEED*SPRINT_MULT*1.2*dt;
    player.z+=forward.z*MOVE_SPEED*SPRINT_MULT*1.2*dt;
    const col=collide(player.x,player.z,PLAYER_R);
    player.x=col.x;player.z=col.z;
    if(slideTimer<=0){isSliding=false;player.crouching=false;}
  }
}

// === CAMERA FUNCTIONS ===
function updateCameraView(){
  if(cameras.length===0){cameraViewActive=false;return;}
  let start=cameraViewIndex;
  for(let i=0;i<cameras.length;i++){
    cameraViewIndex=(start+1+i)%cameras.length;
    if(cameras[cameraViewIndex].alive) return;
  }
  cameraViewActive=false; // no alive cameras
}

// === MAP EDITOR ===
function initMapEditor(){
  editorMap=[];
  for(let z=0;z<MAP_H;z++){
    editorMap[z]=[];
    for(let x=0;x<MAP_W;x++) editorMap[z][x]=MAP[z][x];
  }
  drawEditorMap();
}
function drawEditorMap(){
  const ec=document.getElementById('editorCanvas');
  if(!ec) return;
  const ctx=ec.getContext('2d');
  const cw=ec.width/MAP_W, ch=ec.height/MAP_H;
  ctx.fillStyle='#111';ctx.fillRect(0,0,ec.width,ec.height);
  const colors={0:'#222',1:'#666',2:'#864',3:'#f44',4:'#ff0',5:'#08f',6:'#0f0'};
  for(let z=0;z<MAP_H;z++) for(let x=0;x<MAP_W;x++){
    ctx.fillStyle=colors[editorMap[z][x]]||'#222';
    ctx.fillRect(x*cw,z*ch,cw-1,ch-1);
  }
  // Grid lines
  ctx.strokeStyle='rgba(0,255,0,0.15)';ctx.lineWidth=0.5;
  for(let x=0;x<=MAP_W;x++){ctx.beginPath();ctx.moveTo(x*cw,0);ctx.lineTo(x*cw,ec.height);ctx.stroke();}
  for(let z=0;z<=MAP_H;z++){ctx.beginPath();ctx.moveTo(0,z*ch);ctx.lineTo(ec.width,z*ch);ctx.stroke();}
}
function editorClick(ex,ey){
  const ec=document.getElementById('editorCanvas');
  if(!ec||!editorMap) return;
  const rect=ec.getBoundingClientRect();
  const mx=(ex-rect.left)/rect.width*MAP_W|0;
  const my=(ey-rect.top)/rect.height*MAP_H|0;
  if(mx>=0&&mx<MAP_W&&my>=0&&my<MAP_H){
    editorMap[my][mx]=editorTool;
    drawEditorMap();
  }
}
function saveEditorMap(){
  if(!editorMap) return;
  try{localStorage.setItem('customMap',JSON.stringify(editorMap));
  const msg=document.getElementById('editorMsg');if(msg){msg.textContent='Карта сохранена!';msg.style.color='#0f0';}}catch(e){}
}
function loadEditorMap(){
  try{
    const d=localStorage.getItem('customMap');
    if(d){editorMap=JSON.parse(d);drawEditorMap();
    const msg=document.getElementById('editorMsg');if(msg){msg.textContent='Карта загружена!';msg.style.color='#ff0';}}
  }catch(e){}
}
function playEditorMap(){
  if(!editorMap) return;
  // Copy editorMap to MAP
  for(let z=0;z<MAP_H;z++) for(let x=0;x<MAP_W;x++) MAP[z][x]=editorMap[z][x];
  // Rebuild level geometry
  rebuildLevel();
  document.getElementById('mapEditorScreen').style.display='none';
  game.start();
}

/* ============================================================
   PLAYER UPDATE
   ============================================================ */
function updatePlayer(dt){
  globalVoiceCd=Math.max(0,globalVoiceCd-dt);
  // Medkit (H key)
  const mxHpMed=gameMode==='juggernaut'?500:(MAX_HP+armorBonus);
  if(keys['KeyH']&&playerMedkits>0&&player.hp<mxHpMed){
    playerMedkits--;player.hp=Math.min(mxHpMed,player.hp+50);
    bleeding=false;playSound('reload');
  }
  // Grenade (T key)
  if(keys['KeyT']&&playerGrenades>0&&!player._grenadeCd){
    playerGrenades--;
    player._grenadeCd=true;
    setTimeout(()=>{if(player)player._grenadeCd=false;},500);
    const cp2=Math.cos(player.pitch),sp2=Math.sin(player.pitch);
    const sy2=Math.sin(player.yaw),cy2=Math.cos(player.yaw);
    const gd={x:-sy2*cp2, y:sp2, z:-cy2*cp2};
    grenades.push({x:player.x+gd.x,y:player.y+gd.y*0.5,z:player.z+gd.z,
      vx:gd.x*18,vy:gd.y*18+5,vz:gd.z*18,timer:2.0});
  }
  // Weapon switch (1-4) — cancel reload, reset ammo to weapon's mag
  const prevWeapon=currentWeapon;
  if(keys['Digit1']) currentWeapon=0;
  if(keys['Digit2']&&hasShotgun) currentWeapon=1;
  if(keys['Digit3']&&hasPistol) currentWeapon=2;
  if(keys['Digit4']&&hasSniper) currentWeapon=3;
  if(keys['Digit5']&&hasGlitchWeapon) currentWeapon=4;
  if(currentWeapon!==prevWeapon){
    // Store ammo for previous weapon
    if(!player._weaponAmmo) player._weaponAmmo=[MAG_SIZE,6,12,5,20];
    if(!player._weaponReserve) player._weaponReserve=[RESERVE_AMMO,30,999,25,100];
    player._weaponAmmo[prevWeapon]=ammo;
    player._weaponReserve[prevWeapon]=reserveAmmo;
    // Load ammo for new weapon
    ammo=player._weaponAmmo[currentWeapon]||(WEAPONS[currentWeapon]||WEAPONS[0]).mag;
    reserveAmmo=player._weaponReserve[currentWeapon]||(WEAPONS[currentWeapon]||WEAPONS[0]).reserve;
    reloading=false;
    document.getElementById('reloadBar').style.display='none';
    playSound('reload');
  }
  // Bullet time (Z)
  if(keys['KeyZ']&&hasBulletTime&&bulletTimeLeft<=0&&bulletTimeCd<=0&&!player._btHeld){
    bulletTimeLeft=3;player._btHeld=true;
  }
  if(!keys['KeyZ']) player._btHeld=false;
  // Night vision (N)
  if(keys['KeyN']&&hasNightVision&&!player._nvHeld){
    nightVision=!nightVision;player._nvHeld=true;
    document.getElementById('nightVisionOverlay').style.display=nightVision?'block':'none';
  }
  if(!keys['KeyN']) player._nvHeld=false;
  // Shield (RMB when has shield and not ADS weapon)
  shieldActive=mouseRightDown&&hasShield&&shieldHP>0&&currentWeapon===0;
  // Weapon 6 = gravity gun
  if(keys['Digit6']&&hasGravGun) currentWeapon=5;
  // Mine placement (C key)
  if(keys['KeyC']&&!player._mineHeld&&playerMines>0){placeMine();player._mineHeld=true;}
  if(!keys['KeyC']) player._mineHeld=false;
  // Drone toggle (V key)
  if(keys['KeyV']&&!player._droneHeld){toggleDrone();player._droneHeld=true;}
  if(!keys['KeyV']) player._droneHeld=false;
  // If drone active, skip player movement
  if(droneActive){updateDrone(dt);return;}
  // Stealth kill (B key)
  if(keys['KeyB']&&!player._stealthHeld){tryStealthKill();player._stealthHeld=true;}
  if(!keys['KeyB']) player._stealthHeld=false;
  stealthKillCd=Math.max(0,stealthKillCd-dt);
  // Akimbo toggle (M key)
  if(keys['KeyM']&&hasAkimbo&&!player._akimboHeld){akimboActive=!akimboActive;player._akimboHeld=true;if(akimboActive)currentWeapon=2;}
  if(!keys['KeyM']) player._akimboHeld=false;
  // Command wheel (X key)
  if(keys['KeyX']&&!commandWheelOpen){commandWheelOpen=true;document.getElementById('commandWheel').style.display='block';}
  if(!keys['KeyX']&&commandWheelOpen){commandWheelOpen=false;document.getElementById('commandWheel').style.display='none';}
  if(commandWheelOpen){
    if(keys['Digit1']){allyCommandMode='follow';commandWheelOpen=false;document.getElementById('commandWheel').style.display='none';}
    if(keys['Digit2']){allyCommandMode='hold';commandWheelOpen=false;document.getElementById('commandWheel').style.display='none';}
    if(keys['Digit3']){allyCommandMode='attack';commandWheelOpen=false;document.getElementById('commandWheel').style.display='none';}
    if(keys['Digit4']){allyCommandMode='heal';commandWheelOpen=false;document.getElementById('commandWheel').style.display='none';}
  }
  // Vehicle entry (F near car when not interacting with other things)
  if(keys['KeyF']&&!player._vehicleHeld){
    if(inVehicle){enterVehicle();player._vehicleHeld=true;}
    else if(!inVehicle){const car=findCar();const cdx2=player.x-car.x,cdz2=player.z-car.z;if(cdx2*cdx2+cdz2*cdz2<9&&!evacActive){enterVehicle();player._vehicleHeld=true;}}
  }
  if(!keys['KeyF']) player._vehicleHeld=false;
  if(inVehicle){updateVehicle(dt);return;}
  // Camera view (hold Tab)
  if(keys['Tab']&&!player._camHeld&&cameras.length>0){
    cameraViewActive=!cameraViewActive;
    if(cameraViewActive) updateCameraView();
    player._camHeld=true;
  }
  if(!keys['Tab']) player._camHeld=false;
  // Slide (Shift+Ctrl while sprinting)
  if(player.sprinting&&(keys['ControlLeft']||keys['ControlRight'])&&!isSliding&&player.onGround){
    isSliding=true;slideTimer=0.6;player.crouching=true;
  }
  updateSlide(dt);
  // Defuse bombs (F key near bomb)
  // Movement
  const forward={x:-Math.sin(player.yaw), z:-Math.cos(player.yaw)};
  const right={x:Math.cos(player.yaw), z:-Math.sin(player.yaw)};
  let mx=0, mz=0;
  if(keys['KeyW']||keys['ArrowUp']){mx+=forward.x;mz+=forward.z;}
  if(keys['KeyS']||keys['ArrowDown']){mx-=forward.x;mz-=forward.z;}
  if(keys['KeyA']||keys['ArrowLeft']){mx-=right.x;mz-=right.z;}
  if(keys['KeyD']||keys['ArrowRight']){mx+=right.x;mz+=right.z;}
  const len=Math.sqrt(mx*mx+mz*mz);
  if(len>0){mx/=len;mz/=len;}

  // Crouch toggle (Ctrl)
  if(keys['ControlLeft']||keys['ControlRight']){
    if(!player._ctrlHeld){player.crouching=!player.crouching;player._ctrlHeld=true;}
  } else player._ctrlHeld=false;
  player.ads=mouseRightDown&&!player.sprinting;
  // Sprint (Shift) — only when moving forward, not crouching, not ADS
  const wantSprint=(keys['ShiftLeft']||keys['ShiftRight'])&&(keys['KeyW']||keys['ArrowUp'])&&!player.crouching&&!player.ads&&player.stamina>0;
  player.sprinting=wantSprint;
  if(player.sprinting){player.stamina=Math.max(0,player.stamina-STAMINA_DRAIN*dt);}
  else{player.stamina=Math.min(STAMINA_MAX,player.stamina+STAMINA_REGEN*dt);}
  if(player.stamina<=0) player.sprinting=false;
  const woundMult=woundLeg?0.6:1;
  const spd=MOVE_SPEED*(player.crouching?0.45:1)*(player.ads?0.65:1)*(player.sprinting?SPRINT_MULT:1)*woundMult*weatherSpeedMult;
  player.x+=mx*spd*dt;
  player.z+=mz*spd*dt;

  // Collision
  const col=collide(player.x,player.z,PLAYER_R);
  player.x=col.x; player.z=col.z;

  // Push dead bodies (ragdoll particles) when walking into them
  if(len>0){
    for(const e of enemies){
      if(e.hp>0 || !e._ragdoll) continue;
      const rag=e._ragdoll;
      for(const p of rag.particles){
        const pdx=p.x-player.x, pdz=p.z-player.z;
        const pd=Math.sqrt(pdx*pdx+pdz*pdz);
        if(pd<1.2 && pd>0.01){
          const pushStr=0.15*(1-pd/1.2);
          p.ox-=(pdx/pd)*pushStr;
          p.oz-=(pdz/pd)*pushStr;
          rag.sleeping=false; rag.sleepFrames=0;
        }
      }
    }
  }

  // Jump / Gravity
  if(keys['Space']&&player.onGround){player.vy=JUMP_V;player.onGround=false;}
  player.vy-=GRAVITY*dt;
  player.y+=player.vy*dt;
  const groundH=player.crouching?1.0:PLAYER_H;
  if(player.y<=groundH){player.y=groundH;player.vy=0;player.onGround=true;}
  // Parkour: wall running
  checkWallRun(dt);

  // Footstep sounds
  if(len>0 && player.onGround){
    stepTimer-=dt;
    if(stepTimer<=0){playSound('step');stepTimer=player.sprinting?0.25:0.4;}
  }

  // Shooting (weapon-based fire rate)
  shootCd-=dt;
  const wp=WEAPONS[currentWeapon]||WEAPONS[0];
  const fireCd=gameMode==='juggernaut'?0.05:wp.firerate;
  if(mouseDown && shootCd<=0 && !reloading && ammo>0 && !player.sprinting && !commandWheelOpen){
    playerShoot();
    shootCd=akimboActive?fireCd*0.5:fireCd;
    if(akimboActive&&ammo>0){ammo--;} // double shot
  }

  // Reload (weapon-based mag size and reload time)
  const wpMag=gameMode==='juggernaut'?100:wp.mag;
  const wpReload=wp.reload;
  if(keys['KeyR']&&!reloading&&ammo<wpMag&&reserveAmmo>0) startReload();
  if(ammo<=0&&reserveAmmo>0&&!reloading) startReload();
  if(reloading){
    reloadTimer-=dt;
    document.getElementById('reloadFill').style.width=((1-reloadTimer/wpReload)*100)+'%';
    if(reloadTimer<=0){
      const need=wpMag-ammo;
      const give=Math.min(need,reserveAmmo);
      ammo+=give; reserveAmmo-=give;
      reloading=false;
      document.getElementById('reloadBar').style.display='none';
      playSound('reload');
    }
  }

  // Recoil decay
  recoil*=Math.max(0,1-dt*12);

  // Hit marker decay
  hitMarkerTimer-=dt;
  headshotTimer-=dt;

  // Bleeding
  if(bleeding){
    bleedTimer-=dt;
    player.hp-=BLEED_DPS*dt;
    if(bleedTimer<=0) bleeding=false;
  }

  // Blood overlay
  const maxHp=gameMode==='juggernaut'?500:(MAX_HP+armorBonus);
  const bloodMult=goreEnabled?0.7:0.15;
  document.getElementById('bloodOverlay').style.opacity = Math.max(0, (1-player.hp/maxHp)*bloodMult);

  // Death check
  if(player.hp<=0){
    player.hp=0;
    state='dead';
    droneActive=false;inVehicle=false;cameraViewActive=false;
    playSound('death');
    playVoice("Mission accomplished, he's dead.");
    document.getElementById('deathScreen').style.display='flex';
    if(gameMode==='juggernaut'){
      const dk=document.getElementById('deathKills');
      dk.textContent='Убийства: '+jugKills+' | Волна: '+jugWave;
      dk.style.display='block';
    }
    document.exitPointerLock();
  }

  // Lean (Q/E)
  const wantLeanL=keys['KeyQ']?-1:0;
  const wantLeanR=keys['KeyE']?1:0;
  const leanTarget=(wantLeanL+wantLeanR)*(player.sprinting?0:1);
  leanAmount+=(leanTarget-leanAmount)*Math.min(1,dt*10); // smooth

  // Interaction (F key — E is now lean)
  const interactKey=keys['KeyF'];
  // Door interaction
  if(interactKey && !player._doorHeld){
    for(const door of doors){
      const dd=Math.sqrt((player.x-door.x)**2+(player.z-door.z)**2);
      if(dd<3){
        door.open=!door.open;
        // Toggle MAP cell: 0=open, 1=wall
        MAP[door.gz][door.gx]=door.open?0:1;
        playSound(door.open?'pickup':'step');
        player._doorHeld=true;
        break;
      }
    }
  }
  if(!interactKey) player._doorHeld=false;
  // Money pickup (auto)
  for(const m of moneyBags){
    if(!m.alive) continue;
    const dx=player.x-m.x, dz=player.z-m.z;
    if(dx*dx+dz*dz<4){m.alive=false;playSound('pickup');}
  }

  // G key — BAG / CUFFS (separate from F to avoid conflicts)
  const captureKey=keys['KeyG'];
  if(captureKey && !player._captureHeld){
    // Try bag on nearest alive enemy
    let didCapture=false;
    if(playerBags>0 && !didCapture){
      let best=null, bd=Infinity;
      for(const e of enemies){
        if(e.hp<=0||e.state==='blinded'||e.state==='captured') continue;
        const d2=(player.x-e.x)**2+(player.z-e.z)**2;
        if(d2<bd){bd=d2;best=e;}
      }
      if(best && bd<64){
        best.state='blinded'; best._prevState='blinded';
        best.shootTimer=3; best.hurtTimer=0;
        playerBags--;
        playSound('reload');
        didCapture=true;
      }
    }
    // Try cuffs on nearest blinded enemy
    if(playerCuffs>0 && !didCapture){
      let best=null, bd=Infinity;
      for(const e of enemies){
        if(e.state!=='blinded') continue;
        const d2=(player.x-e.x)**2+(player.z-e.z)**2;
        if(d2<bd){bd=d2;best=e;}
      }
      if(best && bd<64){
        best.state='captured'; best._prevState='captured';
        playerCuffs--;
        if(capturedEnemy&&capturedEnemy.hp>0) capturedEnemy.state='blinded';
        capturedEnemy=best;
        playSound('reload');
        didCapture=true;
      }
    }
  }
  player._captureHeld=!!captureKey;

  // F key — loot, heal, revive
  if(interactKey && !player._interactHeld){
    let interacted=false;
    // Heal wounded ally
    if(!interacted){
      for(const a of allies){
        if(a.hp<=0||a.hp>=a.maxHp) continue;
        const adx=player.x-a.x, adz=player.z-a.z;
        if(adx*adx+adz*adz<6 && playerMedkits>0){
          a.hp=Math.min(a.maxHp,a.hp+50);
          playerMedkits--;
          playSound('reload');
          interacted=true; break;
        }
      }
    }
    // Revive dead ally
    if(!interacted){
      for(const a of allies){
        if(a.hp>0) continue;
        const adx=player.x-a.x, adz=player.z-a.z;
        if(adx*adx+adz*adz<6 && playerMedkits>0){
          a.hp=50; a.state='follow'; a._ragdoll=null;
          playerMedkits--;
          playSound('reload');
          interacted=true; break;
        }
      }
    }
    // Loot dead enemy
    if(!interacted){
      for(const e of enemies){
        if(e.hp>0 || e.looted) continue;
        const dx2=player.x-e.x, dz2=player.z-e.z;
        if(dx2*dx2+dz2*dz2<6){
          e.looted=true;
          reserveAmmo+=gameMode==='juggernaut'?50:15;
          lootCount++;
          playSound('pickup');
          break;
        }
      }
    }
  }
  player._interactHeld=!!interactKey;

  // Check objectives (skip in juggernaut — endless mode)
  if(gameMode==='juggernaut') return;
  allEnemiesDead = enemies.every(e=>e.hp<=0||e.state==='blinded'||e.state==='captured');
  allMoneyCollected = moneyBags.every(m=>!m.alive);

  // Evacuation
  if(allEnemiesDead && allMoneyCollected && !evacActive){
    evacActive=true;
    evacTimer=EVAC_TIME;
  }
  if(evacActive){
    evacTimer-=dt;
    document.getElementById('timerTxt').style.display='block';
    document.getElementById('timerTxt').textContent='ЭВАКУАЦИЯ: '+Math.ceil(evacTimer)+'с';

    // Check if player reached car
    const car=findCar();
    const cdx=player.x-car.x, cdz=player.z-car.z;
    if(cdx*cdx+cdz*cdz<9){
      state='win';
      playerCoins+=40;
      let winMsg='Эвакуация успешна! +40 монет';
      if(capturedEnemy && capturedEnemy.hp>0){
        playerCoins+=60;
        winMsg='Эвакуация успешна! +40 монет\nПленный продан! +60 монет';
      }
      jugUnlocked=true;
      playSound('win');
      const ws=document.getElementById('winScreen');
      ws.querySelector('p').textContent=winMsg;
      ws.style.display='flex';
      document.exitPointerLock();
    }

    if(evacTimer<=0){
      // Failed to evacuate - spawn overwhelming enemies
      state='dead';
      playSound('death');
      document.getElementById('deathScreen').style.display='flex';
      document.getElementById('deathScreen').querySelector('p').textContent='Время вышло! Бригада зачистки прибыла. Машина уехала без тебя.';
      document.exitPointerLock();
    }
  }
}

function startReload(){
  reloading=true;
  const rwp=WEAPONS[currentWeapon]||WEAPONS[0];
  reloadTimer=rwp.reload;
  document.getElementById('reloadBar').style.display='block';
  document.getElementById('reloadFill').style.width='0%';
  playSound('reload');
}

/* ============================================================
   SHOOTING (RAYCASTING)
   ============================================================ */
function playerShoot(){
  ammo--;
  recoil=1;
  const wp=WEAPONS[currentWeapon]||WEAPONS[0];
  player.pitch+=currentWeapon===3?0.04:currentWeapon===1?0.035:0.018;
  const cp=Math.cos(player.pitch), sp=Math.sin(player.pitch);
  const sy=Math.sin(player.yaw), cy=Math.cos(player.yaw);
  const baseDx=-sy*cp, baseDy=sp, baseDz=-cy*cp;
  let bulletDmg=gameMode==='juggernaut'?50:(wp.dmg+weaponBonus+(playerLevel-1));
  if(armorPiercing) bulletDmg*=2;

  playSound('shoot');
  spawnParticles(player.x+baseDx*0.5, player.y+baseDy*0.5-0.2, player.z+baseDz*0.5, 'muzzle');
  // Skeleton mode / glitch weapon: purple muzzle particles
  if(skeletonMode || (currentWeapon===4 && hasGlitchWeapon)){
    for(let pi=0;pi<5;pi++){
      particles.push({x:player.x+baseDx*0.6,y:player.y+baseDy*0.6-0.2,z:player.z+baseDz*0.6,
        vx:baseDx*8+(Math.random()-.5)*2,vy:baseDy*8+(Math.random()-.5)*2,vz:baseDz*8+(Math.random()-.5)*2,
        life:0.3+Math.random()*0.3,r:0.5,g:0,b:0.8,a:1,size:0.04+Math.random()*0.03});
    }
  }

  const pellets=wp.pellets||1;
  const spr=(wp.spread||0)*(woundArm?2.5:1)*(akimboActive?1.5:1);
  for(let pp=0;pp<pellets;pp++){
    const dx=baseDx+(Math.random()-0.5)*spr, dy=baseDy+(Math.random()-0.5)*spr, dz=baseDz+(Math.random()-0.5)*spr;
    singleRaycast(dx,dy,dz,bulletDmg);
  }
  // XP for kills handled inside singleRaycast
}

function singleRaycast(dx,dy,dz,bulletDmg){

  let closestDist=Infinity, closestHit=null;

  // Check enemies — two-zone: head (y=1.72,r=0.25) and body (y=1.0,r=0.55)
  for(const e of enemies){
    if(e.hp<=0) continue;
    // HEAD zone
    const hcY=1.72; // head center y
    const hR=0.25;
    const hex=e.x-player.x, hez=e.z-player.z, hey=hcY-player.y;
    const ha=dx*dx+dy*dy+dz*dz;
    const ht=-(hex*(-dx)+hey*(-dy)+hez*(-dz))/ha;
    if(ht>0){
      const hhx=player.x+dx*ht, hhy=player.y+dy*ht, hhz=player.z+dz*ht;
      const hdd=Math.sqrt((hhx-e.x)**2+(hhy-hcY)**2+(hhz-e.z)**2);
      if(hdd<hR && ht<closestDist){
        closestDist=ht;
        closestHit={type:'enemy',enemy:e,x:hhx,y:hhy,z:hhz,headshot:true};
      }
    }
    // BODY zone (only if no closer head hit)
    const bcY=1.0;
    const bR=0.55;
    const bex=e.x-player.x, bez=e.z-player.z, bey=bcY-player.y;
    const bt=-(bex*(-dx)+bey*(-dy)+bez*(-dz))/ha;
    if(bt>0){
      const bhx=player.x+dx*bt, bhy=player.y+dy*bt, bhz=player.z+dz*bt;
      const bdd=Math.sqrt((bhx-e.x)**2+(bhy-bcY)**2+(bhz-e.z)**2);
      if(bdd<bR && bt<closestDist){
        closestDist=bt;
        closestHit={type:'enemy',enemy:e,x:bhx,y:bhy,z:bhz,headshot:false};
      }
    }
  }

  // Check dead bodies (ragdoll) — sphere test around spine particle
  for(const e of enemies){
    if(e.hp>0 || !e._ragdoll) continue;
    const rag=e._ragdoll;
    const sp=rag.particles[RS];
    const ddx=sp.x-player.x, ddz=sp.z-player.z;
    const ddy=(sp.y+0.4)-player.y; // center of body mass
    const bta=dx*dx+dy*dy+dz*dz;
    const btt=-(ddx*(-dx)+ddy*(-dy)+ddz*(-dz))/bta;
    if(btt>0){
      const cx2=player.x+dx*btt, cy2=player.y+dy*btt, cz2=player.z+dz*btt;
      const cd2=Math.sqrt((cx2-sp.x)**2+(cy2-sp.y-0.4)**2+(cz2-sp.z)**2);
      if(cd2<0.8 && btt<closestDist){
        closestDist=btt;
        closestHit={type:'dead',enemy:e,x:cx2,y:cy2,z:cz2};
      }
    }
  }

  // Check barrels
  for(const bar of barrels){
    if(bar.exploded) continue;
    const bex=bar.x-player.x, bez=bar.z-player.z, bey=0.5-player.y;
    const ba=dx*dx+dy*dy+dz*dz;
    const bt=-(bex*(-dx)+bey*(-dy)+bez*(-dz))/ba;
    if(bt>0){
      const bhx=player.x+dx*bt, bhy=player.y+dy*bt, bhz=player.z+dz*bt;
      const bdd=Math.sqrt((bhx-bar.x)**2+(bhy-0.5)**2+(bhz-bar.z)**2);
      if(bdd<0.6 && bt<closestDist){
        closestDist=bt; closestHit={type:'barrel',barrel:bar,x:bhx,y:bhy,z:bhz};
      }
    }
  }
  // Check walls (step along ray)
  for(let t=0.5;t<60;t+=0.5){
    const hx=player.x+dx*t, hy=player.y+dy*t, hz=player.z+dz*t;
    if(hy<0||hy>WALL_H) break;
    const cx=Math.floor(hx/CELL), cz=Math.floor(hz/CELL);
    if(isWall(cx,cz) && t<closestDist){
      closestDist=t;
      closestHit={type:'wall',x:hx,y:hy,z:hz};
      break;
    }
  }

  if(closestHit){
    if(closestHit.type==='enemy'){
      const e=closestHit.enemy;
      let dmg=closestHit.headshot?300:bulletDmg;
      // Boss takes halved damage, headshots capped at 150
      if(e._isBoss){
        if(closestHit.headshot) dmg=150;
        else dmg=Math.ceil(dmg*0.5);
      }
      e.hp-=dmg;
      // Bullet knockback on ragdoll
      if(e._ragdoll){
        const hitPart = closestHit.headshot ? RH : RC;
        const rp = e._ragdoll.particles[hitPart];
        rp.ox -= dx*1.5; rp.oy -= dy*1.5-0.4; rp.oz -= dz*1.5;
        e._ragdoll.sleeping=false; e._ragdoll.sleepFrames=0;
      }
      if(e.state!=='hurt') e._prevState=e.state;
      e.state='hurt';e.hurtTimer=e._isBoss?0.1:0.3;e.flash=1;
      if(goreEnabled){
        spawnDirectionalBlood(closestHit.x,closestHit.y,closestHit.z,dx,dy,dz,closestHit.headshot?20:10);
        trySpawnWallDecal(closestHit.x,closestHit.y,closestHit.z,dx,dy,dz);
      }
      if(closestHit.headshot){
        headshotTimer=0.5;
        playHeadshotSound();
      }
      playSound('hit');
      hitMarkerTimer=0.2;
      if(e.hp<=0){
        if(capturedEnemy===e) capturedEnemy=null;
        // Math mode: check answer
        if(gameMode==='math' && e._mathAnswer!==undefined){
          if(e._mathAnswer===mathAnswer){
            mathScore=mathDoubleReward?40:20;
            if(mathDoubleReward) mathDoubleReward=false;
            playerCoins+=mathScore;
            state='win';
            playSound('win');
            document.getElementById('winScreen').style.display='flex';
            document.getElementById('winScreen').querySelector('p').textContent=
              mathA+' × '+mathB+' = '+mathAnswer+'\nПравильно! +'+mathScore+' монет\nВсего: '+playerCoins+' монет';
            document.getElementById('mathHud').style.display='none';
            try { document.exitPointerLock(); } catch(ex){}
          } else {
            state='dead';
            playSound('death');
            document.getElementById('deathScreen').style.display='flex';
            document.getElementById('deathScreen').querySelector('p').textContent=
              'Неправильно! '+e._mathAnswer+' ≠ '+mathAnswer+'\n'+mathA+' × '+mathB+' = '+mathAnswer;
            document.getElementById('deathKills').style.display='block';
            document.getElementById('deathKills').textContent='Ваши монеты: '+playerCoins;
            document.getElementById('mathHud').style.display='none';
            try { document.exitPointerLock(); } catch(ex){}
          }
        }
        if(gameMode==='juggernaut') jugKills++;
        // Boss death: +500 coins, unlock glitch weapon
        if(e._isBoss){
          bossDefeated=true; hasGlitchWeapon=true;
          playerCoins+=500;
          screenShake=1.5;
          state='win';
          playSound('win');
          document.getElementById('winScreen').style.display='flex';
          document.getElementById('winScreen').querySelector('p').textContent=
            'ЧЁРНАЯ ОШИБКА УНИЧТОЖЕНА!\n+500 монет\nГлитч-пушка разблокирована!\nВсего: '+playerCoins+' монет';
          try { document.exitPointerLock(); } catch(ex){}
        }
        // Glitch weapon: convert enemy to ally instead of killing
        if(currentWeapon===4 && WEAPONS[4] && WEAPONS[4].glitch && !e._isBoss){
          e.hp=60; e.state='idle';
          e._glitched=true; e._isAlly=true;
          e.flash=1;
          // Spawn purple conversion particles
          for(let pi=0;pi<15;pi++){
            particles.push({x:e.x+(Math.random()-.5),y:1+(Math.random()-.5)*1.5,z:e.z+(Math.random()-.5),
              vx:(Math.random()-.5)*4,vy:Math.random()*3,vz:(Math.random()-.5)*4,
              life:0.8+Math.random()*0.5,r:0.6,g:0,b:1,a:1,size:0.08+Math.random()*0.06});
          }
          return; // don't create ragdoll
        }
        // Skeleton mode: enemy turns to skeleton on kill, then falls apart
        if(skeletonMode && !e._isBoss){
          e._skeleton=true;
          // Spawn purple particles instead of blood
          for(let pi=0;pi<20;pi++){
            particles.push({x:closestHit.x+(Math.random()-.5)*.5,y:closestHit.y+(Math.random()-.5)*.5,z:closestHit.z+(Math.random()-.5)*.5,
              vx:(Math.random()-.5)*5+dx*2,vy:Math.random()*4,vz:(Math.random()-.5)*5+dz*2,
              life:0.6+Math.random()*0.6,r:0.4,g:0,b:0.8,a:1,size:0.06+Math.random()*0.05});
          }
        }
        addXP(closestHit.headshot?25:15);
        screenShake=closestHit.headshot?0.8:0.5;
        // Close-range kill screen blood (<2m)
        if(closestDist<2) spawnScreenBlood(4+Math.floor(Math.random()*5));
        // Create ragdoll on death with stronger knockback
        e._ragdoll=createRagdoll(e, dx, dy, dz, closestHit.headshot?RH:RC);
        // Extra lift impulse - knock them off their feet
        const spP=e._ragdoll.particles[closestHit.headshot?RH:RC];
        spP.oy-=1.2; // upward lift
        // Skeleton dismember all on kill
        if(e._skeleton && e._ragdoll){
          e._ragdoll.headGone=true; e._ragdoll.armLGone=true; e._ragdoll.armRGone=true;
          e._ragdoll.legLGone=true; e._ragdoll.legRGone=true;
        }
        // Dismemberment on kill: determine body zone from hit Y
        if(goreEnabled && dmg>40){
          const hitY=closestHit.y;
          if(closestHit.headshot){
            e._ragdoll.headGone=true;
            spawnDirectionalBlood(closestHit.x,closestHit.y,closestHit.z,dx,dy,dz,30);
            spawnGiblet(closestHit.x,closestHit.y,closestHit.z,dx,dy,dz,.78,.62,.48,0.2);
            playSound('dismember');
          } else {
            const hitX=closestHit.x-e.x, hitZ=closestHit.z-e.z;
            const sa=Math.sin(-e.angle),ca=Math.cos(-e.angle);
            const localX=hitX*ca-hitZ*sa;
            if(hitY>0.9){
              if(localX<0 && !e._ragdoll.armLGone){
                e._ragdoll.armLGone=true;
                spawnDirectionalBlood(closestHit.x,closestHit.y,closestHit.z,dx,dy,dz,20);
                spawnGiblet(closestHit.x,closestHit.y,closestHit.z,dx,dy,dz,.27,.40,.33,0.35);
                playSound('dismember');
              } else if(localX>=0 && !e._ragdoll.armRGone){
                e._ragdoll.armRGone=true;
                spawnDirectionalBlood(closestHit.x,closestHit.y,closestHit.z,dx,dy,dz,20);
                spawnGiblet(closestHit.x,closestHit.y,closestHit.z,dx,dy,dz,.27,.40,.33,0.35);
                playSound('dismember');
              }
            } else {
              if(localX<0 && !e._ragdoll.legLGone){
                e._ragdoll.legLGone=true;
                spawnDirectionalBlood(closestHit.x,closestHit.y,closestHit.z,dx,dy,dz,20);
                spawnGiblet(closestHit.x,closestHit.y,closestHit.z,dx,dy,dz,.21,.27,.21,0.45);
                playSound('dismember');
              } else if(localX>=0 && !e._ragdoll.legRGone){
                e._ragdoll.legRGone=true;
                spawnDirectionalBlood(closestHit.x,closestHit.y,closestHit.z,dx,dy,dz,20);
                spawnGiblet(closestHit.x,closestHit.y,closestHit.z,dx,dy,dz,.21,.27,.21,0.45);
                playSound('dismember');
              }
            }
          }
        } else if(closestHit.headshot && goreEnabled){
          e._ragdoll.headGone=true;
          spawnDirectionalBlood(closestHit.x,closestHit.y,closestHit.z,dx,dy,dz,25);
        }
      }
    } else if(closestHit.type==='dead'){
      // Shooting dead body — post-mortem dismemberment
      const e=closestHit.enemy;
      const rag=e._ragdoll;
      e.flash=0.5;
      if(goreEnabled){
        spawnDirectionalBlood(closestHit.x,closestHit.y,closestHit.z,dx,dy,dz,12);
        trySpawnWallDecal(closestHit.x,closestHit.y,closestHit.z,dx,dy,dz);
      }
      playSound('hit');
      hitMarkerTimer=0.2;
      screenShake=0.3;
      // Stronger knockback on ragdoll
      const hitPart=closestHit.y>1.4?RH:closestHit.y>0.8?RC:RS;
      const rp=rag.particles[hitPart];
      rp.ox-=dx*1.2; rp.oy-=dy*1.2-0.5; rp.oz-=dz*1.2;
      rag.sleeping=false; rag.sleepFrames=0;
      // Dismemberment on dead body
      if(goreEnabled && bulletDmg>40){
        const hitY=closestHit.y;
        const dsp=rag.particles[RS];
        const hitX=closestHit.x-dsp.x, hitZ=closestHit.z-dsp.z;
        const crossVal=hitX*dz-hitZ*dx;
        if(hitY>1.4 && !rag.headGone){
          rag.headGone=true;
          spawnDirectionalBlood(closestHit.x,closestHit.y,closestHit.z,dx,dy,dz,30);
          spawnGiblet(closestHit.x,closestHit.y,closestHit.z,dx,dy,dz,.78,.62,.48,0.2);
          playSound('dismember');
        } else if(hitY>0.8){
          if(crossVal<0 && !rag.armLGone){
            rag.armLGone=true;
            spawnDirectionalBlood(closestHit.x,closestHit.y,closestHit.z,dx,dy,dz,20);
            spawnGiblet(closestHit.x,closestHit.y,closestHit.z,dx,dy,dz,.27,.40,.33,0.35);
            playSound('dismember');
          } else if(crossVal>=0 && !rag.armRGone){
            rag.armRGone=true;
            spawnDirectionalBlood(closestHit.x,closestHit.y,closestHit.z,dx,dy,dz,20);
            spawnGiblet(closestHit.x,closestHit.y,closestHit.z,dx,dy,dz,.27,.40,.33,0.35);
            playSound('dismember');
          }
        } else {
          if(crossVal<0 && !rag.legLGone){
            rag.legLGone=true;
            spawnDirectionalBlood(closestHit.x,closestHit.y,closestHit.z,dx,dy,dz,20);
            spawnGiblet(closestHit.x,closestHit.y,closestHit.z,dx,dy,dz,.21,.27,.21,0.45);
            playSound('dismember');
          } else if(crossVal>=0 && !rag.legRGone){
            rag.legRGone=true;
            spawnDirectionalBlood(closestHit.x,closestHit.y,closestHit.z,dx,dy,dz,20);
            spawnGiblet(closestHit.x,closestHit.y,closestHit.z,dx,dy,dz,.21,.27,.21,0.45);
            playSound('dismember');
          }
        }
      }
    } else if(closestHit.type==='barrel'){
      // Barrel hit — explode it
      const bar=closestHit.barrel;
      bar.hp-=bulletDmg;
      if(bar.hp<=0 && !bar.exploded){
        bar.exploded=true;
        explodeBarrel(bar);
      } else {
        spawnParticles(closestHit.x,closestHit.y,closestHit.z,'impact');
      }
    } else {
      spawnParticles(closestHit.x,closestHit.y,closestHit.z,'impact');
    }
  }
}

function explodeBarrel(bar){
  playSound('explode');
  screenShake=1.0;
  // Fire/smoke particles
  for(let i=0;i<40;i++){
    const a=Math.random()*Math.PI*2, sp=2+Math.random()*6;
    const vy2=3+Math.random()*8;
    particles.push({x:bar.x,y:0.5,z:bar.z,vx:Math.cos(a)*sp,vy:vy2,vz:Math.sin(a)*sp,
      life:0.5+Math.random()*1.0,maxLife:1.5,size:8+Math.random()*12,
      r:1,g:0.3+Math.random()*0.4,b:0,isBlood:false});
  }
  // Damage nearby enemies
  for(const e of enemies){
    if(e.hp<=0) continue;
    const dd=Math.sqrt((e.x-bar.x)**2+(e.z-bar.z)**2);
    if(dd<6){
      const dmg=Math.floor(150*(1-dd/6));
      e.hp-=dmg;
      if(e.state!=='hurt') e._prevState=e.state;
      e.state='hurt'; e.hurtTimer=0.5; e.flash=1;
      if(e.hp<=0){
        e._ragdoll=createRagdoll(e,(e.x-bar.x)/dd,0.5,(e.z-bar.z)/dd,RC);
        addXP(15);
      }
    }
  }
  // Damage player
  const pd=Math.sqrt((player.x-bar.x)**2+(player.z-bar.z)**2);
  if(pd<6){
    const pdmg=Math.floor(80*(1-pd/6));
    if(shieldActive&&shieldHP>0){shieldHP-=pdmg;}
    else player.hp-=pdmg;
    spawnScreenBlood(3);
  }
  // Chain explode nearby barrels
  for(const b2 of barrels){
    if(b2===bar||b2.exploded) continue;
    const bd=Math.sqrt((b2.x-bar.x)**2+(b2.z-bar.z)**2);
    if(bd<4){b2.exploded=true;setTimeout(()=>explodeBarrel(b2),150);}
  }
}

function playHeadshotSound(){
  if(!audioCtx) return;
  const ctx=audioCtx,t=ctx.currentTime;
  // Sharp metallic ping for headshot
  const osc=ctx.createOscillator();osc.type='sine';osc.frequency.value=1400;
  osc.frequency.exponentialRampToValueAtTime(800,t+0.15);
  const g=ctx.createGain();g.gain.value=0.2;g.gain.exponentialRampToValueAtTime(0.001,t+0.2);
  osc.connect(g);g.connect(ctx.destination);osc.start(t);osc.stop(t+0.2);
  // Second harmonic
  const osc2=ctx.createOscillator();osc2.type='triangle';osc2.frequency.value=2200;
  const g2=ctx.createGain();g2.gain.value=0.1;g2.gain.exponentialRampToValueAtTime(0.001,t+0.15);
  osc2.connect(g2);g2.connect(ctx.destination);osc2.start(t);osc2.stop(t+0.15);
}

/* ============================================================
   ENEMY AI
   ============================================================ */
function updateEnemies(dt){
  for(const e of enemies){
    if(e.hp<=0){
      if(capturedEnemy===e) capturedEnemy=null;
      e.state='dead';
      e.flash*=Math.max(0,1-dt*8);
      if(!e._ragdoll) e._ragdoll=createRagdoll(e, 0, -0.5, 0, RC);
      if(!e._ragdoll.sleeping) updateRagdoll(e._ragdoll, dt);
      e.x=e._ragdoll.particles[RS].x; e.z=e._ragdoll.particles[RS].z;
      // Blood pool: spawn once, grow over 5 seconds
      if(!e._bloodPool){
        e._bloodPool={x:e.x,z:e.z,size:0.05,maxSize:0.4+Math.random()*0.3,age:0};
        bloodPools.push(e._bloodPool);
      }
      if(e._bloodPool.age<5){
        e._bloodPool.age+=dt;
        e._bloodPool.size=e._bloodPool.maxSize*Math.min(1,e._bloodPool.age/5);
        e._bloodPool.x=e.x; e._bloodPool.z=e.z;
      }
      continue;
    }
    // Glitched enemies fight for the player — target nearest non-glitched enemy
    if(e._glitched){
      e.flash*=Math.max(0,1-dt*8);
      let nearE=null, nearD=Infinity;
      for(const oe of enemies){
        if(oe===e||oe.hp<=0||oe._glitched) continue;
        const odx=oe.x-e.x, odz=oe.z-e.z, od=Math.sqrt(odx*odx+odz*odz);
        if(od<nearD){nearD=od;nearE=oe;}
      }
      if(nearE){
        e.angle=Math.atan2(nearE.x-e.x,nearE.z-e.z);
        if(nearD>3){
          const nx=e.x+Math.sin(e.angle)*e.speed*dt;
          const nz=e.z+Math.cos(e.angle)*e.speed*dt;
          const col=collide(nx,nz,0.4);
          e.x=col.x;e.z=col.z;
          e.walkPhase+=dt*6;
        }
        e.shootTimer=(e.shootTimer||0)-dt;
        if(e.shootTimer<=0 && nearD<25 && lineOfSight(e.x,e.z,nearE.x,nearE.z)){
          nearE.hp-=25; nearE.flash=1;
          if(nearE.state!=='hurt') nearE._prevState=nearE.state;
          nearE.state='hurt'; nearE.hurtTimer=0.3;
          playSound('shoot');
          e.shootTimer=1.0+Math.random();
        }
      }
      continue;
    }

    e.flash*=Math.max(0,1-dt*8);
    e.voiceCd=Math.max(0,(e.voiceCd||0)-dt);

    const dx=player.x-e.x, dz=player.z-e.z;
    const dist=Math.sqrt(dx*dx+dz*dz);
    const canSee=dist<40 && lineOfSight(e.x,e.z,player.x,player.z);

    // Always smoothly rotate toward target angle
    const targetAngle=Math.atan2(dx,dz);
    switch(e.state){
      case 'idle':
        if(gameMode==='math'){
          // Math mode: wander randomly, never shoot. Freeze = stand still
          if(mathFreezeTimer<=0){
            e.angle+=(Math.sin(Date.now()*0.0005+e.x)*0.5)*dt;
            const mx=e.x+Math.sin(e.angle)*e.speed*dt;
            const mz=e.z+Math.cos(e.angle)*e.speed*dt;
            const mc=collide(mx,mz,0.4);
            e.x=mc.x;e.z=mc.z;
            e.walkPhase+=dt*5;
          }
        } else if(canSee){
          e.state='combat';
          e.angle=targetAngle;
          if(e.voiceCd<=0 && Math.random()<0.5){
            playVoice('I have to kill you idiot');
            e.voiceCd=8;
          }
        } else {
          // Slow idle rotation
          e.angle+=(Math.sin(Date.now()*0.0005+e.x)*0.5)*dt;
        }
        break;
      case 'combat':
        if(!canSee){
          e.alertTimer+=dt;
          // Still face last known player direction
          e.angle=targetAngle;
          if(e.alertTimer>5){e.state='idle';e.alertTimer=0;}
        } else {
          e.alertTimer=0;
          e.angle=targetAngle;
          // Boss: charge at player, melee + shoot
          if(e._isBoss){
            e._bossGlitchTimer=(e._bossGlitchTimer||0)+dt;
            // Always rush toward player fast
            const bspd=e.speed*(dist>5?1.5:0.8);
            const nx=e.x+Math.sin(e.angle)*bspd*dt;
            const nz=e.z+Math.cos(e.angle)*bspd*dt;
            const col=collide(nx,nz,0.6);
            e.x=col.x;e.z=col.z;
            e.walkPhase+=dt*10;
            // Melee damage on contact (high damage)
            if(dist<2.0){
              if(!e._meleeCd||e._meleeCd<=0){
                e._meleeCd=0.7;
                if(shieldActive&&shieldHP>0){shieldHP-=40;}
                else{player.hp-=30;spawnScreenBlood(4);screenShake=0.6;}
              }
            }
            if(e._meleeCd>0) e._meleeCd-=dt;
            // Also shoots
            e.shootTimer-=dt;
            if(e.shootTimer<=0 && dist<30){
              enemyShoot(e,dist);
              e.shootTimer=0.6+Math.random()*0.8;
            }
          }
          // Zombies: no shooting, just rush & melee
          else if(e._zombie){
            // Always rush toward player
            const nx=e.x+Math.sin(e.angle)*e.speed*dt;
            const nz=e.z+Math.cos(e.angle)*e.speed*dt;
            const col=collide(nx,nz,0.4);
            e.x=col.x;e.z=col.z;
            e.walkPhase+=dt*8;
            // Melee damage on contact
            if(dist<1.5){
              if(!e._meleeCd||e._meleeCd<=0){
                e._meleeCd=1.0;
                if(shieldActive&&shieldHP>0){shieldHP-=15;}
                else{player.hp-=15;spawnScreenBlood(2);screenShake=0.3;}
              }
            }
            if(e._meleeCd>0) e._meleeCd-=dt;
          } else {
          e.shootTimer-=dt;
          if(e.shootTimer<=0 && dist<35){
            enemyShoot(e,dist);
            e.shootTimer=1.2+Math.random()*1.5;
          }
          // Move toward player if far, strafe if close
          if(dist>8){
            const nx=e.x+Math.sin(e.angle)*e.speed*dt;
            const nz=e.z+Math.cos(e.angle)*e.speed*dt;
            const col=collide(nx,nz,0.4);
            e.x=col.x;e.z=col.z;
            e.walkPhase+=dt*8;
          } else {
            const sa=e.angle+Math.PI/2;
            const nx=e.x+Math.sin(sa)*e.speed*0.4*dt;
            const nz=e.z+Math.cos(sa)*e.speed*0.4*dt;
            const col=collide(nx,nz,0.4);
            e.x=col.x;e.z=col.z;
            e.walkPhase+=dt*5;
          }
          }
          // Random combat voice
          if(e.voiceCd<=0 && Math.random()<0.002){
            playVoice('I have to kill you idiot');
            e.voiceCd=10;
          }
        }
        break;
      case 'hurt':
        if(e._prevState!=='blinded'&&e._prevState!=='captured') e.angle=targetAngle;
        e.hurtTimer-=dt;
        if(e.hurtTimer<=0){
          if(e.hp>0){
            const prev=e._prevState||'combat';
            e.state=gameMode==='math'?'idle':(prev==='blinded'||prev==='captured')?prev:'combat';
            if(e.hp<40 && e.voiceCd<=0 && e.state==='combat'){
              playVoice(Math.random()<0.5?'Help me!':'Help me please!');
              e.voiceCd=6;
            }
          } else e.state='dead';
        }
        break;
      case 'blinded':
        // Random movement + random shooting (bag on head)
        e.angle+=(Math.random()-0.5)*4*dt;
        const bnx=e.x+Math.sin(e.angle)*e.speed*0.3*dt;
        const bnz=e.z+Math.cos(e.angle)*e.speed*0.3*dt;
        const bcol=collide(bnx,bnz,0.4);
        e.x=bcol.x; e.z=bcol.z;
        e.walkPhase+=dt*3;
        e.shootTimer-=dt;
        if(e.shootTimer<=0){
          blindedShoot(e);
          e.shootTimer=2+Math.random()*3;
        }
        break;
      case 'captured':
        // Follow player, positioned between player and nearest enemy
        {
          let nearestAngle=player.yaw;
          let nearDist=Infinity;
          for(const oe of enemies){
            if(oe===e||oe.hp<=0) continue;
            const odx=oe.x-player.x, odz=oe.z-player.z;
            const od=Math.sqrt(odx*odx+odz*odz);
            if(od<nearDist){ nearDist=od; nearestAngle=Math.atan2(odx,odz); }
          }
          const shieldDist=1.2;
          const tx=player.x+Math.sin(nearestAngle)*shieldDist;
          const tz=player.z+Math.cos(nearestAngle)*shieldDist;
          const ccol=collide(tx,tz,0.4);
          e.x=ccol.x; e.z=ccol.z;
          e.angle=nearestAngle+Math.PI; // face away from threat
        }
        break;
    }
  }
}

/* ============================================================
   ALLY AI
   ============================================================ */
function updateAllies(dt){
  for(const a of allies){
    if(a.hp<=0){
      a.state='dead';
      a.flash*=Math.max(0,1-dt*8);
      if(!a._ragdoll) a._ragdoll=createRagdoll(a, 0, -0.5, 0, RC);
      if(!a._ragdoll.sleeping) updateRagdoll(a._ragdoll, dt);
      a.x=a._ragdoll.particles[RS].x; a.z=a._ragdoll.particles[RS].z;
      if(!a._bloodPool){
        a._bloodPool={x:a.x,z:a.z,size:0.05,maxSize:0.35+Math.random()*0.2,age:0};
        bloodPools.push(a._bloodPool);
      }
      if(a._bloodPool.age<5){
        a._bloodPool.age+=dt;
        a._bloodPool.size=a._bloodPool.maxSize*Math.min(1,a._bloodPool.age/5);
        a._bloodPool.x=a.x; a._bloodPool.z=a.z;
      }
      continue;
    }
    a.flash*=Math.max(0,1-dt*8);
    a.healCd=Math.max(0,(a.healCd||0)-dt);
    a.shootTimer=Math.max(0,a.shootTimer-dt);

    // Repulsion: push away from other allies so they don't stack
    let repX=0, repZ=0;
    for(const a2 of allies){
      if(a2===a||a2.hp<=0) continue;
      const sx=a.x-a2.x, sz=a.z-a2.z;
      const sd=Math.sqrt(sx*sx+sz*sz);
      if(sd<1.8 && sd>0.01){
        const f=(1.8-sd)/sd*6;
        repX+=sx*f;repZ+=sz*f;
      }
    }
    a.x+=repX*dt;a.z+=repZ*dt;
    const repCol=collide(a.x,a.z,0.4);a.x=repCol.x;a.z=repCol.z;

    // Allies pick up money
    for(const m of moneyBags){
      if(!m.alive) continue;
      const mdx=a.x-m.x, mdz=a.z-m.z;
      if(mdx*mdx+mdz*mdz<4){m.alive=false;playSound('pickup');}
    }

    const pdx=player.x-a.x, pdz=player.z-a.z;
    const pDist=Math.sqrt(pdx*pdx+pdz*pdz);

    if(a.role==='dumb'){
      // Саида: random wandering, walks into walls, stands near enemies
      a._wanderTimer-=dt;
      if(a._wanderTimer<=0){
        a._wanderAngle=Math.random()*Math.PI*2;
        a._wanderTimer=2+Math.random()*4;
      }
      a.angle=a._wanderAngle;
      const nx=a.x+Math.sin(a.angle)*a.speed*dt;
      const nz=a.z+Math.cos(a.angle)*a.speed*dt;
      const col=collide(nx,nz,0.4);
      a.x=col.x;a.z=col.z;
      a.walkPhase+=dt*5;
      continue;
    }

    // Find nearest enemy (visible for shooting, any for chasing)
    let nearE=null, nearED=Infinity;
    let chaseE=null, chaseED=Infinity;
    for(const e of enemies){
      if(e.hp<=0 || e.state==='blinded' || e.state==='captured') continue;
      const edx=e.x-a.x, edz=e.z-a.z;
      const ed=Math.sqrt(edx*edx+edz*edz);
      if(ed<40 && ed<chaseED){chaseED=ed;chaseE=e;}
      if(ed<35 && ed<nearED && lineOfSight(a.x,a.z,e.x,e.z)){nearED=ed;nearE=e;}
    }

    if(a.role==='medic'){
      // Medics: heal first, then fight, then follow
      // Check for wounded allies (any damage at all)
      let wAlly=null, wD=Infinity;
      for(const a2 of allies){
        if(a2===a||a2.hp<=0||a2.hp>=a2.maxHp-1) continue;
        const d2=Math.sqrt((a2.x-a.x)**2+(a2.z-a.z)**2);
        if(d2<wD){wD=d2;wAlly=a2;}
      }
      // Check player — heal if ANY damage taken
      const mxHp=gameMode==='juggernaut'?500:(MAX_HP+armorBonus);
      const pNeedsHeal=player.hp<mxHp-1;
      // Prioritize player over allies
      if(pNeedsHeal && pDist<wD+5){wAlly=null;wD=pDist;}

      if(wAlly && wD<40){
        // Run to wounded ally and heal
        a.state='heal';
        const hdx=wAlly.x-a.x, hdz=wAlly.z-a.z;
        a.angle=Math.atan2(hdx,hdz);
        if(wD>1.8){
          const spd=a.speed*(wD>6?1.5:1);
          const nx=a.x+Math.sin(a.angle)*spd*dt;
          const nz=a.z+Math.cos(a.angle)*spd*dt;
          const col=collide(nx,nz,0.4);a.x=col.x;a.z=col.z;
          a.walkPhase+=dt*9;
        } else if(a.healCd<=0){
          wAlly.hp=Math.min(wAlly.maxHp,wAlly.hp+30);
          a.healCd=1.5;
        }
      } else if(pNeedsHeal && pDist<50){
        // Run to player and heal — top priority
        a.state='heal';
        a.angle=Math.atan2(pdx,pdz);
        if(pDist>1.8){
          const spd=a.speed*(pDist>6?1.6:1);
          const nx=a.x+Math.sin(a.angle)*spd*dt;
          const nz=a.z+Math.cos(a.angle)*spd*dt;
          const col=collide(nx,nz,0.4);a.x=col.x;a.z=col.z;
          a.walkPhase+=dt*10;
        } else if(a.healCd<=0){
          player.hp=Math.min(mxHp,player.hp+25);
          a.healCd=1.5;
        }
      } else if(nearE){
        // No one to heal — fight enemies!
        a.state='combat';
        a.angle=Math.atan2(nearE.x-a.x,nearE.z-a.z);
        if(a.shootTimer<=0 && nearED<30){
          allyShoot(a,nearE);a.shootTimer=1.5+Math.random()*1.5;
        }
        // Keep some distance (medics are cautious)
        if(nearED>12){
          const nx=a.x+Math.sin(a.angle)*a.speed*dt;
          const nz=a.z+Math.cos(a.angle)*a.speed*dt;
          const col=collide(nx,nz,0.4);a.x=col.x;a.z=col.z;
          a.walkPhase+=dt*8;
        }
      } else if(chaseE && chaseED<25){
        // Chase enemy even without LOS
        a.state='combat';
        a.angle=Math.atan2(chaseE.x-a.x,chaseE.z-a.z);
        const nx=a.x+Math.sin(a.angle)*a.speed*dt;
        const nz=a.z+Math.cos(a.angle)*a.speed*dt;
        const col=collide(nx,nz,0.4);a.x=col.x;a.z=col.z;
        a.walkPhase+=dt*8;
      } else {
        // Follow player closely / obey command
        a.state='follow';
        if(allyCommandMode==='hold'){/* stay put */}
        else if(allyCommandMode==='heal'&&player.hp<(MAX_HP+armorBonus)&&pDist<30){
          a.angle=Math.atan2(pdx,pdz);
          if(pDist>1.8){const nx=a.x+Math.sin(a.angle)*a.speed*dt;const nz=a.z+Math.cos(a.angle)*a.speed*dt;const col=collide(nx,nz,0.4);a.x=col.x;a.z=col.z;a.walkPhase+=dt*8;}
          else if(a.healCd<=0){player.hp=Math.min(MAX_HP+armorBonus,player.hp+20);a.healCd=2;}
        }
        else if(pDist>3){
          a.angle=Math.atan2(pdx,pdz);
          const spd=a.speed*(pDist>10?1.5:1);
          const nx=a.x+Math.sin(a.angle)*spd*dt;
          const nz=a.z+Math.cos(a.angle)*spd*dt;
          const col=collide(nx,nz,0.4);a.x=col.x;a.z=col.z;
          a.walkPhase+=dt*8;
        }
      }
    } else {
      // DEFENDER: aggressive, charges enemies, shoots fast
      if(nearE){
        a.state='combat';
        a.angle=Math.atan2(nearE.x-a.x,nearE.z-a.z);
        if(a.shootTimer<=0 && nearED<35){
          allyShoot(a,nearE);a.shootTimer=0.9+Math.random()*1.2;
        }
        // Charge toward enemy
        if(nearED>6){
          const nx=a.x+Math.sin(a.angle)*a.speed*1.2*dt;
          const nz=a.z+Math.cos(a.angle)*a.speed*1.2*dt;
          const col=collide(nx,nz,0.4);a.x=col.x;a.z=col.z;
          a.walkPhase+=dt*9;
        } else if(nearED<4){
          // Strafe at close range
          const sa=a.angle+Math.PI/2*(Math.sin(Date.now()*0.002+a.x)>0?1:-1);
          const nx=a.x+Math.sin(sa)*a.speed*0.5*dt;
          const nz=a.z+Math.cos(sa)*a.speed*0.5*dt;
          const col=collide(nx,nz,0.4);a.x=col.x;a.z=col.z;
          a.walkPhase+=dt*6;
        }
      } else if(chaseE && chaseED<30){
        // Chase enemy even without LOS — run toward them
        a.state='combat';
        a.angle=Math.atan2(chaseE.x-a.x,chaseE.z-a.z);
        const nx=a.x+Math.sin(a.angle)*a.speed*1.3*dt;
        const nz=a.z+Math.cos(a.angle)*a.speed*1.3*dt;
        const col=collide(nx,nz,0.4);a.x=col.x;a.z=col.z;
        a.walkPhase+=dt*9;
      } else {
        // Follow player / obey command
        a.state='follow';
        if(allyCommandMode==='hold'){/* stay put */}
        else if(allyCommandMode==='attack'){
          // Aggressively search for enemies
          if(chaseE){a.angle=Math.atan2(chaseE.x-a.x,chaseE.z-a.z);const nx=a.x+Math.sin(a.angle)*a.speed*1.3*dt;const nz=a.z+Math.cos(a.angle)*a.speed*1.3*dt;const col=collide(nx,nz,0.4);a.x=col.x;a.z=col.z;a.walkPhase+=dt*9;}
        }
        else if(pDist>3){
          a.angle=Math.atan2(pdx,pdz);
          const spd=a.speed*(pDist>10?1.5:1);
          const nx=a.x+Math.sin(a.angle)*spd*dt;
          const nz=a.z+Math.cos(a.angle)*spd*dt;
          const col=collide(nx,nz,0.4);a.x=col.x;a.z=col.z;
          a.walkPhase+=dt*8;
        }
      }
    }
  }
}

function allyShoot(a,target){
  if(target.state==='blinded'||target.state==='captured') return; // don't shoot prisoners
  const dx=target.x-a.x, dz=target.z-a.z;
  const dist=Math.sqrt(dx*dx+dz*dz);
  const accuracy=Math.max(0.3,1-dist/40);
  const hitChance=a.role==='defender'?0.55:0.4; // defenders more accurate
  if(Math.random()<accuracy*hitChance){
    const dmg=a.role==='defender'?25:18;
    target.hp-=dmg;
    if(target.state!=='hurt') target._prevState=target.state;
    target.state='hurt';target.hurtTimer=0.3;target.flash=1;
    if(goreEnabled) spawnParticles(target.x,1.3,target.z,'blood');
    if(target.hp<=0 && gameMode==='juggernaut') jugKills++;
  }
  spawnParticles(a.x,1.5,a.z,'muzzle');
  playSound('enemyShoot');
}

function enemyShoot(e,dist){
  const accuracy=Math.max(0.25, 1-dist/40);
  if(Math.random()<accuracy*0.6){
    // Shield check: captured enemy absorbs damage if between shooter and player
    if(capturedEnemy && capturedEnemy.hp>0){
      const cex=capturedEnemy.x-e.x, cez=capturedEnemy.z-e.z;
      const cpx=player.x-e.x, cpz=player.z-e.z;
      const ceDist=Math.sqrt(cex*cex+cez*cez);
      const cpDist=Math.sqrt(cpx*cpx+cpz*cpz);
      if(ceDist<cpDist+0.5){
        const dot=(cex*cpx+cez*cpz)/(ceDist*cpDist+0.001);
        if(dot>0.85){
          capturedEnemy.hp-=ENEMY_DMG; capturedEnemy.flash=1;
          if(goreEnabled) spawnParticles(capturedEnemy.x,1.3,capturedEnemy.z,'blood');
          if(capturedEnemy.hp<=0){ capturedEnemy.state='dead'; capturedEnemy=null; }
          spawnParticles(e.x,1.5,e.z,'muzzle');
          playSound('enemyShoot');
          return;
        }
      }
    }
    // Shield absorbs damage
    let edmg=ENEMY_DMG;
    const rawDmg=ENEMY_DMG;
    // Equipment damage reduction + wound application
    const hitRoll=Math.random();
    let hitZone='body';
    if(hitRoll<0.2){hitZone='head';if(hasEquipHelmet&&equipHelmet>0){edmg*=0.5;equipHelmet-=rawDmg;if(equipHelmet<=0)equipHelmet=0;}}
    else if(hitRoll<0.7){hitZone='body';if(hasEquipVest&&equipVest>0){edmg*=0.6;equipVest-=rawDmg*0.3;if(equipVest<=0)equipVest=0;}}
    else{hitZone='leg';if(hasEquipKnees&&equipKnees>0){edmg*=0.7;equipKnees-=rawDmg*0.2;if(equipKnees<=0)equipKnees=0;}}
    applyWound(hitZone);
    if(shieldActive&&shieldHP>0){
      shieldHP-=edmg;
      if(shieldHP<0){player.hp+=shieldHP;shieldHP=0;}
    } else {
      player.hp-=edmg;
    }
    bleeding=true;
    bleedTimer=3;
    spawnScreenBlood(3+Math.floor(Math.random()*4));
    screenShake=0.4;
    document.getElementById('bloodOverlay').style.opacity='0.5';
    setTimeout(()=>{if(state==='playing')document.getElementById('bloodOverlay').style.opacity=String(Math.max(0,(1-player.hp/(MAX_HP+armorBonus))*0.5));},200);
    // Helmet crack chance (15%) when armor is active
    if(armorBonus>0 && Math.random()<0.15){
      addHelmetCrack();
    }
  }
  // Stray bullets can hit nearby allies
  for(const a of allies){
    if(a.hp<=0) continue;
    const adx=a.x-e.x, adz=a.z-e.z;
    const aDist=Math.sqrt(adx*adx+adz*adz);
    if(aDist<6 && Math.random()<0.4){
      a.hp-=ENEMY_DMG;a.flash=1;
      if(goreEnabled) spawnParticles(a.x,1.3,a.z,'blood');
      if(a.hp<=0){
        const adx2=a.x-e.x, adz2=a.z-e.z;
        const aDist2=Math.sqrt(adx2*adx2+adz2*adz2)||1;
        a._ragdoll=createRagdoll(a, adx2/aDist2, 0, adz2/aDist2, RC);
      }
      break;
    }
  }
  spawnParticles(e.x,1.5,e.z,'muzzle');
  playSound('enemyShoot');
}

function blindedShoot(e){
  // Blinded enemy shoots in random direction — can hit other enemies but NOT player
  const rAngle=Math.random()*Math.PI*2;
  const rdx=Math.sin(rAngle), rdz=Math.cos(rAngle);
  // Check if random bullet hits any other enemy
  for(const other of enemies){
    if(other===e||other.hp<=0) continue;
    const ox=other.x-e.x, oz=other.z-e.z;
    const oDist=Math.sqrt(ox*ox+oz*oz);
    if(oDist>15||oDist<0.5) continue;
    // Dot product check: is other enemy roughly in the fire direction?
    const dot=(ox*rdx+oz*rdz)/oDist;
    if(dot>0.9){
      const perp=Math.abs(ox*rdz-oz*rdx)/oDist;
      if(perp<0.6){
        other.hp-=ENEMY_DMG; other.flash=1; other.state='hurt'; other.hurtTimer=0.3;
        if(goreEnabled) spawnParticles(other.x,1.3,other.z,'blood');
        break;
      }
    }
  }
  spawnParticles(e.x,1.5,e.z,'muzzle');
  playSound('enemyShoot');
}

function addHelmetCrack(){
  const hcc=document.getElementById('helmetCrackCanvas');
  if(!hcc) return;
  hcc.style.display='block';
  hcc.width=window.innerWidth;hcc.height=window.innerHeight;
  const cx=hcc.width*(0.3+Math.random()*0.4);
  const cy=hcc.height*(0.2+Math.random()*0.6);
  helmetCracks.push({x:cx,y:cy});
  drawHelmetCracks();
}

function drawHelmetCracks(){
  const hcc=document.getElementById('helmetCrackCanvas');
  if(!hcc||helmetCracks.length===0) return;
  const ctx=hcc.getContext('2d');
  ctx.clearRect(0,0,hcc.width,hcc.height);
  ctx.strokeStyle='rgba(200,220,255,0.6)';
  ctx.lineWidth=1.5;
  for(const crack of helmetCracks){
    const branches=4+Math.random()*4|0;
    for(let i=0;i<branches;i++){
      ctx.beginPath();
      ctx.moveTo(crack.x,crack.y);
      let px=crack.x,py=crack.y;
      const angle=Math.PI*2*i/branches+Math.random()*0.5;
      const len=30+Math.random()*60;
      const segs=3+Math.random()*3|0;
      for(let s=1;s<=segs;s++){
        const t=s/segs;
        px=crack.x+Math.cos(angle+Math.random()*0.6-0.3)*len*t;
        py=crack.y+Math.sin(angle+Math.random()*0.6-0.3)*len*t;
        ctx.lineTo(px,py);
      }
      ctx.stroke();
    }
    // Small impact circle
    ctx.beginPath();ctx.arc(crack.x,crack.y,3,0,Math.PI*2);ctx.stroke();
  }
}

/* ============================================================
   RENDER
   ============================================================ */
function drawWorld(vpMat){
  if(!worldProg) return;
  gl.useProgram(worldProg);
  gl.uniformMatrix4fv(worldU.uVP,false,vpMat);
  gl.uniform1f(worldU.uFog,gameMode==='boss'?20.0:gfxFogDist);
  gl.activeTexture(gl.TEXTURE0);
  gl.uniform1i(worldU.uTex,0);

  function drawVBO(vbo,tex){
    if(vbo.count===0)return;
    gl.bindTexture(gl.TEXTURE_2D,tex);
    gl.bindBuffer(gl.ARRAY_BUFFER,vbo.buf);
    gl.enableVertexAttribArray(worldAP);
    gl.enableVertexAttribArray(worldAU);
    gl.enableVertexAttribArray(worldAN);
    gl.vertexAttribPointer(worldAP,3,gl.FLOAT,false,32,0);
    gl.vertexAttribPointer(worldAU,2,gl.FLOAT,false,32,12);
    gl.vertexAttribPointer(worldAN,3,gl.FLOAT,false,32,20);
    gl.drawArrays(gl.TRIANGLES,0,vbo.count);
  }

  drawVBO(vboWall,texWall);
  drawVBO(vboFloor,texFloor);
  drawVBO(vboCeil,texCeil);
  drawVBO(vboCrate,texCrate);
  drawVBO(vboCar,texCar);
}

function drawEnemies(vpMat,viewMat){
  if(!entityProg) return;
  gl.useProgram(entityProg);
  gl.uniformMatrix4fv(entityU.uVP,false,vpMat);
  gl.uniform1f(entityU.uFog,gameMode==='boss'?20.0:gfxFogDist);
  gl.uniform1f(entityU.uAO,gfxShadows?1.0:0.0);
  gl.bindBuffer(gl.ARRAY_BUFFER,cubeVBO.buf);
  gl.enableVertexAttribArray(entityAP);
  gl.enableVertexAttribArray(entityAN);
  gl.vertexAttribPointer(entityAP,3,gl.FLOAT,false,24,0);
  gl.vertexAttribPointer(entityAN,3,gl.FLOAT,false,24,12);

  function box(m,sx,sy,sz,r,g,b){
    gl.uniformMatrix4fv(entityU.uM,false,mat4Mul(m,mat4S(sx,sy,sz)));
    gl.uniform3f(entityU.uCol,r,g,b);
    gl.drawArrays(gl.TRIANGLES,0,36);
  }

  for(const e of enemies){
    const isDead=e.hp<=0;
    // Boss glitch flash: rapidly cycle flash for strobing effect
    if(e._isBoss && !isDead){
      const gt=(e._bossGlitchTimer||0);
      gl.uniform1f(entityU.uFlash, Math.abs(Math.sin(gt*12))*0.4 + e.flash);
    } else {
      gl.uniform1f(entityU.uFlash,e.flash);
    }

    // Compute colors BEFORE dead check so ragdolls keep correct appearance
    if(e._camoIdx===undefined) e._camoIdx=Math.floor(Math.random()*CAMO_PALETTES.length);
    const cpal=enemyCamo?CAMO_PALETTES[e._camoIdx]:CAMO_PALETTES[0];
    const isZombie=!!e._zombie;
    let hCol,tCol,pCol,skinCol,skinCol2,slvCol;
    // Boss: all black with glitch color flashes
    if(e._isBoss){
      const gc=Math.sin((e._bossGlitchTimer||0)*8)*0.15;
      hCol=[.05+gc,.02,.08+gc]; tCol=[.06+gc,.03,.07+gc]; pCol=[.04,.02+gc,.06+gc];
      skinCol=[.08,.05,.12]; skinCol2=[.06,.04,.10]; slvCol=[.05,.03,.08];
    }
    // Skeleton enemies: white/bone colored
    else if(e._skeleton){
      hCol=[.85,.80,.70]; tCol=[.80,.75,.65]; pCol=[.75,.70,.60];
      skinCol=[.90,.85,.75]; skinCol2=[.85,.80,.70]; slvCol=[.80,.75,.65];
    }
    // Glitched allies: purple/cyan
    else if(e._glitched){
      const gc2=Math.sin(Date.now()*0.008)*0.1;
      hCol=[.3+gc2,.1,.5]; tCol=[.2,.3+gc2,.5]; pCol=[.15,.2+gc2,.45];
      skinCol=[.5,.3,.7]; skinCol2=[.4,.25,.6]; slvCol=[.2,.3,.5];
    }
    else if(isZombie){
      hCol=[.15,.18,.12]; tCol=[.18,.22,.15]; pCol=[.14,.16,.12];
      skinCol=[.35,.45,.25]; skinCol2=[.30,.40,.22]; slvCol=[.18,.22,.15];
    } else {
      hCol=cpal.helm; tCol=cpal.torso; pCol=cpal.pants;
      skinCol=[.78,.62,.48]; skinCol2=[.72,.56,.42]; slvCol=[.27,.40,.33];
    }

    if(isDead){
      if(!e._ragdoll) continue;
      const rag = e._ragdoll;
      // HEAD
      if(!rag.headGone){
        box(boneMat(rag, RH, RN), 0.21,1.0,0.20, skinCol[0],skinCol[1],skinCol[2]);
        box(particleMat(rag, RH), 0.28,0.14,0.28, hCol[0],hCol[1],hCol[2]);
      } else {
        box(particleMat(rag, RN), 0.10,0.06,0.10, .50,.05,.05);
      }
      // Zombie: wound on head ragdoll
      if(isZombie && !rag.headGone){
        box(particleMat(rag, RH), 0.04,0.06,0.04, .4,.08,.05);
      }
      // NECK
      box(boneMat(rag, RN, RC), 0.08,1.0,0.08, skinCol2[0],skinCol2[1],skinCol2[2]);
      // TORSO
      box(boneMat(rag, RC, RS), 0.38,1.0,0.22, tCol[0],tCol[1],tCol[2]);
      // Zombie: wounds on torso ragdoll
      if(isZombie){
        box(boneMat(rag, RC, RS), 0.08,0.12,0.02, .45,.10,.08);
      }
      // LEFT ARM or stump
      if(!rag.armLGone){
        box(boneMat(rag, RC, RSL), 0.10,1.0,0.10, tCol[0],tCol[1],tCol[2]);
        box(boneMat(rag, RSL, REL), 0.10,1.0,0.10, slvCol[0],slvCol[1],slvCol[2]);
        box(boneMat(rag, REL, RHL), 0.09,1.0,0.09, slvCol[0],slvCol[1],slvCol[2]);
        box(particleMat(rag, RHL), 0.07,0.06,0.08, skinCol[0],skinCol[1],skinCol[2]);
      } else {
        box(particleMat(rag, RSL), 0.08,0.06,0.08, .50,.05,.05);
      }
      // RIGHT ARM or stump
      if(!rag.armRGone){
        box(boneMat(rag, RC, RSR), 0.10,1.0,0.10, tCol[0],tCol[1],tCol[2]);
        box(boneMat(rag, RSR, RER), 0.10,1.0,0.10, slvCol[0],slvCol[1],slvCol[2]);
        box(boneMat(rag, RER, RHR), 0.09,1.0,0.09, slvCol[0],slvCol[1],slvCol[2]);
        box(particleMat(rag, RHR), 0.07,0.06,0.08, skinCol[0],skinCol[1],skinCol[2]);
      } else {
        box(particleMat(rag, RSR), 0.08,0.06,0.08, .50,.05,.05);
      }
      // LEFT LEG or stump
      if(!rag.legLGone){
        box(boneMat(rag, RS, RKL), 0.14,1.0,0.14, pCol[0],pCol[1],pCol[2]);
        box(boneMat(rag, RKL, RFL), 0.13,1.0,0.13, pCol[0],pCol[1],pCol[2]);
        box(particleMat(rag, RFL), 0.16,0.14,0.20, .13,.13,.13);
      } else {
        box(particleMat(rag, RKL), 0.10,0.06,0.10, .50,.05,.05);
      }
      // RIGHT LEG or stump
      if(!rag.legRGone){
        box(boneMat(rag, RS, RKR), 0.14,1.0,0.14, pCol[0],pCol[1],pCol[2]);
        box(boneMat(rag, RKR, RFR), 0.13,1.0,0.13, pCol[0],pCol[1],pCol[2]);
        box(particleMat(rag, RFR), 0.16,0.14,0.20, .13,.13,.13);
      } else {
        box(particleMat(rag, RKR), 0.10,0.06,0.10, .50,.05,.05);
      }
      // Belt at spine
      box(particleMat(rag, RS), 0.28,0.08,0.18, isZombie?.25:.67,isZombie?.15:.20,isZombie?.12:.20);
      // Dropped rifle (not for zombies — they have no weapons)
      if(!isZombie){
        const wpD=mat4Mul(mat4T(rag.rifleX,0.05,rag.rifleZ),mat4Mul(mat4RY(-rag.rifleAngle-0.3),mat4RX(Math.PI/2)));
        box(mat4Mul(wpD,mat4T(0,0,0)), .030,.030,.50, .22,.22,.22);
        box(mat4Mul(wpD,mat4T(0,0,.14)), .035,.038,.12, .25,.25,.25);
        box(mat4Mul(wpD,mat4T(0,-.05,0)), .022,.07,.030, .15,.15,.15);
      }
      continue;
    }

    const wk=e.walkPhase||0;
    const inCombat=(e.state==='combat'||e.state==='hurt');
    const isBagged=(e.state==='blinded'||e.state==='captured');
    // hCol, tCol, pCol, skinCol, skinCol2, slvCol, isZombie, cpal already computed above
    let bM=mat4Mul(mat4T(e.x,0,e.z),mat4RY(-e.angle));
    // Boss: 1.5x scale
    if(e._isBoss) bM=mat4Mul(bM,mat4S(1.5,1.5,1.5));
    // Leg swing for walking
    const lL=Math.sin(wk)*0.55, lR=-Math.sin(wk)*0.55;

    if(isZombie){
      // ===== ZOMBIE HEAD (no helmet, bald, wounds) =====
      // Bald head
      box(mat4Mul(bM,mat4T(0,1.78,0)), 0.22,0.16,0.22, skinCol[0]-.05,skinCol[1]-.05,skinCol[2]);
      // Face
      box(mat4Mul(bM,mat4T(0,1.66,0)), 0.21,0.20,0.20, skinCol[0],skinCol[1],skinCol[2]);
      box(mat4Mul(bM,mat4T(0,1.67,.09)), 0.16,0.14,0.04, skinCol[0],skinCol[1],skinCol[2]);
      // Glowing red/yellow eyes
      box(mat4Mul(bM,mat4T(-0.05,1.70,.11)), 0.045,0.03,0.01, .8,.2,.1);
      box(mat4Mul(bM,mat4T(-0.05,1.70,.115)), 0.025,0.025,0.005, 1,.3,.0);
      box(mat4Mul(bM,mat4T(0.05,1.70,.11)), 0.045,0.03,0.01, .8,.2,.1);
      box(mat4Mul(bM,mat4T(0.05,1.70,.115)), 0.025,0.025,0.005, 1,.3,.0);
      // Open jaw/mouth
      box(mat4Mul(bM,mat4T(0,1.61,.10)), 0.08,0.03,0.03, .15,.05,.05);
      // Wound on head
      box(mat4Mul(bM,mat4T(.08,1.75,.05)), 0.04,0.06,0.04, .4,.08,.05);
    } else {
    // ===== HELMET =====
    box(mat4Mul(bM,mat4T(0,1.82,0)), 0.28,0.14,0.28, hCol[0],hCol[1],hCol[2]);
    box(mat4Mul(bM,mat4T(0,1.76,.13)), 0.26,0.04,0.06, hCol[0]-.02,hCol[1]-.03,hCol[2]-.02);
    box(mat4Mul(bM,mat4T(0,1.74,.14)), 0.22,0.03,0.02, .10,.10,.10);
    if(isBagged){
      // Brown bag over head
      box(mat4Mul(bM,mat4T(0,1.72,0)), 0.26,0.26,0.26, .45,.30,.15);
      box(mat4Mul(bM,mat4T(0,1.58,0)), 0.24,0.04,0.24, .40,.27,.12);
    } else {
      // HEAD / FACE
      box(mat4Mul(bM,mat4T(0,1.66,0)), 0.21,0.20,0.20, skinCol[0],skinCol[1],skinCol[2]);
      box(mat4Mul(bM,mat4T(0,1.67,.09)), 0.16,0.14,0.04, skinCol[0],skinCol[1],skinCol[2]);
      // EYES
      box(mat4Mul(bM,mat4T(-0.05,1.70,.11)), 0.045,0.03,0.01, 1,1,1);
      box(mat4Mul(bM,mat4T(-0.05,1.70,.115)), 0.02,0.02,0.005, .10,.10,.10);
      box(mat4Mul(bM,mat4T(0.05,1.70,.11)), 0.045,0.03,0.01, 1,1,1);
      box(mat4Mul(bM,mat4T(0.05,1.70,.115)), 0.02,0.02,0.005, .10,.10,.10);
    }
    }
    // NECK
    box(mat4Mul(bM,mat4T(0,1.52,0)), 0.08,0.08,0.08, skinCol2[0],skinCol2[1],skinCol2[2]);
    // TORSO
    box(mat4Mul(bM,mat4T(0,1.30,0)), 0.42,0.32,0.24, tCol[0],tCol[1],tCol[2]);
    box(mat4Mul(bM,mat4T(0,1.00,0)), 0.32,0.28,0.20, tCol[0],tCol[1],tCol[2]);
    // Zombie: exposed ribs wound on torso
    if(isZombie){
      box(mat4Mul(bM,mat4T(.12,1.15,.12)), 0.08,0.12,0.02, .45,.10,.08);
      box(mat4Mul(bM,mat4T(-.10,1.05,.11)), 0.06,0.08,0.02, .50,.12,.08);
    }
    box(mat4Mul(bM,mat4T(0,0.84,0)), 0.28,0.08,0.18, isZombie?.25:.67,isZombie?.15:.20,isZombie?.12:.20);
    box(mat4Mul(bM,mat4T(0,0.88,0)), 0.34,0.04,0.22, .20,.18,.12);
    if(!isZombie) box(mat4Mul(bM,mat4T(0,0.88,.10)), 0.05,0.035,0.02, .55,.50,.30);

    // slvCol already computed above
    if(e.state==='captured'){
      // ===== CAPTURED POSE =====
      const laC=mat4Mul(bM,mat4Mul(mat4T(-0.22,1.30,0),mat4RX(0.8)));
      box(mat4Mul(laC,mat4T(0,-0.19,0)), 0.10,0.34,0.10, slvCol[0],slvCol[1],slvCol[2]);
      box(mat4Mul(laC,mat4T(0,-0.38,0)), 0.07,0.06,0.08, skinCol[0],skinCol[1],skinCol[2]);
      const raC=mat4Mul(bM,mat4Mul(mat4T(0.22,1.30,0),mat4RX(0.8)));
      box(mat4Mul(raC,mat4T(0,-0.19,0)), 0.10,0.34,0.10, slvCol[0],slvCol[1],slvCol[2]);
      box(mat4Mul(raC,mat4T(0,-0.38,0)), 0.07,0.06,0.08, skinCol[0],skinCol[1],skinCol[2]);
      box(mat4Mul(bM,mat4T(0,0.96,-.14)), 0.14,0.04,0.04, .15,.15,.18);
      box(mat4Mul(bM,mat4T(-0.08,0.96,-.14)), 0.03,0.05,0.05, .12,.12,.15);
      box(mat4Mul(bM,mat4T(0.08,0.96,-.14)), 0.03,0.05,0.05, .12,.12,.15);
    } else if(inCombat || e.state==='blinded'){
      if(inCombat && !isZombie){
        // ===== COMBAT POSE: both arms hold rifle =====
        const rShM=mat4Mul(bM,mat4T(0.22,1.38,0));
        box(mat4Mul(rShM,mat4Mul(mat4RX(-1.2),mat4T(0,-0.19,0))), 0.10,0.34,0.10, slvCol[0],slvCol[1],slvCol[2]);
        box(mat4Mul(rShM,mat4Mul(mat4RX(-1.2),mat4T(0,-0.38,0))), 0.07,0.06,0.08, skinCol[0],skinCol[1],skinCol[2]);
        const lShM=mat4Mul(bM,mat4T(-0.22,1.38,0));
        box(mat4Mul(lShM,mat4Mul(mat4RX(-1.35),mat4T(0,-0.19,0.04))), 0.10,0.34,0.10, slvCol[0],slvCol[1],slvCol[2]);
        box(mat4Mul(lShM,mat4Mul(mat4RX(-1.35),mat4T(0,-0.38,0.06))), 0.07,0.06,0.08, skinCol[0],skinCol[1],skinCol[2]);
      } else if(isZombie){
        // ===== ZOMBIE ATTACK POSE: arms reaching forward =====
        const zAL=Math.sin(wk*2+0.5)*0.4-0.8;
        const zAR=Math.sin(wk*2)*0.4-0.8;
        const armLZ=mat4Mul(bM,mat4Mul(mat4T(-0.24,1.38,0),mat4Mul(mat4RX(zAL),mat4T(0,-0.19,0))));
        box(armLZ, 0.10,0.34,0.10, skinCol[0],skinCol[1],skinCol[2]);
        box(mat4Mul(bM,mat4Mul(mat4T(-0.24,1.38,0),mat4Mul(mat4RX(zAL),mat4T(0,-0.39,0)))), 0.08,0.07,0.09, skinCol[0]-.05,skinCol[1]-.05,skinCol[2]-.03);
        const armRZ=mat4Mul(bM,mat4Mul(mat4T(0.24,1.38,0),mat4Mul(mat4RX(zAR),mat4T(0,-0.19,0))));
        box(armRZ, 0.10,0.34,0.10, skinCol[0],skinCol[1],skinCol[2]);
        box(mat4Mul(bM,mat4Mul(mat4T(0.24,1.38,0),mat4Mul(mat4RX(zAR),mat4T(0,-0.39,0)))), 0.08,0.07,0.09, skinCol[0]-.05,skinCol[1]-.05,skinCol[2]-.03);
      } else {
        // ===== BLINDED: arms flailing =====
        const bAL=Math.sin(wk*1.5+1)*0.6, bAR=-Math.sin(wk*1.5)*0.6;
        const armLB=mat4Mul(bM,mat4Mul(mat4T(-0.24,1.38,0),mat4Mul(mat4RX(bAL),mat4T(0,-0.19,0))));
        box(armLB, 0.10,0.34,0.10, slvCol[0],slvCol[1],slvCol[2]);
        box(mat4Mul(bM,mat4Mul(mat4T(-0.24,1.38,0),mat4Mul(mat4RX(bAL),mat4T(0,-0.39,0)))), 0.07,0.06,0.08, skinCol[0],skinCol[1],skinCol[2]);
        const armRB=mat4Mul(bM,mat4Mul(mat4T(0.24,1.38,0),mat4Mul(mat4RX(bAR),mat4T(0,-0.19,0))));
        box(armRB, 0.10,0.34,0.10, slvCol[0],slvCol[1],slvCol[2]);
        box(mat4Mul(bM,mat4Mul(mat4T(0.24,1.38,0),mat4Mul(mat4RX(bAR),mat4T(0,-0.39,0)))), 0.07,0.06,0.08, skinCol[0],skinCol[1],skinCol[2]);
      }
      // ===== RIFLE (not for zombies) =====
      if(!isZombie){
        const wpM=mat4Mul(bM,mat4T(0.06,1.20,0.20));
        box(mat4Mul(wpM,mat4T(0,0,.22)), .020,.020,.30, .25,.25,.25);
        box(mat4Mul(wpM,mat4T(0,0,.38)), .026,.026,.04, .18,.18,.18);
        box(mat4Mul(wpM,mat4T(0,0,.08)), .035,.038,.16, .28,.28,.28);
        box(mat4Mul(wpM,mat4T(0,.003,-.10)), .032,.044,.24, .22,.22,.22);
        box(mat4Mul(wpM,mat4T(0,.030,-.02)), .016,.008,.22, .30,.30,.30);
        box(mat4Mul(wpM,mat4T(0,-.065,-.08)), .025,.085,.034, .15,.15,.15);
        box(mat4Mul(wpM,mat4Mul(mat4T(0,-.04,-.18),mat4RX(.22))), .022,.065,.028, .30,.22,.14);
        box(mat4Mul(wpM,mat4T(0,0,-.26)), .015,.015,.10, .25,.25,.25);
        box(mat4Mul(wpM,mat4T(0,-.004,-.32)), .026,.040,.06, .30,.22,.14);
      }
    } else {
      // ===== IDLE POSE: arms swinging =====
      const aL=-Math.sin(wk)*0.45, aR=Math.sin(wk)*0.45;
      const armLM=mat4Mul(bM,mat4Mul(mat4T(-0.24,1.38,0),mat4Mul(mat4RX(aL),mat4T(0,-0.19,0))));
      box(armLM, 0.10,0.34,0.10, slvCol[0],slvCol[1],slvCol[2]);
      box(mat4Mul(bM,mat4Mul(mat4T(-0.24,1.38,0),mat4Mul(mat4RX(aL),mat4T(0,-0.39,0)))), 0.07,0.06,0.08, skinCol[0],skinCol[1],skinCol[2]);
      const armRM=mat4Mul(bM,mat4Mul(mat4T(0.24,1.38,0),mat4Mul(mat4RX(aR),mat4T(0,-0.19,0))));
      box(armRM, 0.10,0.34,0.10, slvCol[0],slvCol[1],slvCol[2]);
      box(mat4Mul(bM,mat4Mul(mat4T(0.24,1.38,0),mat4Mul(mat4RX(aR),mat4T(0,-0.39,0)))), 0.07,0.06,0.08, skinCol[0],skinCol[1],skinCol[2]);
      // Rifle lowered (not for zombies)
      if(!isZombie){
        const rwM=mat4Mul(bM,mat4Mul(mat4T(0.24,1.38,0),mat4RX(aR)));
        box(mat4Mul(rwM,mat4T(0.06,-0.20,0)), .025,.025,.40, .22,.22,.22);
        box(mat4Mul(rwM,mat4T(0.06,-0.20,.12)), .032,.032,.10, .25,.25,.25);
        box(mat4Mul(rwM,mat4T(0.06,-0.20,-.12)), .028,.035,.08, .22,.22,.22);
        box(mat4Mul(rwM,mat4T(0.06,-.24,-.06)), .020,.06,.026, .15,.15,.15);
      }
    }

    // LEGS (always swing)
    const llM=mat4Mul(bM,mat4Mul(mat4T(-0.10,0.82,0),mat4RX(lL)));
    box(mat4Mul(llM,mat4T(0,-0.24,0)), 0.14,0.48,0.14, pCol[0],pCol[1],pCol[2]);
    box(mat4Mul(llM,mat4T(0,-0.53,.01)), 0.16,0.14,0.20, .13,.13,.13);
    const rlM=mat4Mul(bM,mat4Mul(mat4T(0.10,0.82,0),mat4RX(lR)));
    box(mat4Mul(rlM,mat4T(0,-0.24,0)), 0.14,0.48,0.14, pCol[0],pCol[1],pCol[2]);
    box(mat4Mul(rlM,mat4T(0,-0.53,.01)), 0.16,0.14,0.20, .13,.13,.13);
  }

  // ===== DRAW ALLIES (same entity shader, different colors) =====
  for(const a of allies){
    const isDead=a.hp<=0;
    gl.uniform1f(entityU.uFlash,a.flash);
    // Colors by role
    const hR=a.role==='medic'?[.20,.30,.60]:a.role==='dumb'?[.70,.35,.50]:[.25,.40,.25]; // helmet
    const tR=a.role==='medic'?[.25,.35,.55]:a.role==='dumb'?[.55,.40,.50]:[.30,.38,.28]; // torso

    if(isDead){
      if(!a._ragdoll) continue;
      const rag = a._ragdoll;
      // HEAD
      if(!rag.headGone){
        box(boneMat(rag, RH, RN), 0.21,1.0,0.20, .78,.62,.48);
        box(particleMat(rag, RH), 0.28,0.14,0.28, hR[0],hR[1],hR[2]);
      } else {
        box(particleMat(rag, RN), 0.10,0.06,0.10, .50,.05,.05);
      }
      // NECK
      box(boneMat(rag, RN, RC), 0.08,1.0,0.08, .72,.56,.42);
      // TORSO
      box(boneMat(rag, RC, RS), 0.38,1.0,0.22, tR[0],tR[1],tR[2]);
      // LEFT ARM or stump
      if(!rag.armLGone){
        box(boneMat(rag, RC, RSL), 0.10,1.0,0.10, tR[0],tR[1],tR[2]);
        box(boneMat(rag, RSL, REL), 0.10,1.0,0.10, tR[0],tR[1],tR[2]);
        box(boneMat(rag, REL, RHL), 0.09,1.0,0.09, tR[0],tR[1],tR[2]);
        box(particleMat(rag, RHL), 0.07,0.06,0.08, .78,.62,.48);
      } else {
        box(particleMat(rag, RSL), 0.08,0.06,0.08, .50,.05,.05);
      }
      // RIGHT ARM or stump
      if(!rag.armRGone){
        box(boneMat(rag, RC, RSR), 0.10,1.0,0.10, tR[0],tR[1],tR[2]);
        box(boneMat(rag, RSR, RER), 0.10,1.0,0.10, tR[0],tR[1],tR[2]);
        box(boneMat(rag, RER, RHR), 0.09,1.0,0.09, tR[0],tR[1],tR[2]);
        box(particleMat(rag, RHR), 0.07,0.06,0.08, .78,.62,.48);
      } else {
        box(particleMat(rag, RSR), 0.08,0.06,0.08, .50,.05,.05);
      }
      // LEFT LEG or stump
      if(!rag.legLGone){
        box(boneMat(rag, RS, RKL), 0.14,1.0,0.14, .21,.27,.21);
        box(boneMat(rag, RKL, RFL), 0.13,1.0,0.13, .21,.27,.21);
        box(particleMat(rag, RFL), 0.16,0.14,0.20, .13,.13,.13);
      } else {
        box(particleMat(rag, RKL), 0.10,0.06,0.10, .50,.05,.05);
      }
      // RIGHT LEG or stump
      if(!rag.legRGone){
        box(boneMat(rag, RS, RKR), 0.14,1.0,0.14, .21,.27,.21);
        box(boneMat(rag, RKR, RFR), 0.13,1.0,0.13, .21,.27,.21);
        box(particleMat(rag, RFR), 0.16,0.14,0.20, .13,.13,.13);
      } else {
        box(particleMat(rag, RKR), 0.10,0.06,0.10, .50,.05,.05);
      }
      // Belt at spine
      box(particleMat(rag, RS), 0.28,0.08,0.18, .67,.20,.20);
      continue;
    }

    const wk=a.walkPhase||0;
    const inCombat=(a.state==='combat');
    let bM=mat4Mul(mat4T(a.x,0,a.z),mat4RY(-a.angle));
    const lL=Math.sin(wk)*0.55, lR=-Math.sin(wk)*0.55;
    // Helmet
    box(mat4Mul(bM,mat4T(0,1.82,0)),.28,.14,.28,hR[0],hR[1],hR[2]);
    // Medic cross on helmet
    if(a.role==='medic'){
      box(mat4Mul(bM,mat4T(0,1.88,.13)),.02,.06,.01,1,1,1);
      box(mat4Mul(bM,mat4T(0,1.88,.13)),.06,.02,.01,1,1,1);
    }
    // Head
    box(mat4Mul(bM,mat4T(0,1.66,0)),.21,.20,.20,.78,.62,.48);
    box(mat4Mul(bM,mat4T(0,1.67,.09)),.16,.14,.04,.78,.62,.48);
    // Eyes
    box(mat4Mul(bM,mat4T(-0.05,1.70,.11)),.045,.03,.01,1,1,1);
    box(mat4Mul(bM,mat4T(-0.05,1.70,.115)),.02,.02,.005,.10,.10,.10);
    box(mat4Mul(bM,mat4T(0.05,1.70,.11)),.045,.03,.01,1,1,1);
    box(mat4Mul(bM,mat4T(0.05,1.70,.115)),.02,.02,.005,.10,.10,.10);
    // Neck
    box(mat4Mul(bM,mat4T(0,1.52,0)),.08,.08,.08,.72,.56,.42);
    // Torso
    box(mat4Mul(bM,mat4T(0,1.30,0)),.42,.32,.24,tR[0],tR[1],tR[2]);
    box(mat4Mul(bM,mat4T(0,1.00,0)),.32,.28,.20,tR[0],tR[1],tR[2]);
    // Medic red cross on chest
    if(a.role==='medic'){
      box(mat4Mul(bM,mat4T(0,1.30,.13)),.03,.10,.01,.9,.1,.1);
      box(mat4Mul(bM,mat4T(0,1.30,.13)),.10,.03,.01,.9,.1,.1);
    }
    // Belt
    box(mat4Mul(bM,mat4T(0,0.88,0)),.34,.04,.22,.20,.18,.12);

    if(inCombat){
      // Arms forward holding weapon
      const rShM=mat4Mul(bM,mat4T(0.22,1.38,0));
      box(mat4Mul(rShM,mat4Mul(mat4RX(-1.2),mat4T(0,-0.19,0))),.10,.34,.10,tR[0],tR[1],tR[2]);
      box(mat4Mul(rShM,mat4Mul(mat4RX(-1.2),mat4T(0,-0.38,0))),.07,.06,.08,.78,.62,.48);
      const lShM=mat4Mul(bM,mat4T(-0.22,1.38,0));
      box(mat4Mul(lShM,mat4Mul(mat4RX(-1.35),mat4T(0,-0.19,0.04))),.10,.34,.10,tR[0],tR[1],tR[2]);
      box(mat4Mul(lShM,mat4Mul(mat4RX(-1.35),mat4T(0,-0.38,0.06))),.07,.06,.08,.78,.62,.48);
      // Rifle
      const wpM=mat4Mul(bM,mat4T(0.06,1.20,0.20));
      box(mat4Mul(wpM,mat4T(0,0,.22)),.020,.020,.30,.25,.25,.25);
      box(mat4Mul(wpM,mat4T(0,0,.08)),.035,.038,.16,.28,.28,.28);
      box(mat4Mul(wpM,mat4T(0,.003,-.10)),.032,.044,.24,.22,.22,.22);
      box(mat4Mul(wpM,mat4T(0,-.065,-.08)),.025,.085,.034,.15,.15,.15);
    } else {
      // Idle arms swinging
      const aL=-Math.sin(wk)*0.45, aR=Math.sin(wk)*0.45;
      const armLM=mat4Mul(bM,mat4Mul(mat4T(-0.24,1.38,0),mat4Mul(mat4RX(aL),mat4T(0,-0.19,0))));
      box(armLM,.10,.34,.10,tR[0],tR[1],tR[2]);
      box(mat4Mul(bM,mat4Mul(mat4T(-0.24,1.38,0),mat4Mul(mat4RX(aL),mat4T(0,-0.39,0)))),.07,.06,.08,.78,.62,.48);
      const armRM=mat4Mul(bM,mat4Mul(mat4T(0.24,1.38,0),mat4Mul(mat4RX(aR),mat4T(0,-0.19,0))));
      box(armRM,.10,.34,.10,tR[0],tR[1],tR[2]);
      box(mat4Mul(bM,mat4Mul(mat4T(0.24,1.38,0),mat4Mul(mat4RX(aR),mat4T(0,-0.39,0)))),.07,.06,.08,.78,.62,.48);
    }
    // Legs
    const llM=mat4Mul(bM,mat4Mul(mat4T(-0.10,0.82,0),mat4RX(lL)));
    box(mat4Mul(llM,mat4T(0,-0.24,0)),.14,.48,.14,.21,.27,.21);
    box(mat4Mul(llM,mat4T(0,-0.53,.01)),.16,.14,.20,.13,.13,.13);
    const rlM=mat4Mul(bM,mat4Mul(mat4T(0.10,0.82,0),mat4RX(lR)));
    box(mat4Mul(rlM,mat4T(0,-0.24,0)),.14,.48,.14,.21,.27,.21);
    box(mat4Mul(rlM,mat4T(0,-0.53,.01)),.16,.14,.20,.13,.13,.13);
  }

  // Money bags as billboards
  if(!billProg) return;
  resetAttribs();
  gl.useProgram(billProg);
  gl.uniformMatrix4fv(billU.uVP,false,vpMat);
  gl.uniform3f(billU.uRight,viewMat[0],viewMat[4],viewMat[8]);
  gl.uniform3f(billU.uUp,0,1,0);
  gl.activeTexture(gl.TEXTURE0);
  gl.uniform1i(billU.uTex,0);
  gl.bindBuffer(gl.ARRAY_BUFFER,billQuad);
  gl.enableVertexAttribArray(billAP);
  gl.enableVertexAttribArray(billAU);
  gl.vertexAttribPointer(billAP,2,gl.FLOAT,false,16,0);
  gl.vertexAttribPointer(billAU,2,gl.FLOAT,false,16,8);
  for(const m of moneyBags){
    if(!m.alive) continue;
    gl.bindTexture(gl.TEXTURE_2D,texCar);
    gl.uniform3f(billU.uPos,m.x,0,m.z);
    gl.uniform2f(billU.uSize,0.6,0.6);
    gl.uniform1f(billU.uFlash,0);
    gl.drawArrays(gl.TRIANGLES,0,6);
  }
}

function drawParticles(vpMat){
  if(particles.length===0 || !partProg) return;
  gl.useProgram(partProg);
  gl.uniformMatrix4fv(partU.uVP,false,vpMat);

  let idx=0;
  for(const p of particles){
    if(idx>=MAX_PARTS*8) break;
    partData[idx++]=p.x;partData[idx++]=p.y;partData[idx++]=p.z;
    partData[idx++]=p.r;partData[idx++]=p.g;partData[idx++]=p.b;partData[idx++]=p.a;
    partData[idx++]=p.size*gfxParticleSize;
  }

  gl.bindBuffer(gl.ARRAY_BUFFER,partBuf);
  gl.bufferData(gl.ARRAY_BUFFER,partData,gl.DYNAMIC_DRAW);

  gl.enableVertexAttribArray(partAP);
  gl.enableVertexAttribArray(partAC);
  gl.enableVertexAttribArray(partAS);
  gl.vertexAttribPointer(partAP,3,gl.FLOAT,false,32,0);
  gl.vertexAttribPointer(partAC,4,gl.FLOAT,false,32,12);
  gl.vertexAttribPointer(partAS,1,gl.FLOAT,false,32,28);

  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA,gl.ONE);
  gl.depthMask(false);
  gl.drawArrays(gl.POINTS,0,Math.min(particles.length,MAX_PARTS));
  gl.depthMask(true);
  gl.disable(gl.BLEND);
}

function resetAttribs(){
  for(let i=0;i<4;i++) gl.disableVertexAttribArray(i);
}

let minigunSpin=0; // minigun barrel rotation accumulator

function drawWeapon3D(vpMat){
  if(!entityProg||player.ads) return; // hide weapon when looking through scope
  gl.clear(gl.DEPTH_BUFFER_BIT); // weapon always renders on top
  gl.useProgram(entityProg);
  gl.uniformMatrix4fv(entityU.uVP,false,vpMat);
  gl.uniform1f(entityU.uFog,gameMode==='boss'?20.0:gfxFogDist);
  gl.uniform1f(entityU.uAO,gfxShadows?1.0:0.0);
  gl.bindBuffer(gl.ARRAY_BUFFER,cubeVBO.buf);
  gl.enableVertexAttribArray(entityAP);
  gl.enableVertexAttribArray(entityAN);
  gl.vertexAttribPointer(entityAP,3,gl.FLOAT,false,24,0);
  gl.vertexAttribPointer(entityAN,3,gl.FLOAT,false,24,12);
  gl.uniform1f(entityU.uFlash,0);

  function box(m,sx,sy,sz,r,g,b){
    gl.uniformMatrix4fv(entityU.uM,false,mat4Mul(m,mat4S(sx,sy,sz)));
    // Gold skin: remap gray weapon parts to gold tones (skip skin/clothing)
    if(goldSkin && r<0.5 && g<0.5 && b<0.5 && Math.abs(r-g)<0.15 && Math.abs(r-b)<0.15){
      const lum=r;
      gl.uniform3f(entityU.uCol, 0.7+lum*0.5, 0.55+lum*0.4, 0.1+lum*0.15);
    } else {
      gl.uniform3f(entityU.uCol,r,g,b);
    }
    gl.drawArrays(gl.TRIANGLES,0,36);
  }

  if(gameMode==='juggernaut'){
    drawMinigun(vpMat,box);
    return;
  }

  // Camera basis vectors
  const SY=Math.sin(player.yaw),CY=Math.cos(player.yaw);
  const SP=Math.sin(player.pitch),CP=Math.cos(player.pitch);
  const fx=-SY*CP, fy=SP, fz=-CY*CP; // forward
  const rx=CY, ry=0, rz=-SY;          // right
  const ux=ry*fz-rz*fy, uy=rz*fx-rx*fz, uz=rx*fy-ry*fx; // up

  // Orientation matrix: local X+=right, Y+=up, Z+=forward
  const oM=new Float32Array([rx,ry,rz,0, ux,uy,uz,0, fx,fy,fz,0, 0,0,0,1]);

  // Bob & recoil
  const mv=(keys['KeyW']||keys['KeyS']||keys['KeyA']||keys['KeyD'])?1:0;
  const sprintBob=player.sprinting?2.5:1;
  const bobSpd=player.sprinting?0.009:0.005;
  const bobX=Math.sin(Date.now()*bobSpd)*0.008*mv*sprintBob;
  const bobY=Math.abs(Math.cos(Date.now()*bobSpd))*0.012*mv*sprintBob;
  const rk=recoil*0.06; // recoil pushback
  // 4-phase reload animation
  let rlDown=0, rlTilt=0, rlPhase=0, rlMagDrop=0, rlMagInsert=0;
  if(reloading){
    const rwpAnim=WEAPONS[currentWeapon]||WEAPONS[0];
    const prog=1-reloadTimer/rwpAnim.reload; // 0→1 over reload time
    if(prog<0.2){
      // Phase 1: tilt weapon
      rlPhase=1;
      const t=prog/0.2;
      rlTilt=t*0.4;
      rlDown=t*0.08;
    } else if(prog<0.4){
      // Phase 2: magazine drops out
      rlPhase=2;
      const t=(prog-0.2)/0.2;
      rlTilt=0.4;
      rlDown=0.08;
      rlMagDrop=t; // 0→1 mag drops
    } else if(prog<0.7){
      // Phase 3: new magazine slides up
      rlPhase=3;
      const t=(prog-0.4)/0.3;
      rlTilt=0.4-t*0.1;
      rlDown=0.08-t*0.02;
      rlMagInsert=t; // 0→1 mag goes in
    } else {
      // Phase 4: return to idle
      rlPhase=4;
      const t=(prog-0.7)/0.3;
      rlTilt=0.3*(1-t);
      rlDown=0.06*(1-t);
    }
  }
  // ADS offset (more centered)
  const adsR=player.ads?-0.10:0;

  // Base position: forward + right + down from camera
  const bx=player.x+fx*(0.32-rk)+rx*(0.22+adsR)+rx*bobX-ux*(0.24+rlDown)-ux*bobY;
  const by=player.y+fy*(0.32-rk)+ry*(0.22+adsR)+ry*bobX-uy*(0.24+rlDown)-uy*bobY;
  const bz=player.z+fz*(0.32-rk)+rz*(0.22+adsR)+rz*bobX-uz*(0.24+rlDown)-uz*bobY;

  // Base model: translate + orient + optional reload tilt
  let bM=mat4Mul(mat4T(bx,by,bz),oM);
  if(reloading) bM=mat4Mul(bM,mat4RX(rlTilt));

  // ===== WEAPON MODELS (per currentWeapon) =====
  // Magazine helper for reload animation
  function drawMag(mx,my,mz,mw,mh,md,c1,c2,c3,c1b,c2b,c3b){
    if(!reloading || rlPhase===1 || rlPhase===4){
      box(mat4Mul(bM,mat4T(mx,my,mz)), mw,mh,md, c1,c2,c3);
      box(mat4Mul(bM,mat4T(mx,my-mh-0.02,mz)), mw*.92,.02,md*.92, c1b,c2b,c3b);
    } else if(rlPhase===2){
      const mDrop=rlMagDrop*0.35, mRot=rlMagDrop*0.3;
      box(mat4Mul(bM,mat4Mul(mat4T(mx,my-mDrop,mz),mat4RX(mRot))), mw,mh,md, c1,c2,c3);
      box(mat4Mul(bM,mat4Mul(mat4T(mx,my-mh-0.02-mDrop,mz),mat4RX(mRot))), mw*.92,.02,md*.92, c1b,c2b,c3b);
    } else if(rlPhase===3){
      const mUp=(1-rlMagInsert)*0.30;
      box(mat4Mul(bM,mat4T(mx,my-mUp,mz)), mw,mh,md, .18,.18,.12);
      box(mat4Mul(bM,mat4T(mx,my-mh-0.02-mUp,mz)), mw*.92,.02,md*.92, .15,.15,.10);
    }
  }

  // Shared trigger/guard
  function drawTrigger(tz){
    box(mat4Mul(bM,mat4T(0,-.04,tz)), .004,.022,.06, .28,.28,.28);
    box(mat4Mul(bM,mat4T(0,-.03,tz+.015)), .005,.018,.008, .18,.18,.18);
  }

  // Right hand+arm helper (on grip at gz)
  function drawRightArm(gx,gy,gz){
    box(mat4Mul(bM,mat4T(gx+.018,gy+.02,gz)), .055,.04,.05, .76,.60,.46);
    box(mat4Mul(bM,mat4T(gx-.02,gy+.04,gz+.01)), .015,.02,.04, .72,.56,.42);
    box(mat4Mul(bM,mat4T(gx,gy+.035,gz+.05)), .012,.014,.03, .72,.56,.42);
    box(mat4Mul(bM,mat4Mul(mat4T(gx+.04,gy-.02,gz-.02),mat4RZ(-.25))), .045,.05,.05, .72,.56,.42);
    box(mat4Mul(bM,mat4Mul(mat4T(gx+.07,gy-.10,gz-.05),mat4RZ(-.35))), .048,.14,.05, .72,.56,.42);
    box(mat4Mul(bM,mat4Mul(mat4T(gx+.11,gy-.22,gz-.07),mat4RZ(-.4))), .055,.16,.06, .63,.18,.18);
    box(mat4Mul(bM,mat4Mul(mat4T(gx+.13,gy-.30,gz-.08),mat4RZ(-.4))), .06,.05,.065, .32,.32,.32);
  }

  // Left hand+arm helper (on handguard at hx,hy,hz)
  function drawLeftArm(hx,hy,hz){
    if(reloading && (rlPhase===2||rlPhase===3)){
      const lhx=0, lhy=-.10, lhz=-.02;
      box(mat4Mul(bM,mat4T(lhx,lhy,lhz)), .058,.048,.06, .76,.60,.46);
      box(mat4Mul(bM,mat4T(lhx-.01,lhy+.03,lhz)), .018,.018,.04, .72,.56,.42);
      box(mat4Mul(bM,mat4Mul(mat4T(-.05,-.16,-.04),mat4RZ(.3))), .045,.06,.05, .72,.56,.42);
      box(mat4Mul(bM,mat4Mul(mat4T(-.10,-.24,-.06),mat4RZ(.4))), .048,.14,.05, .72,.56,.42);
      box(mat4Mul(bM,mat4Mul(mat4T(-.15,-.34,-.08),mat4RZ(.45))), .055,.16,.06, .63,.18,.18);
      box(mat4Mul(bM,mat4Mul(mat4T(-.17,-.42,-.09),mat4RZ(.45))), .06,.05,.065, .32,.32,.32);
    } else {
      box(mat4Mul(bM,mat4T(hx,hy,hz)), .058,.048,.06, .76,.60,.46);
      box(mat4Mul(bM,mat4T(hx-.01,hy+.04,hz)), .018,.018,.04, .72,.56,.42);
      box(mat4Mul(bM,mat4T(hx+.02,hy-.025,hz+.01)), .04,.012,.04, .70,.54,.40);
      box(mat4Mul(bM,mat4Mul(mat4T(hx-.035,hy-.055,hz-.02),mat4RZ(.3))), .045,.05,.05, .72,.56,.42);
      box(mat4Mul(bM,mat4Mul(mat4T(hx-.085,hy-.145,hz-.06),mat4RZ(.4))), .048,.14,.05, .72,.56,.42);
      box(mat4Mul(bM,mat4Mul(mat4T(hx-.135,hy-.265,hz-.10),mat4RZ(.45))), .055,.16,.06, .63,.18,.18);
      box(mat4Mul(bM,mat4Mul(mat4T(hx-.155,hy-.345,hz-.11),mat4RZ(.45))), .06,.05,.065, .32,.32,.32);
    }
  }

  if(currentWeapon===0){
    // ===== ASSAULT RIFLE (AK/M4 style) =====
    box(mat4Mul(bM,mat4T(0,0,.24)), .022,.022,.38, .32,.32,.32); // Barrel
    box(mat4Mul(bM,mat4T(0,0,.44)), .028,.028,.05, .20,.20,.20); // Muzzle brake
    box(mat4Mul(bM,mat4T(.018,0,.44)), .008,.035,.04, .15,.15,.15); // Flash hider slit
    box(mat4Mul(bM,mat4T(-.018,0,.44)), .008,.035,.04, .15,.15,.15);
    box(mat4Mul(bM,mat4T(0,0,.12)), .038,.042,.16, .28,.28,.28); // Handguard
    box(mat4Mul(bM,mat4T(0,.032,.12)), .015,.008,.14, .38,.38,.38); // Rail top
    box(mat4Mul(bM,mat4T(0,-.032,.12)), .015,.008,.10, .35,.35,.35); // Rail bottom
    box(mat4Mul(bM,mat4T(0,.005,-.04)), .034,.048,.30, .22,.22,.22); // Receiver
    box(mat4Mul(bM,mat4T(0,.034,.02)), .018,.010,.24, .36,.36,.36); // Upper rail
    box(mat4Mul(bM,mat4T(.022,.01,-.01)), .006,.020,.04, .12,.12,.12); // Ejection port
    box(mat4Mul(bM,mat4T(0,.035,-.06)), .025,.008,.02, .40,.40,.40); // Charging handle
    drawMag(0,-.07,-.02, .028,.10,.038, .15,.15,.15, .12,.12,.12);
    drawTrigger(-.07);
    box(mat4Mul(bM,mat4Mul(mat4T(0,-.06,-.11),mat4RX(.2))), .024,.07,.032, .36,.25,.16); // Grip
    box(mat4Mul(bM,mat4T(0,.005,-.22)), .016,.016,.14, .28,.28,.28); // Stock tube
    box(mat4Mul(bM,mat4T(0,-.005,-.30)), .028,.045,.08, .36,.25,.16); // Stock
    box(mat4Mul(bM,mat4T(0,-.005,-.34)), .032,.052,.015, .18,.18,.18); // Buttpad
    drawRightArm(0,-.06,-.11);
    drawLeftArm(-.015,-.015,.12);

  } else if(currentWeapon===1){
    // ===== SHOTGUN (pump-action, wider barrel) =====
    // Long thick barrel
    box(mat4Mul(bM,mat4T(0,.01,.20)), .030,.030,.40, .25,.25,.25);
    // Barrel tip / choke
    box(mat4Mul(bM,mat4T(0,.01,.42)), .034,.034,.04, .18,.18,.18);
    // Magazine tube (under barrel)
    box(mat4Mul(bM,mat4T(0,-.025,.16)), .022,.022,.32, .30,.30,.30);
    // Magazine tube cap
    box(mat4Mul(bM,mat4T(0,-.025,.33)), .026,.026,.02, .20,.20,.20);
    // Pump/slide (grip piece under barrel)
    box(mat4Mul(bM,mat4T(0,-.015,.08)), .042,.048,.10, .38,.28,.16);
    // Pump grip ridges
    box(mat4Mul(bM,mat4T(0,-.040,.06)), .044,.008,.02, .30,.22,.12);
    box(mat4Mul(bM,mat4T(0,-.040,.08)), .044,.008,.02, .30,.22,.12);
    box(mat4Mul(bM,mat4T(0,-.040,.10)), .044,.008,.02, .30,.22,.12);
    // Receiver (chunky, boxy)
    box(mat4Mul(bM,mat4T(0,.008,-.06)), .040,.055,.28, .20,.20,.20);
    // Loading port (bottom)
    box(mat4Mul(bM,mat4T(0,-.035,-.04)), .032,.012,.08, .14,.14,.14);
    // Ejection port (right side)
    box(mat4Mul(bM,mat4T(.028,.02,-.02)), .008,.025,.06, .12,.12,.12);
    // Top rail (short)
    box(mat4Mul(bM,mat4T(0,.042,-.02)), .016,.008,.12, .35,.35,.35);
    // Front bead sight
    box(mat4Mul(bM,mat4T(0,.032,.36)), .006,.010,.006, 1,.3,.1);
    drawTrigger(-.12);
    // Pistol grip
    box(mat4Mul(bM,mat4Mul(mat4T(0,-.06,-.16),mat4RX(.22))), .028,.075,.036, .38,.28,.16);
    // Stock (wooden, thick)
    box(mat4Mul(bM,mat4T(0,-.005,-.24)), .032,.050,.12, .42,.30,.18);
    box(mat4Mul(bM,mat4T(0,-.008,-.32)), .034,.054,.06, .38,.26,.14);
    // Buttpad (rubber)
    box(mat4Mul(bM,mat4T(0,-.008,-.35)), .038,.058,.015, .15,.15,.15);
    // No magazine — internal tube
    drawRightArm(0,-.06,-.16);
    drawLeftArm(-.015,-.030,.08); // Left hand on pump

  } else if(currentWeapon===2){
    // ===== PISTOL (compact, one-handed look) =====
    // Short barrel
    box(mat4Mul(bM,mat4T(0,.015,.10)), .018,.018,.16, .28,.28,.28);
    // Muzzle
    box(mat4Mul(bM,mat4T(0,.015,.19)), .022,.022,.02, .18,.18,.18);
    // Slide (top half)
    box(mat4Mul(bM,mat4T(0,.022,.04)), .030,.028,.20, .22,.22,.22);
    // Slide serrations (rear)
    box(mat4Mul(bM,mat4T(0,.030,-.04)), .032,.010,.04, .28,.28,.28);
    // Ejection port
    box(mat4Mul(bM,mat4T(.020,.030,.02)), .006,.015,.03, .14,.14,.14);
    // Front sight
    box(mat4Mul(bM,mat4T(0,.040,.12)), .005,.010,.005, 1,1,1);
    // Rear sight
    box(mat4Mul(bM,mat4T(0,.040,-.02)), .012,.010,.005, 1,1,1);
    box(mat4Mul(bM,mat4T(0,.040,-.02)), .005,.012,.006, .15,.15,.15);
    // Frame (lower)
    box(mat4Mul(bM,mat4T(0,-.005,.02)), .028,.025,.16, .24,.24,.24);
    // Trigger guard
    box(mat4Mul(bM,mat4T(0,-.025,-.01)), .004,.018,.06, .26,.26,.26);
    // Trigger
    box(mat4Mul(bM,mat4T(0,-.018,.005)), .005,.015,.006, .18,.18,.18);
    // Grip (steeper angle)
    box(mat4Mul(bM,mat4Mul(mat4T(0,-.050,-.06),mat4RX(.28))), .026,.065,.030, .22,.22,.22);
    // Grip texture panels
    box(mat4Mul(bM,mat4Mul(mat4T(.018,-.050,-.06),mat4RX(.28))), .008,.055,.028, .28,.28,.28);
    box(mat4Mul(bM,mat4Mul(mat4T(-.018,-.050,-.06),mat4RX(.28))), .008,.055,.028, .28,.28,.28);
    // Magazine
    drawMag(0,-.065,-.04, .020,.055,.026, .18,.18,.18, .14,.14,.14);
    // Magazine base plate
    box(mat4Mul(bM,mat4T(0,-.13,-.04)), .022,.008,.028, .16,.16,.16);
    // Right hand (wrapping grip, higher up since pistol is small)
    box(mat4Mul(bM,mat4T(.018,-.03,-.06)), .055,.042,.06, .76,.60,.46);
    box(mat4Mul(bM,mat4T(-.02,-.01,-.05)), .015,.02,.04, .72,.56,.42);
    box(mat4Mul(bM,mat4T(0,-.015,.01)), .012,.014,.025, .72,.56,.42);
    box(mat4Mul(bM,mat4Mul(mat4T(.04,-.07,-.08),mat4RZ(-.25))), .045,.05,.05, .72,.56,.42);
    box(mat4Mul(bM,mat4Mul(mat4T(.07,-.15,-.11),mat4RZ(-.35))), .048,.14,.05, .72,.56,.42);
    box(mat4Mul(bM,mat4Mul(mat4T(.11,-.27,-.13),mat4RZ(-.4))), .055,.16,.06, .63,.18,.18);
    box(mat4Mul(bM,mat4Mul(mat4T(.13,-.35,-.14),mat4RZ(-.4))), .06,.05,.065, .32,.32,.32);
    // Left hand support (cupping right hand)
    if(reloading && (rlPhase===2||rlPhase===3)){
      const lhx=0, lhy=-.10, lhz=-.04;
      box(mat4Mul(bM,mat4T(lhx,lhy,lhz)), .058,.048,.06, .76,.60,.46);
      box(mat4Mul(bM,mat4Mul(mat4T(-.05,-.16,-.06),mat4RZ(.3))), .045,.06,.05, .72,.56,.42);
      box(mat4Mul(bM,mat4Mul(mat4T(-.10,-.24,-.08),mat4RZ(.4))), .048,.14,.05, .72,.56,.42);
      box(mat4Mul(bM,mat4Mul(mat4T(-.15,-.34,-.10),mat4RZ(.45))), .055,.16,.06, .63,.18,.18);
      box(mat4Mul(bM,mat4Mul(mat4T(-.17,-.42,-.11),mat4RZ(.45))), .06,.05,.065, .32,.32,.32);
    } else {
      box(mat4Mul(bM,mat4T(-.030,-.04,-.06)), .050,.046,.06, .76,.60,.46);
      box(mat4Mul(bM,mat4T(-.020,-.005,-.04)), .015,.018,.04, .72,.56,.42);
      box(mat4Mul(bM,mat4Mul(mat4T(-.055,-.08,-.08),mat4RZ(.3))), .045,.05,.05, .72,.56,.42);
      box(mat4Mul(bM,mat4Mul(mat4T(-.10,-.17,-.12),mat4RZ(.4))), .048,.14,.05, .72,.56,.42);
      box(mat4Mul(bM,mat4Mul(mat4T(-.15,-.29,-.16),mat4RZ(.45))), .055,.16,.06, .63,.18,.18);
      box(mat4Mul(bM,mat4Mul(mat4T(-.17,-.37,-.17),mat4RZ(.45))), .06,.05,.065, .32,.32,.32);
    }

  } else if(currentWeapon===3){
    // ===== SNIPER RIFLE (long barrel, scope, bipod) =====
    // Very long thin barrel
    box(mat4Mul(bM,mat4T(0,0,.30)), .018,.018,.55, .30,.30,.30);
    // Muzzle brake (large)
    box(mat4Mul(bM,mat4T(0,0,.58)), .032,.032,.06, .18,.18,.18);
    // Muzzle brake ports
    box(mat4Mul(bM,mat4T(.022,0,.57)), .008,.020,.04, .12,.12,.12);
    box(mat4Mul(bM,mat4T(-.022,0,.57)), .008,.020,.04, .12,.12,.12);
    // Free-float handguard (long, slim)
    box(mat4Mul(bM,mat4T(0,0,.12)), .032,.036,.22, .26,.26,.26);
    // Handguard ventilation holes
    box(mat4Mul(bM,mat4T(.020,0,.08)), .008,.020,.04, .18,.18,.18);
    box(mat4Mul(bM,mat4T(.020,0,.16)), .008,.020,.04, .18,.18,.18);
    box(mat4Mul(bM,mat4T(-.020,0,.08)), .008,.020,.04, .18,.18,.18);
    box(mat4Mul(bM,mat4T(-.020,0,.16)), .008,.020,.04, .18,.18,.18);
    // Receiver (long, flat-top)
    box(mat4Mul(bM,mat4T(0,.005,-.06)), .034,.048,.34, .20,.20,.20);
    // Bolt handle (right side)
    box(mat4Mul(bM,mat4T(.030,.015,.00)), .018,.012,.03, .35,.35,.35);
    box(mat4Mul(bM,mat4T(.045,.015,.00)), .012,.012,.012, .30,.30,.30);
    // ===== SCOPE =====
    // Scope mount rings
    box(mat4Mul(bM,mat4T(0,.050,.04)), .020,.016,.020, .28,.28,.28);
    box(mat4Mul(bM,mat4T(0,.050,-.06)), .020,.016,.020, .28,.28,.28);
    // Scope tube (main)
    box(mat4Mul(bM,mat4T(0,.072,-.01)), .022,.022,.18, .15,.15,.15);
    // Scope objective lens (front, larger)
    box(mat4Mul(bM,mat4T(0,.072,.10)), .030,.030,.03, .10,.10,.10);
    // Scope lens glass (cyan tint)
    box(mat4Mul(bM,mat4T(0,.072,.115)), .026,.026,.003, .1,.6,.8);
    // Scope eyepiece (rear)
    box(mat4Mul(bM,mat4T(0,.072,-.12)), .026,.026,.03, .12,.12,.12);
    // Scope elevation turret (top)
    box(mat4Mul(bM,mat4T(0,.092,-.02)), .012,.014,.012, .22,.22,.22);
    // Scope windage turret (right)
    box(mat4Mul(bM,mat4T(.032,.072,-.02)), .014,.012,.012, .22,.22,.22);
    // Ejection port
    box(mat4Mul(bM,mat4T(.024,.01,.00)), .006,.022,.05, .12,.12,.12);
    // Magazine (box style, larger)
    drawMag(0,-.075,-.04, .030,.085,.045, .16,.16,.16, .12,.12,.12);
    drawTrigger(-.12);
    // Pistol grip
    box(mat4Mul(bM,mat4Mul(mat4T(0,-.06,-.16),mat4RX(.18))), .026,.075,.034, .36,.25,.16);
    // Stock (adjustable, skeletonized)
    box(mat4Mul(bM,mat4T(0,.008,-.28)), .018,.018,.16, .26,.26,.26); // Stock tube
    box(mat4Mul(bM,mat4T(0,-.010,-.38)), .030,.048,.08, .36,.25,.16); // Cheek rest
    box(mat4Mul(bM,mat4T(0,.020,-.38)), .024,.012,.08, .32,.22,.14); // Cheek riser
    box(mat4Mul(bM,mat4T(0,-.010,-.42)), .034,.054,.015, .18,.18,.18); // Buttpad
    // ===== BIPOD (folded under) =====
    box(mat4Mul(bM,mat4Mul(mat4T(.015,-.045,.20),mat4RX(.6))), .006,.08,.006, .22,.22,.22);
    box(mat4Mul(bM,mat4Mul(mat4T(-.015,-.045,.20),mat4RX(.6))), .006,.08,.006, .22,.22,.22);
    // Bipod feet
    box(mat4Mul(bM,mat4Mul(mat4T(.015,-.10,.24),mat4RX(.6))), .010,.005,.015, .18,.18,.18);
    box(mat4Mul(bM,mat4Mul(mat4T(-.015,-.10,.24),mat4RX(.6))), .010,.005,.015, .18,.18,.18);
    drawRightArm(0,-.06,-.16);
    drawLeftArm(-.015,-.015,.10);

  } else if(currentWeapon===4){
    // ===== GLITCH WEAPON (purple/cyan distortion gun) =====
    const gt=Date.now()*0.01;
    const gFlicker=Math.sin(gt*3)*0.15;
    // Barrel (dark purple with cyan accents)
    box(mat4Mul(bM,mat4T(0,0,.22)), .024,.024,.36, .12+gFlicker,.02,.20);
    box(mat4Mul(bM,mat4T(0,0,.42)), .032,.032,.05, .05,.15,.25);
    // Energy rings on barrel
    box(mat4Mul(bM,mat4T(0,0,.15)), .030,.030,.02, 0,.4+gFlicker,.6);
    box(mat4Mul(bM,mat4T(0,0,.25)), .030,.030,.02, 0,.4+gFlicker,.6);
    box(mat4Mul(bM,mat4T(0,0,.35)), .030,.030,.02, 0,.4+gFlicker,.6);
    // Receiver body
    box(mat4Mul(bM,mat4T(0,.005,-.02)), .038,.048,.24, .10,.02,.16);
    // Glowing core in receiver
    gl.uniform1f(entityU.uFlash,0.3+Math.sin(gt)*0.2);
    box(mat4Mul(bM,mat4T(0,.015,0)), .025,.025,.10, .5,0,.8);
    gl.uniform1f(entityU.uFlash,0);
    // Top rail (glitchy cyan)
    box(mat4Mul(bM,mat4T(0,.038,.02)), .016,.008,.20, 0,.3,.4);
    // Magazine (dark)
    drawMag(0,-.07,-.02, .026,.08,.034, .08,.02,.12, .06,.02,.10);
    drawTrigger(-.07);
    // Grip (dark purple)
    box(mat4Mul(bM,mat4Mul(mat4T(0,-.06,-.11),mat4RX(.2))), .024,.07,.032, .12,.04,.18);
    // Stock (skeletal, dark)
    box(mat4Mul(bM,mat4T(0,.005,-.20)), .014,.014,.12, .08,.02,.14);
    box(mat4Mul(bM,mat4T(0,-.005,-.28)), .026,.042,.06, .10,.04,.16);
    box(mat4Mul(bM,mat4T(0,-.005,-.31)), .030,.048,.015, .06,.02,.10);
    drawRightArm(0,-.06,-.11);
    drawLeftArm(-.015,-.015,.12);
  }

  // ===== MUZZLE FLASH (weapon-specific) =====
  if(recoil>0.3){
    const fl=recoil-0.3;
    if(currentWeapon===1){
      // Shotgun: wide spread flash
      box(mat4Mul(bM,mat4T(0,.01,.46)), .08*fl*3,.08*fl*3,.04, 1,.8,.2);
      box(mat4Mul(bM,mat4T(0,.01,.50)), .06*fl*3,.06*fl*3,.02, 1,1,.6);
      box(mat4Mul(bM,mat4T(.03,.01,.47)), .03*fl*3,.03*fl*3,.02, 1,.7,.15);
      box(mat4Mul(bM,mat4T(-.03,.01,.47)), .03*fl*3,.03*fl*3,.02, 1,.7,.15);
    } else if(currentWeapon===2){
      // Pistol: small flash
      box(mat4Mul(bM,mat4T(0,.015,.22)), .035*fl*3,.035*fl*3,.02, 1,.85,.25);
      box(mat4Mul(bM,mat4T(0,.015,.24)), .02*fl*3,.02*fl*3,.015, 1,1,.7);
    } else if(currentWeapon===3){
      // Sniper: long thin flash
      box(mat4Mul(bM,mat4T(0,0,.62)), .04*fl*3,.04*fl*3,.05, 1,.85,.25);
      box(mat4Mul(bM,mat4T(0,0,.67)), .025*fl*3,.025*fl*3,.03, 1,1,.7);
    } else if(currentWeapon===4){
      // Glitch: purple flash
      box(mat4Mul(bM,mat4T(0,0,.46)), .05*fl*3,.05*fl*3,.03, .6,.1,1);
      box(mat4Mul(bM,mat4T(0,0,.49)), .03*fl*3,.03*fl*3,.02, .3,.8,1);
    } else {
      // Rifle: standard flash
      box(mat4Mul(bM,mat4T(0,0,.48)), .05*fl*3,.05*fl*3,.03, 1,.85,.25);
      box(mat4Mul(bM,mat4T(0,0,.51)), .03*fl*3,.03*fl*3,.02, 1,1,.7);
    }
  }
}

function drawMinigun(vpMat,box){
  // Camera basis
  const SY=Math.sin(player.yaw),CY=Math.cos(player.yaw);
  const SP=Math.sin(player.pitch),CP=Math.cos(player.pitch);
  const fx=-SY*CP, fy=SP, fz=-CY*CP;
  const rx=CY, ry=0, rz=-SY;
  const ux=ry*fz-rz*fy, uy=rz*fx-rx*fz, uz=rx*fy-ry*fx;
  const oM=new Float32Array([rx,ry,rz,0, ux,uy,uz,0, fx,fy,fz,0, 0,0,0,1]);

  const mv=(keys['KeyW']||keys['KeyS']||keys['KeyA']||keys['KeyD'])?1:0;
  const bobX=Math.sin(Date.now()*0.005)*0.006*mv;
  const bobY=Math.abs(Math.cos(Date.now()*0.005))*0.008*mv;
  const rk=recoil*0.04;

  const bx=player.x+fx*(0.35-rk)+rx*(0.25)+rx*bobX-ux*(0.30)-ux*bobY;
  const by=player.y+fy*(0.35-rk)+ry*(0.25)+ry*bobX-uy*(0.30)-uy*bobY;
  const bz=player.z+fz*(0.35-rk)+rz*(0.25)+rz*bobX-uz*(0.30)-uz*bobY;
  let bM=mat4Mul(mat4T(bx,by,bz),oM);

  // Spin barrels when firing
  if(mouseDown && ammo>0) minigunSpin+=0.5;
  else minigunSpin+=0.02;

  // Main body housing
  box(mat4Mul(bM,mat4T(0,0,-.05)), .055,.055,.28, .30,.30,.30);
  // Motor housing (rear)
  box(mat4Mul(bM,mat4T(0,0,-.22)), .06,.06,.10, .25,.25,.25);
  // Barrel shroud
  box(mat4Mul(bM,mat4T(0,0,.15)), .045,.045,.22, .28,.28,.28);

  // 6 rotating barrels
  for(let i=0;i<6;i++){
    const a=minigunSpin+Math.PI*2*i/6;
    const offX=Math.cos(a)*0.035;
    const offY=Math.sin(a)*0.035;
    box(mat4Mul(bM,mat4T(offX,offY,.26)), .012,.012,.28, .22,.22,.22);
  }

  // Front barrel clamp
  box(mat4Mul(bM,mat4T(0,0,.38)), .05,.05,.02, .35,.35,.35);
  // Ammo feed (left side box)
  box(mat4Mul(bM,mat4T(-.07,-.03,-.10)), .04,.06,.12, .20,.18,.12);
  // Ammo belt link
  box(mat4Mul(bM,mat4T(-.07,-.02,-.02)), .03,.02,.08, .55,.45,.15);
  // Handle/grip
  box(mat4Mul(bM,mat4Mul(mat4T(0,-.08,-.15),mat4RX(.15))), .028,.08,.04, .36,.25,.16);
  // Trigger area
  box(mat4Mul(bM,mat4T(0,-.05,-.12)), .015,.03,.03, .18,.18,.18);

  // ===== RIGHT HAND on grip =====
  box(mat4Mul(bM,mat4T(.02,-.06,-.15)), .055,.04,.05, .76,.60,.46);
  box(mat4Mul(bM,mat4Mul(mat4T(.04,-.12,-.17),mat4RZ(-.3))), .045,.08,.05, .72,.56,.42);
  box(mat4Mul(bM,mat4Mul(mat4T(.07,-.22,-.19),mat4RZ(-.4))), .048,.14,.05, .72,.56,.42);
  box(mat4Mul(bM,mat4Mul(mat4T(.11,-.34,-.20),mat4RZ(-.4))), .055,.14,.06, .63,.18,.18);

  // ===== LEFT HAND on top/front =====
  box(mat4Mul(bM,mat4T(-.02,.03,.08)), .055,.04,.06, .76,.60,.46);
  box(mat4Mul(bM,mat4Mul(mat4T(-.05,-.04,.06),mat4RZ(.3))), .045,.06,.05, .72,.56,.42);
  box(mat4Mul(bM,mat4Mul(mat4T(-.10,-.14,.04),mat4RZ(.4))), .048,.14,.05, .72,.56,.42);
  box(mat4Mul(bM,mat4Mul(mat4T(-.15,-.26,.02),mat4RZ(.45))), .055,.14,.06, .63,.18,.18);

  // Muzzle flash
  if(recoil>0.2){
    const fl=recoil-0.2;
    box(mat4Mul(bM,mat4T(0,0,.42)), .06*fl*3,.06*fl*3,.04, 1,.85,.25);
    box(mat4Mul(bM,mat4T(0,0,.46)), .04*fl*3,.04*fl*3,.03, 1,1,.7);
  }
}

function drawMenuCharacter(dt){
  menuCharAngle+=dt*0.5;
  gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
  gl.viewport(0,0,canvas.width,canvas.height);
  const aspect=canvas.width/canvas.height;
  const proj=perspective(1.0,aspect,0.1,50);
  const view=viewMatrix(0,1.2,4.5,Math.PI,0);
  const vp=mat4Mul(proj,view);
  if(!entityProg) return;
  resetAttribs();
  gl.useProgram(entityProg);
  gl.uniformMatrix4fv(entityU.uVP,false,vp);
  gl.uniform1f(entityU.uFog,100.0);
  gl.uniform1f(entityU.uAO,gfxShadows?1.0:0.0);
  gl.bindBuffer(gl.ARRAY_BUFFER,cubeVBO.buf);
  gl.enableVertexAttribArray(entityAP);
  gl.enableVertexAttribArray(entityAN);
  gl.vertexAttribPointer(entityAP,3,gl.FLOAT,false,24,0);
  gl.vertexAttribPointer(entityAN,3,gl.FLOAT,false,24,12);
  function box(m,sx,sy,sz,r,g,b){
    gl.uniformMatrix4fv(entityU.uM,false,mat4Mul(m,mat4S(sx,sy,sz)));
    gl.uniform3f(entityU.uCol,r,g,b);
    gl.drawArrays(gl.TRIANGLES,0,36);
  }
  gl.uniform1f(entityU.uFlash,0);
  const bM=mat4Mul(mat4T(0,0,0),mat4RY(-menuCharAngle));
  // Balaclava/head
  box(mat4Mul(bM,mat4T(0,1.82,0)),.28,.14,.28,.15,.15,.15);
  box(mat4Mul(bM,mat4T(0,1.66,0)),.21,.20,.20,.12,.12,.12);
  // Eyes through balaclava
  box(mat4Mul(bM,mat4T(-0.05,1.70,.11)),.045,.03,.01,.85,.85,.85);
  box(mat4Mul(bM,mat4T(-0.05,1.70,.115)),.02,.02,.005,.10,.10,.10);
  box(mat4Mul(bM,mat4T(0.05,1.70,.11)),.045,.03,.01,.85,.85,.85);
  box(mat4Mul(bM,mat4T(0.05,1.70,.115)),.02,.02,.005,.10,.10,.10);
  // Neck
  box(mat4Mul(bM,mat4T(0,1.52,0)),.08,.08,.08,.12,.12,.12);
  // Torso — red shirt
  box(mat4Mul(bM,mat4T(0,1.30,0)),.42,.32,.24,.60,.12,.12);
  box(mat4Mul(bM,mat4T(0,1.00,0)),.32,.28,.20,.55,.10,.10);
  // Vest over shirt
  box(mat4Mul(bM,mat4T(0,1.30,.05)),.36,.28,.14,.22,.24,.18);
  // Belt
  box(mat4Mul(bM,mat4T(0,0.88,0)),.34,.04,.22,.20,.18,.12);
  box(mat4Mul(bM,mat4T(0,0.84,0)),.28,.08,.18,.15,.15,.12);
  // Arms — combat pose holding rifle
  const rShM=mat4Mul(bM,mat4T(0.22,1.38,0));
  box(mat4Mul(rShM,mat4Mul(mat4RX(-1.2),mat4T(0,-0.19,0))),.10,.34,.10,.55,.10,.10);
  box(mat4Mul(rShM,mat4Mul(mat4RX(-1.2),mat4T(0,-0.38,0))),.07,.06,.08,.78,.62,.48);
  const lShM=mat4Mul(bM,mat4T(-0.22,1.38,0));
  box(mat4Mul(lShM,mat4Mul(mat4RX(-1.35),mat4T(0,-0.19,0.04))),.10,.34,.10,.55,.10,.10);
  box(mat4Mul(lShM,mat4Mul(mat4RX(-1.35),mat4T(0,-0.38,0.06))),.07,.06,.08,.78,.62,.48);
  // Rifle
  const wpM=mat4Mul(bM,mat4T(0.06,1.20,0.20));
  box(mat4Mul(wpM,mat4T(0,0,.22)),.020,.020,.30,.25,.25,.25);
  box(mat4Mul(wpM,mat4T(0,0,.08)),.035,.038,.16,.28,.28,.28);
  box(mat4Mul(wpM,mat4T(0,.003,-.10)),.032,.044,.24,.22,.22,.22);
  box(mat4Mul(wpM,mat4T(0,-.065,-.08)),.025,.085,.034,.15,.15,.15);
  // Legs — black pants
  const llM=mat4Mul(bM,mat4Mul(mat4T(-0.10,0.82,0),mat4RX(0)));
  box(mat4Mul(llM,mat4T(0,-0.24,0)),.14,.48,.14,.10,.10,.10);
  box(mat4Mul(llM,mat4T(0,-0.53,.01)),.16,.14,.20,.08,.08,.08);
  const rlM=mat4Mul(bM,mat4Mul(mat4T(0.10,0.82,0),mat4RX(0)));
  box(mat4Mul(rlM,mat4T(0,-0.24,0)),.14,.48,.14,.10,.10,.10);
  box(mat4Mul(rlM,mat4T(0,-0.53,.01)),.16,.14,.20,.08,.08,.08);
  resetAttribs();
}

function drawGiblets(vpMat){
  if(giblets.length===0 || !entityProg) return;
  gl.useProgram(entityProg);
  gl.uniformMatrix4fv(entityU.uVP,false,vpMat);
  gl.uniform1f(entityU.uFog,gameMode==='boss'?20.0:gfxFogDist);
  gl.uniform1f(entityU.uAO,gfxShadows?1.0:0.0);
  gl.bindBuffer(gl.ARRAY_BUFFER,cubeVBO.buf);
  gl.enableVertexAttribArray(entityAP);
  gl.enableVertexAttribArray(entityAN);
  gl.vertexAttribPointer(entityAP,3,gl.FLOAT,false,24,0);
  gl.vertexAttribPointer(entityAN,3,gl.FLOAT,false,24,12);
  gl.uniform1f(entityU.uFlash,0);
  for(const g of giblets){
    const a=g.particles[0], b=g.particles[1];
    const gdx=b.x-a.x, gdy=b.y-a.y, gdz=b.z-a.z;
    const glen=Math.sqrt(gdx*gdx+gdy*gdy+gdz*gdz)||0.01;
    const mx=(a.x+b.x)/2, my=(a.y+b.y)/2, mz=(a.z+b.z)/2;
    const ux=gdx/glen, uy=gdy/glen, uz=gdz/glen;
    let grx,gry,grz;
    if(Math.abs(uy)>0.99){grx=1;gry=0;grz=0;}else{
      const il=1/Math.sqrt(ux*ux+uz*uz); grx=-uz*il;gry=0;grz=ux*il;
    }
    const gfx=uy*grz-uz*gry, gfy=uz*grx-ux*grz, gfz=ux*gry-uy*grx;
    const gm=new Float32Array([grx*g.sx,gry*g.sx,grz*g.sx,0, ux*glen,uy*glen,uz*glen,0, gfx*g.sx,gfy*g.sx,gfz*g.sx,0, mx,my,mz,1]);
    gl.uniformMatrix4fv(entityU.uM,false,gm);
    gl.uniform3f(entityU.uCol,g.r,g.g,g.b);
    gl.drawArrays(gl.TRIANGLES,0,36);
  }
}

function drawBloodPools(vpMat){
  if(bloodPools.length===0 || !entityProg) return;
  gl.useProgram(entityProg);
  gl.uniformMatrix4fv(entityU.uVP,false,vpMat);
  gl.uniform1f(entityU.uFog,gameMode==='boss'?20.0:gfxFogDist);
  gl.uniform1f(entityU.uAO,gfxShadows?1.0:0.0);
  gl.bindBuffer(gl.ARRAY_BUFFER,cubeVBO.buf);
  gl.enableVertexAttribArray(entityAP);
  gl.enableVertexAttribArray(entityAN);
  gl.vertexAttribPointer(entityAP,3,gl.FLOAT,false,24,0);
  gl.vertexAttribPointer(entityAN,3,gl.FLOAT,false,24,12);
  gl.uniform1f(entityU.uFlash,0);
  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);
  gl.depthMask(false);
  for(const bp of bloodPools){
    if(bp.size<0.02) continue;
    const s=bp.size;
    const alpha=Math.min(0.7,bp.age*0.3); // fade in gradually
    // Slightly elliptical pool on floor
    const dm=new Float32Array([
      s*1.2, 0, 0, 0,
      0, 0.003, 0, 0,
      0, 0, s*0.9, 0,
      bp.x, 0.004, bp.z, 1]);
    gl.uniformMatrix4fv(entityU.uM,false,dm);
    gl.uniform3f(entityU.uCol,0.25*alpha,0.01*alpha,0.01*alpha);
    gl.drawArrays(gl.TRIANGLES,0,36);
  }
  gl.depthMask(true);
  gl.disable(gl.BLEND);
}

function drawBloodDecals(vpMat){
  if(bloodDecals.length===0 || !entityProg) return;
  gl.useProgram(entityProg);
  gl.uniformMatrix4fv(entityU.uVP,false,vpMat);
  gl.uniform1f(entityU.uFog,gameMode==='boss'?20.0:gfxFogDist);
  gl.uniform1f(entityU.uAO,gfxShadows?1.0:0.0);
  gl.bindBuffer(gl.ARRAY_BUFFER,cubeVBO.buf);
  gl.enableVertexAttribArray(entityAP);
  gl.enableVertexAttribArray(entityAN);
  gl.vertexAttribPointer(entityAP,3,gl.FLOAT,false,24,0);
  gl.vertexAttribPointer(entityAN,3,gl.FLOAT,false,24,12);
  gl.uniform1f(entityU.uFlash,0);
  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);
  gl.depthMask(false);
  for(const d of bloodDecals){
    const s=d.size;
    const alpha=Math.min(1,d.life/2);
    const rot=d.rot||0;
    const cr=Math.cos(rot), sr=Math.sin(rot);
    let dm;
    if(d.ny===1){
      // Floor decal: flat in XZ plane with rotation for organic shape
      // Elongate slightly for splatter effect
      const sx2=s*(0.8+Math.random()*0.01), sz2=s*(0.6+Math.random()*0.01);
      dm=new Float32Array([
        cr*sx2, 0, sr*sx2, 0,
        0, 0.004, 0, 0,
        -sr*sz2, 0, cr*sz2, 0,
        d.x, d.y, d.z, 1]);
    } else if(d.nx!==0){
      // Wall X-facing: flat in YZ plane with rotation
      dm=new Float32Array([
        0.004, 0, 0, 0,
        0, cr*s, sr*s, 0,
        0, -sr*s, cr*s, 0,
        d.x, d.y, d.z, 1]);
    } else {
      // Wall Z-facing: flat in XY plane with rotation
      dm=new Float32Array([
        cr*s, sr*s, 0, 0,
        -sr*s, cr*s, 0, 0,
        0, 0, 0.004, 0,
        d.x, d.y, d.z, 1]);
    }
    gl.uniformMatrix4fv(entityU.uM,false,dm);
    gl.uniform3f(entityU.uCol,0.32*alpha,0.02*alpha,0.01*alpha);
    gl.drawArrays(gl.TRIANGLES,0,36);
  }
  gl.depthMask(true);
  gl.disable(gl.BLEND);
}

function drawPlayerSkeleton(vpMat){
  if(!entityProg||!thirdPersonCam) return;
  gl.useProgram(entityProg);
  gl.uniformMatrix4fv(entityU.uVP,false,vpMat);
  gl.uniform1f(entityU.uFog,gameMode==='boss'?20.0:gfxFogDist);
  gl.uniform1f(entityU.uAO,gfxShadows?1.0:0.0);
  gl.bindBuffer(gl.ARRAY_BUFFER,cubeVBO.buf);
  gl.enableVertexAttribArray(entityAP);
  gl.enableVertexAttribArray(entityAN);
  gl.vertexAttribPointer(entityAP,3,gl.FLOAT,false,24,0);
  gl.vertexAttribPointer(entityAN,3,gl.FLOAT,false,24,12);
  gl.uniform1f(entityU.uFlash,0);
  function box(m,sx,sy,sz,r,g,b){
    gl.uniformMatrix4fv(entityU.uM,false,mat4Mul(m,mat4S(sx,sy,sz)));
    gl.uniform3f(entityU.uCol,r,g,b);
    gl.drawArrays(gl.TRIANGLES,0,36);
  }
  const bM=mat4Mul(mat4T(player.x,0,player.z),mat4RY(-player.yaw));
  const wk=Date.now()*0.005;
  const mv=(keys['KeyW']||keys['KeyS']||keys['KeyA']||keys['KeyD'])?1:0;
  const ls=Math.sin(wk)*0.5*mv, lr=-Math.sin(wk)*0.5*mv;
  if(skeletonMode){
  // All black skeleton body
  const boneC=[.08,.06,.06]; const jointC=[.04,.03,.03];
  box(mat4Mul(bM,mat4T(0,1.78,0)), 0.18,0.16,0.18, boneC[0],boneC[1],boneC[2]);
  box(mat4Mul(bM,mat4T(-0.05,1.72,.09)), 0.035,0.03,0.01, .4,0,.6);
  box(mat4Mul(bM,mat4T(0.05,1.72,.09)), 0.035,0.03,0.01, .4,0,.6);
  box(mat4Mul(bM,mat4T(0,1.62,.02)), 0.10,0.04,0.08, boneC[0],boneC[1],boneC[2]);
  box(mat4Mul(bM,mat4T(0,1.50,0)), 0.06,0.06,0.06, jointC[0],jointC[1],jointC[2]);
  box(mat4Mul(bM,mat4T(0,1.35,0)), 0.05,0.22,0.05, boneC[0],boneC[1],boneC[2]);
  box(mat4Mul(bM,mat4T(0,1.10,0)), 0.06,0.06,0.06, jointC[0],jointC[1],jointC[2]);
  box(mat4Mul(bM,mat4T(0,0.95,0)), 0.05,0.18,0.05, boneC[0],boneC[1],boneC[2]);
  box(mat4Mul(bM,mat4T(0,1.30,0)), 0.25,0.04,0.14, boneC[0],boneC[1],boneC[2]);
  box(mat4Mul(bM,mat4T(0,1.22,0)), 0.22,0.04,0.12, boneC[0],boneC[1],boneC[2]);
  box(mat4Mul(bM,mat4T(0,1.14,0)), 0.18,0.04,0.10, boneC[0],boneC[1],boneC[2]);
  box(mat4Mul(bM,mat4T(0,0.82,0)), 0.20,0.08,0.12, boneC[0],boneC[1],boneC[2]);
  const laM=mat4Mul(bM,mat4Mul(mat4T(-0.20,1.38,0),mat4RX(ls*0.6)));
  box(mat4Mul(laM,mat4T(0,-0.15,0)), 0.05,0.22,0.05, boneC[0],boneC[1],boneC[2]);
  box(mat4Mul(laM,mat4T(0,-0.32,0)), 0.04,0.04,0.04, jointC[0],jointC[1],jointC[2]);
  box(mat4Mul(laM,mat4T(0,-0.47,0)), 0.04,0.18,0.04, boneC[0],boneC[1],boneC[2]);
  const raM=mat4Mul(bM,mat4Mul(mat4T(0.20,1.38,0),mat4RX(lr*0.6)));
  box(mat4Mul(raM,mat4T(0,-0.15,0)), 0.05,0.22,0.05, boneC[0],boneC[1],boneC[2]);
  box(mat4Mul(raM,mat4T(0,-0.32,0)), 0.04,0.04,0.04, jointC[0],jointC[1],jointC[2]);
  box(mat4Mul(raM,mat4T(0,-0.47,0)), 0.04,0.18,0.04, boneC[0],boneC[1],boneC[2]);
  const llM=mat4Mul(bM,mat4Mul(mat4T(-0.10,0.80,0),mat4RX(ls)));
  box(mat4Mul(llM,mat4T(0,-0.18,0)), 0.06,0.26,0.06, boneC[0],boneC[1],boneC[2]);
  box(mat4Mul(llM,mat4T(0,-0.38,0)), 0.05,0.05,0.05, jointC[0],jointC[1],jointC[2]);
  box(mat4Mul(llM,mat4T(0,-0.56,0)), 0.05,0.24,0.05, boneC[0],boneC[1],boneC[2]);
  const rlM=mat4Mul(bM,mat4Mul(mat4T(0.10,0.80,0),mat4RX(lr)));
  box(mat4Mul(rlM,mat4T(0,-0.18,0)), 0.06,0.26,0.06, boneC[0],boneC[1],boneC[2]);
  box(mat4Mul(rlM,mat4T(0,-0.38,0)), 0.05,0.05,0.05, jointC[0],jointC[1],jointC[2]);
  box(mat4Mul(rlM,mat4T(0,-0.56,0)), 0.05,0.24,0.05, boneC[0],boneC[1],boneC[2]);
  const gunM=mat4Mul(raM,mat4Mul(mat4T(0,-0.55,0.15),mat4RX(-1.4)));
  box(mat4Mul(gunM,mat4T(0,0,0.15)), 0.025,0.025,0.30, .12,.02,.18);
  box(mat4Mul(gunM,mat4T(0,0,0)), 0.035,0.04,0.12, .10,.02,.15);
  box(mat4Mul(gunM,mat4T(0,-0.04,-0.04)), 0.02,0.06,0.03, .08,.02,.12);
  gl.uniform1f(entityU.uFlash,0.5+Math.sin(Date.now()*0.01)*0.3);
  box(mat4Mul(gunM,mat4T(0,0.01,0.06)), 0.02,0.02,0.06, .5,0,.8);
  gl.uniform1f(entityU.uFlash,0);
  } else {
  // Normal soldier 3rd person model
  // Helmet
  box(mat4Mul(bM,mat4T(0,1.82,0)), 0.22,0.12,0.22, .33,.37,.20);
  // Head
  box(mat4Mul(bM,mat4T(0,1.72,0)), 0.16,0.14,0.16, .85,.68,.55);
  // Eyes
  box(mat4Mul(bM,mat4T(-0.05,1.73,.08)), 0.03,0.02,0.01, 1,1,1);
  box(mat4Mul(bM,mat4T(0.05,1.73,.08)), 0.03,0.02,0.01, 1,1,1);
  box(mat4Mul(bM,mat4T(-0.05,1.73,.085)), 0.015,0.015,0.01, .1,.1,.1);
  box(mat4Mul(bM,mat4T(0.05,1.73,.085)), 0.015,0.015,0.01, .1,.1,.1);
  // Neck
  box(mat4Mul(bM,mat4T(0,1.60,0)), 0.06,0.06,0.06, .80,.62,.48);
  // Upper torso
  box(mat4Mul(bM,mat4T(0,1.38,0)), 0.28,0.20,0.16, .30,.34,.18);
  // Lower torso
  box(mat4Mul(bM,mat4T(0,1.12,0)), 0.24,0.12,0.14, .30,.34,.18);
  // Belt
  box(mat4Mul(bM,mat4T(0,1.02,0)), 0.26,0.04,0.15, .20,.15,.08);
  // Arms
  const laM=mat4Mul(bM,mat4Mul(mat4T(-0.22,1.40,0),mat4RX(ls*0.6)));
  box(mat4Mul(laM,mat4T(0,-0.14,0)), 0.08,0.20,0.08, .30,.34,.18);
  box(mat4Mul(laM,mat4T(0,-0.36,0)), 0.07,0.18,0.07, .30,.34,.18);
  box(mat4Mul(laM,mat4T(0,-0.52,0)), 0.06,0.06,0.06, .80,.62,.48);
  const raM=mat4Mul(bM,mat4Mul(mat4T(0.22,1.40,0),mat4RX(lr*0.6)));
  box(mat4Mul(raM,mat4T(0,-0.14,0)), 0.08,0.20,0.08, .30,.34,.18);
  box(mat4Mul(raM,mat4T(0,-0.36,0)), 0.07,0.18,0.07, .30,.34,.18);
  box(mat4Mul(raM,mat4T(0,-0.52,0)), 0.06,0.06,0.06, .80,.62,.48);
  // Legs
  const llM=mat4Mul(bM,mat4Mul(mat4T(-0.10,0.95,0),mat4RX(ls)));
  box(mat4Mul(llM,mat4T(0,-0.18,0)), 0.09,0.24,0.09, .25,.28,.15);
  box(mat4Mul(llM,mat4T(0,-0.46,0)), 0.08,0.22,0.08, .25,.28,.15);
  box(mat4Mul(llM,mat4T(0,-0.66,0)), 0.09,0.06,0.12, .15,.12,.08);
  const rlM=mat4Mul(bM,mat4Mul(mat4T(0.10,0.95,0),mat4RX(lr)));
  box(mat4Mul(rlM,mat4T(0,-0.18,0)), 0.09,0.24,0.09, .25,.28,.15);
  box(mat4Mul(rlM,mat4T(0,-0.46,0)), 0.08,0.22,0.08, .25,.28,.15);
  box(mat4Mul(rlM,mat4T(0,-0.66,0)), 0.09,0.06,0.12, .15,.12,.08);
  // Weapon in right hand
  const gunM=mat4Mul(raM,mat4Mul(mat4T(0,-0.55,0.15),mat4RX(-1.4)));
  box(mat4Mul(gunM,mat4T(0,0,0.20)), 0.02,0.02,0.35, .25,.22,.20);
  box(mat4Mul(gunM,mat4T(0,0,0)), 0.04,0.05,0.14, .20,.18,.16);
  box(mat4Mul(gunM,mat4T(0,-0.04,-0.04)), 0.02,0.06,0.03, .15,.12,.10);
  box(mat4Mul(gunM,mat4T(0,0.03,0.12)), 0.025,0.015,0.06, .18,.16,.14);
  }
}

function render(){
  gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);

  // Boss mode: darker ambient override via clear color
  if(gameMode==='boss'){
    gl.clearColor(0.02,0.01,0.04,1);
    gl.clear(gl.COLOR_BUFFER_BIT);
  } else {
    gl.clearColor(0.05,0.05,0.12,1);
  }

  const aspect=canvas.width/canvas.height;
  const rwp=WEAPONS[currentWeapon]||WEAPONS[0];
  const adsFov=rwp.zoom||0.4;
  const fov=player.ads?adsFov:1.2;
  const proj=perspective(fov, aspect, 0.1, 100);
  // Lean offset: shift camera sideways + slight roll via pitch/yaw trick
  const leanOff=leanAmount*0.45; // sideways offset
  const leanRoll=leanAmount*0.08; // slight head tilt
  const rxCam=Math.cos(player.yaw), rzCam=-Math.sin(player.yaw); // right vector
  let camX,camY,camZ;
  if(thirdPersonCam){
    // Third-person camera: 3 units behind, 1.5 above player, with wall collision
    const fwdX=-Math.sin(player.yaw)*Math.cos(player.pitch);
    const fwdZ=-Math.cos(player.yaw)*Math.cos(player.pitch);
    const fwdY=Math.sin(player.pitch);
    const wantX=player.x - fwdX*3 + rxCam*leanOff;
    const wantY=player.y + 1.5 - fwdY*1.5;
    const wantZ=player.z - fwdZ*3 + rzCam*leanOff;
    const cc=cameraRayCollide(player.x,player.y,player.z,wantX,wantY,wantZ);
    camX=cc.x; camY=cc.y; camZ=cc.z;
  } else {
    camX=player.x+rxCam*leanOff;
    camY=player.y;
    camZ=player.z+rzCam*leanOff;
  }
  const shakeYaw=screenShake*(Math.random()-0.5)*0.04;
  const shakePitch=screenShake*(Math.random()-0.5)*0.04;
  const view=viewMatrix(camX, camY, camZ, player.yaw+shakeYaw, player.pitch+leanRoll+shakePitch);
  const vp=mat4Mul(proj,view);
  _lastVP=vp; // cache for HUD label projection

  resetAttribs();
  drawWorld(vp);
  resetAttribs();
  drawEnemies(vp,view);
  resetAttribs();
  drawBloodPools(vp);
  resetAttribs();
  drawGiblets(vp);
  resetAttribs();
  drawBloodDecals(vp);
  resetAttribs();
  drawParticles(vp);
  // Draw grenades as small dark boxes
  if(grenades.length>0&&entityProg){
    gl.useProgram(entityProg);
    gl.uniformMatrix4fv(entityU.uVP,false,vp);
    gl.uniform1f(entityU.uFog,gameMode==='boss'?20.0:gfxFogDist);
    gl.bindBuffer(gl.ARRAY_BUFFER,cubeVBO.buf);
    gl.enableVertexAttribArray(entityAP);gl.enableVertexAttribArray(entityAN);
    gl.vertexAttribPointer(entityAP,3,gl.FLOAT,false,24,0);
    gl.vertexAttribPointer(entityAN,3,gl.FLOAT,false,24,12);
    gl.uniform1f(entityU.uFlash,0);
    for(const g of grenades){
      const spin=Date.now()*0.01;
      gl.uniformMatrix4fv(entityU.uM,false,mat4Mul(mat4Mul(mat4T(g.x,g.y,g.z),mat4RY(spin)),mat4S(0.08,0.08,0.12)));
      gl.uniform3f(entityU.uCol,0.2,0.25,0.15);
      gl.drawArrays(gl.TRIANGLES,0,36);
    }
  }
  // Draw barrels (red/brown boxes)
  if(barrels.length>0&&entityProg){
    gl.useProgram(entityProg);
    gl.uniformMatrix4fv(entityU.uVP,false,vp);
    gl.uniform1f(entityU.uFog,gameMode==='boss'?20.0:gfxFogDist);
    gl.bindBuffer(gl.ARRAY_BUFFER,cubeVBO.buf);
    gl.enableVertexAttribArray(entityAP);gl.enableVertexAttribArray(entityAN);
    gl.vertexAttribPointer(entityAP,3,gl.FLOAT,false,24,0);
    gl.vertexAttribPointer(entityAN,3,gl.FLOAT,false,24,12);
    gl.uniform1f(entityU.uFlash,0);
    for(const bar of barrels){
      if(bar.exploded) continue;
      // Barrel body (dark red cylinder approx as box)
      gl.uniformMatrix4fv(entityU.uM,false,mat4Mul(mat4T(bar.x,0.5,bar.z),mat4S(0.5,1.0,0.5)));
      gl.uniform3f(entityU.uCol,0.5,0.15,0.1);
      gl.drawArrays(gl.TRIANGLES,0,36);
      // Yellow hazard stripe
      gl.uniformMatrix4fv(entityU.uM,false,mat4Mul(mat4T(bar.x,0.55,bar.z),mat4S(0.52,0.15,0.52)));
      gl.uniform3f(entityU.uCol,0.8,0.7,0.1);
      gl.drawArrays(gl.TRIANGLES,0,36);
    }
  }
  // Draw doors
  if(doors.length>0&&entityProg){
    gl.useProgram(entityProg);
    gl.uniformMatrix4fv(entityU.uVP,false,vp);
    gl.uniform1f(entityU.uFog,gameMode==='boss'?20.0:gfxFogDist);
    gl.bindBuffer(gl.ARRAY_BUFFER,cubeVBO.buf);
    gl.enableVertexAttribArray(entityAP);gl.enableVertexAttribArray(entityAN);
    gl.vertexAttribPointer(entityAP,3,gl.FLOAT,false,24,0);
    gl.vertexAttribPointer(entityAN,3,gl.FLOAT,false,24,12);
    gl.uniform1f(entityU.uFlash,0);
    for(const door of doors){
      if(door.open) continue; // Don't render open doors
      // Door frame
      gl.uniformMatrix4fv(entityU.uM,false,mat4Mul(mat4T(door.x,WALL_H/2,door.z),mat4S(CELL*0.9,WALL_H,0.15)));
      gl.uniform3f(entityU.uCol,0.4,0.25,0.12);
      gl.drawArrays(gl.TRIANGLES,0,36);
      // Door handle
      gl.uniformMatrix4fv(entityU.uM,false,mat4Mul(mat4T(door.x+0.3,1.0,door.z),mat4S(0.08,0.08,0.2)));
      gl.uniform3f(entityU.uCol,0.7,0.6,0.2);
      gl.drawArrays(gl.TRIANGLES,0,36);
    }
  }
  // Draw bombs (pulsing red boxes)
  if(bombs.length>0&&entityProg){
    gl.useProgram(entityProg);
    gl.uniformMatrix4fv(entityU.uVP,false,vp);
    gl.uniform1f(entityU.uFog,gameMode==='boss'?20.0:gfxFogDist);
    gl.bindBuffer(gl.ARRAY_BUFFER,cubeVBO.buf);
    gl.enableVertexAttribArray(entityAP);gl.enableVertexAttribArray(entityAN);
    gl.vertexAttribPointer(entityAP,3,gl.FLOAT,false,24,0);
    gl.vertexAttribPointer(entityAN,3,gl.FLOAT,false,24,12);
    for(const b of bombs){
      if(b.defused) continue;
      const pulse=0.5+0.5*Math.sin(Date.now()*0.005);
      gl.uniform1f(entityU.uFlash,pulse*0.5);
      gl.uniformMatrix4fv(entityU.uM,false,mat4Mul(mat4T(b.x,0.25,b.z),mat4S(0.4,0.5,0.4)));
      gl.uniform3f(entityU.uCol,0.6,0.1,0.1);
      gl.drawArrays(gl.TRIANGLES,0,36);
      // Blinking light on top
      gl.uniformMatrix4fv(entityU.uM,false,mat4Mul(mat4T(b.x,0.55,b.z),mat4S(0.1,0.1,0.1)));
      gl.uniform3f(entityU.uCol,pulse,0,0);
      gl.uniform1f(entityU.uFlash,pulse);
      gl.drawArrays(gl.TRIANGLES,0,36);
    }
    gl.uniform1f(entityU.uFlash,0);
  }
  // Draw mines (small dark boxes on floor)
  if(mines.length>0&&entityProg){
    gl.useProgram(entityProg);
    gl.uniformMatrix4fv(entityU.uVP,false,vp);
    gl.uniform1f(entityU.uFog,gfxFogDist);
    gl.bindBuffer(gl.ARRAY_BUFFER,cubeVBO.buf);
    gl.enableVertexAttribArray(entityAP);gl.enableVertexAttribArray(entityAN);
    gl.vertexAttribPointer(entityAP,3,gl.FLOAT,false,24,0);
    gl.vertexAttribPointer(entityAN,3,gl.FLOAT,false,24,12);
    for(const m of mines){
      if(m.exploded) continue;
      gl.uniform1f(entityU.uFlash,m.armed?0.2*Math.sin(Date.now()*0.008):0);
      gl.uniformMatrix4fv(entityU.uM,false,mat4Mul(mat4T(m.x,0.05,m.z),mat4S(0.25,0.08,0.25)));
      gl.uniform3f(entityU.uCol,0.3,0.25,0.1);
      gl.drawArrays(gl.TRIANGLES,0,36);
      if(m.armed){
        gl.uniformMatrix4fv(entityU.uM,false,mat4Mul(mat4T(m.x,0.12,m.z),mat4S(0.06,0.04,0.06)));
        gl.uniform3f(entityU.uCol,0.8,0.1,0.1);
        gl.drawArrays(gl.TRIANGLES,0,36);
      }
    }
    gl.uniform1f(entityU.uFlash,0);
  }
  // Draw cameras (small cyan boxes on walls)
  if(cameras.length>0&&entityProg){
    gl.useProgram(entityProg);
    gl.uniformMatrix4fv(entityU.uVP,false,vp);
    gl.uniform1f(entityU.uFog,gfxFogDist);
    gl.bindBuffer(gl.ARRAY_BUFFER,cubeVBO.buf);
    gl.enableVertexAttribArray(entityAP);gl.enableVertexAttribArray(entityAN);
    gl.vertexAttribPointer(entityAP,3,gl.FLOAT,false,24,0);
    gl.vertexAttribPointer(entityAN,3,gl.FLOAT,false,24,12);
    gl.uniform1f(entityU.uFlash,0);
    for(const cam of cameras){
      if(!cam.alive) continue;
      gl.uniformMatrix4fv(entityU.uM,false,mat4Mul(mat4T(cam.x,cam.y,cam.z),mat4S(0.2,0.15,0.2)));
      gl.uniform3f(entityU.uCol,0.1,0.3,0.35);
      gl.drawArrays(gl.TRIANGLES,0,36);
      // Lens
      gl.uniformMatrix4fv(entityU.uM,false,mat4Mul(mat4Mul(mat4T(cam.x,cam.y,cam.z),mat4RY(cam.angle)),mat4Mul(mat4T(0,0,0.12),mat4S(0.08,0.08,0.05))));
      gl.uniform3f(entityU.uCol,0,0.6,0.8);
      gl.drawArrays(gl.TRIANGLES,0,36);
    }
  }
  // Flashlight cone overlay (simple additive quad)
  if(flashlightOn&&hasFlashlight){
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA,gl.ONE);
    // Draw a subtle light cone using particles shader as point
    // We'll handle flashlight as a post-process canvas overlay below
    gl.disable(gl.BLEND);
  }
  // Draw player skeleton in 3rd person
  if(thirdPersonCam){
    resetAttribs();
    drawPlayerSkeleton(vp);
  }
  resetAttribs();
  // In 3rd person, skip 1st-person weapon
  if(!thirdPersonCam) drawWeapon3D(vp);
  // Flashlight canvas overlay
  if(flashlightOn&&hasFlashlight){
    const fctx=document.getElementById('rainCanvas').getContext('2d');
    // We'll draw flashlight on the rain canvas if no rain
    // Actually use a separate approach in frame()
  }
  // Neon mode: tint the scene
  if(neonMode){
    const nOv=document.getElementById('neonOverlay');
    if(nOv) nOv.style.display='block';
  }
}

/* Old 2D weapon draw removed — now using drawWeapon3D() in render() */

/* ============================================================
   MINIMAP
   ============================================================ */
const mmCanvas = document.getElementById('minimap');
const mmctx = mmCanvas.getContext('2d');

function drawMinimap(){
  const w=mmCanvas.width, h=mmCanvas.height;
  mmctx.fillStyle='rgba(0,0,0,0.8)';
  mmctx.fillRect(0,0,w,h);

  const scale=w/MAP_W;
  const scaleZ=h/MAP_H;
  const s=Math.min(scale,scaleZ);

  // Walls
  for(let z=0;z<MAP_H;z++) for(let x=0;x<MAP_W;x++){
    const c=MAP[z][x];
    if(c===1){mmctx.fillStyle='#555';}
    else if(c===2){mmctx.fillStyle='#764';}
    else if(c===5){mmctx.fillStyle='#08f';}
    else continue;
    mmctx.fillRect(x*s,z*s,s,s);
  }

  // Money bags
  mmctx.fillStyle='#ff0';
  for(const m of moneyBags){
    if(!m.alive) continue;
    mmctx.beginPath();
    mmctx.arc(m.x/CELL*s, m.z/CELL*s, 2, 0, Math.PI*2);
    mmctx.fill();
  }

  // Enemies
  for(const e of enemies){
    mmctx.fillStyle=e.hp<=0?'#600':e._glitched?'#a0f':e._isBoss?'#f0f':e.state==='captured'?'#0ff':e.state==='blinded'?'#fa0':'#f00';
    mmctx.beginPath();
    mmctx.arc(e.x/CELL*s, e.z/CELL*s, e._isBoss&&e.hp>0?4:e.hp>0?2.5:1.5, 0, Math.PI*2);
    mmctx.fill();
  }

  // Allies
  for(const a of allies){
    mmctx.fillStyle=a.hp>0?(a.role==='medic'?'#4af':a.role==='dumb'?'#f8a':'#0f0'):'#555';
    mmctx.beginPath();
    mmctx.arc(a.x/CELL*s, a.z/CELL*s, a.hp>0?2.5:1.5, 0, Math.PI*2);
    mmctx.fill();
    // Name initial
    if(a.hp>0){
      mmctx.fillStyle='#fff';mmctx.font='6px monospace';
      mmctx.fillText(a.name[0],a.x/CELL*s-2,a.z/CELL*s-3);
    }
  }

  // Doors
  for(const door of doors){
    mmctx.fillStyle=door.open?'#4a2':'#854';
    mmctx.fillRect(door.gx*s,door.gz*s,s,s);
  }
  // Barrels
  for(const bar of barrels){
    if(bar.exploded) continue;
    mmctx.fillStyle='#f80';
    mmctx.beginPath();
    mmctx.arc(bar.x/CELL*s, bar.z/CELL*s, 2, 0, Math.PI*2);
    mmctx.fill();
  }
  // Bombs
  for(const b of bombs){
    if(b.defused) continue;
    const pulse=0.5+0.5*Math.sin(Date.now()*0.005);
    mmctx.fillStyle=`rgba(255,${Math.floor(50*pulse)},${Math.floor(50*pulse)},1)`;
    mmctx.beginPath();
    mmctx.arc(b.x/CELL*s, b.z/CELL*s, 3, 0, Math.PI*2);
    mmctx.fill();
    mmctx.strokeStyle='#f00';mmctx.lineWidth=1;
    mmctx.stroke();
  }

  // Mines
  mmctx.fillStyle='#fa0';
  for(const m of mines){
    if(m.exploded) continue;
    mmctx.beginPath();
    mmctx.arc(m.x/CELL*s,m.z/CELL*s,m.armed?2:1.5,0,Math.PI*2);
    mmctx.fill();
    if(m.armed){mmctx.strokeStyle='#f00';mmctx.lineWidth=0.5;mmctx.stroke();}
  }
  // Cameras
  for(const cam of cameras){
    if(!cam.alive) continue;
    mmctx.fillStyle='#0ff';
    mmctx.fillRect(cam.x/CELL*s-1.5,cam.z/CELL*s-1.5,3,3);
  }
  // Battle Royale zone
  if(gameMode==='battleroyale'){
    mmctx.strokeStyle='rgba(255,0,0,0.7)';mmctx.lineWidth=1.5;
    mmctx.beginPath();
    mmctx.arc(brZoneX/CELL*s,brZoneZ/CELL*s,brZoneRadius/CELL*s,0,Math.PI*2);
    mmctx.stroke();
    // Target zone
    mmctx.strokeStyle='rgba(255,255,0,0.4)';mmctx.lineWidth=0.5;mmctx.setLineDash([3,3]);
    mmctx.beginPath();
    mmctx.arc(brZoneX/CELL*s,brZoneZ/CELL*s,brZoneTarget/CELL*s,0,Math.PI*2);
    mmctx.stroke();mmctx.setLineDash([]);
  }
  // Drone position
  if(droneActive){
    mmctx.fillStyle='#0ff';
    mmctx.beginPath();
    mmctx.arc(droneX/CELL*s,droneZ/CELL*s,3,0,Math.PI*2);
    mmctx.fill();
    mmctx.strokeStyle='rgba(0,255,255,0.3)';mmctx.lineWidth=0.5;
    mmctx.beginPath();mmctx.arc(droneX/CELL*s,droneZ/CELL*s,25/CELL*s,0,Math.PI*2);mmctx.stroke();
  }
  // Drone-marked enemies (pulsing)
  for(const e of enemies){
    if(e._droneMarked>0&&e.hp>0){
      const pulse=0.5+0.5*Math.sin(Date.now()*0.01);
      mmctx.strokeStyle=`rgba(0,255,255,${pulse})`;mmctx.lineWidth=1;
      mmctx.beginPath();mmctx.arc(e.x/CELL*s,e.z/CELL*s,4,0,Math.PI*2);mmctx.stroke();
    }
  }
  // Wave Defense point
  if(gameMode==='wavedefense'){
    mmctx.strokeStyle='#0ff';mmctx.lineWidth=1.5;
    mmctx.beginPath();mmctx.arc(wdPoint.x/CELL*s,wdPoint.z/CELL*s,6,0,Math.PI*2);mmctx.stroke();
    mmctx.fillStyle='rgba(0,255,255,0.15)';mmctx.fill();
  }
  // Vehicle
  if(inVehicle){
    mmctx.fillStyle='#0f0';
    mmctx.save();mmctx.translate(vehicleX/CELL*s,vehicleZ/CELL*s);mmctx.rotate(vehicleAngle);
    mmctx.fillRect(-3,-5,6,10);
    mmctx.restore();
  }
  // Player
  const px=player.x/CELL*s, pz=player.z/CELL*s;
  mmctx.fillStyle='#0f0';
  mmctx.save();
  mmctx.translate(px,pz);
  mmctx.rotate(player.yaw);
  mmctx.beginPath();
  mmctx.moveTo(0,-4);
  mmctx.lineTo(-3,3);
  mmctx.lineTo(3,3);
  mmctx.closePath();
  mmctx.fill();
  mmctx.restore();
}

/* ============================================================
   HUD UPDATE
   ============================================================ */
function spawnScreenBlood(count){
  for(let i=0;i<count;i++){
    screenBloodDrops.push({
      x:Math.random(), y:Math.random()*0.3, // top portion of screen
      dy:0.02+Math.random()*0.06, // drip speed
      size:8+Math.random()*25,
      life:2+Math.random()*3, maxLife:5,
      r:0.4+Math.random()*0.5, g:0, b:0,
      stretch:1+Math.random()*2, // vertical elongation (drip shape)
      wobble:Math.random()*Math.PI*2 // slight horizontal drift
    });
  }
}

function drawScreenBlood(dt){
  const sbc=document.getElementById('screenBloodCanvas');
  if(!sbc) return;
  if(screenBloodDrops.length===0){sbc.style.display='none';return;}
  sbc.style.display='block';
  const w=sbc.width=window.innerWidth, h=sbc.height=window.innerHeight;
  const ctx=sbc.getContext('2d');
  ctx.clearRect(0,0,w,h);
  for(let i=screenBloodDrops.length-1;i>=0;i--){
    const d=screenBloodDrops[i];
    d.life-=dt;
    if(d.life<=0){screenBloodDrops.splice(i,1);continue;}
    // Drip downward + slight wobble
    d.y+=d.dy*dt;
    d.x+=Math.sin(d.wobble+d.y*5)*0.001;
    d.stretch=Math.min(4,d.stretch+dt*0.5); // elongate over time
    const alpha=Math.min(1,d.life/1.5)*0.8; // fade out in last 1.5s
    const px=d.x*w, py=d.y*h;
    const sz=d.size;
    // Draw drip: elongated ellipse
    ctx.save();
    ctx.translate(px,py);
    ctx.scale(1,d.stretch);
    ctx.beginPath();
    ctx.arc(0,0,sz,0,Math.PI*2);
    ctx.fillStyle=`rgba(${Math.floor(d.r*255)},${Math.floor(d.g*255)},${Math.floor(d.b*255)},${alpha})`;
    ctx.fill();
    // Darker center
    ctx.beginPath();
    ctx.arc(0,0,sz*0.5,0,Math.PI*2);
    ctx.fillStyle=`rgba(${Math.floor(d.r*180)},0,0,${alpha*0.5})`;
    ctx.fill();
    ctx.restore();
    // Trail drip line
    if(d.stretch>1.5){
      ctx.beginPath();
      ctx.moveTo(px,py);
      ctx.lineTo(px+Math.sin(d.wobble)*2,py+sz*d.stretch*1.5);
      ctx.strokeStyle=`rgba(${Math.floor(d.r*200)},0,0,${alpha*0.4})`;
      ctx.lineWidth=sz*0.3;
      ctx.lineCap='round';
      ctx.stroke();
    }
  }
}

function updateHUD(){
  const mxHp=gameMode==='juggernaut'?500:(MAX_HP+armorBonus);
  document.getElementById('hpFill').style.width=(player.hp/mxHp*100)+'%';
  document.getElementById('hpTxt').textContent=Math.ceil(player.hp)+' / '+mxHp+' HP';

  // Hit marker
  const hm=document.getElementById('hitMarker');
  hm.style.opacity=hitMarkerTimer>0?'1':'0';

  // Headshot text
  const hsEl=document.getElementById('headshotTxt');
  if(hsEl) hsEl.style.opacity=headshotTimer>0?'1':'0';

  // Helmet overlay (blue tint when armor active)
  const helmOv=document.getElementById('helmetOverlay');
  if(helmOv) helmOv.style.display=(armorBonus>0&&gameMode!=='juggernaut')?'block':'none';

  // Juggernaut HUD
  const jugEl=document.getElementById('jugHud');
  if(gameMode==='juggernaut'&&jugEl){
    jugEl.style.display='block';
    jugEl.innerHTML='Волна: '+jugWave+'<br>Убийства: '+jugKills;
  } else if(jugEl) jugEl.style.display='none';

  // Objectives
  if(gameMode==='math'){
    document.getElementById('mathProblem').textContent=mathA+' × '+mathB+' = ?';
    document.getElementById('mathTimer').textContent='Время: '+Math.ceil(mathTimer)+' сек'+(mathFreezeTimer>0?' ❄ '+Math.ceil(mathFreezeTimer)+'с':'');
    document.getElementById('objTxt').innerText='Найди врага с ответом '+mathA+'×'+mathB+'\nУбей его!';
  } else if(gameMode==='juggernaut'){
    const alive=enemies.filter(e=>e.hp>0).length;
    document.getElementById('objTxt').innerText='ДЖАГГЕРНАУТ\nВрагов: '+alive+'\nУбийства: '+jugKills;
  } else if(gameMode==='zombie'){
    const alive=enemies.filter(e=>e.hp>0).length;
    const w=window._zombieWave||1;
    document.getElementById('objTxt').innerText='ЗОМБИ ВОЛНА: '+w+'\nЗомби: '+alive+'\nВыживай!';
  } else if(gameMode==='boss'){
    const boss=enemies.find(e=>e._isBoss);
    const bossHp=boss?Math.max(0,boss.hp):0;
    document.getElementById('objTxt').innerText='ЧЁРНАЯ ОШИБКА\nHP Босса: '+bossHp+'/2000\nУничтожь его!';
  } else {
    const enemiesAlive=enemies.filter(e=>e.hp>0).length;
    const moneyLeft=moneyBags.filter(m=>m.alive).length;
    let obj='';
    if(enemiesAlive>0) obj+=`Уничтожить врагов: ${enemiesAlive} осталось\n`;
    else obj+='Враги уничтожены!\n';
    if(moneyLeft>0) obj+=`Найти деньги: ${moneyLeft} осталось\n`;
    else obj+='Деньги собраны!\n';
    if(evacActive) obj+='Беги к машине (EXIT на миникарте)!';
    else if(allEnemiesDead&&allMoneyCollected) obj+='Эвакуация начинается...';
    document.getElementById('objTxt').innerText=obj;
  }

  // Interaction prompts
  const car=findCar();
  const cdx=player.x-car.x, cdz=player.z-car.z;
  const info=document.getElementById('infoTxt');
  let prompt='';
  // Bag/cuffs prompts — HIGHEST priority
  if(playerBags>0){
    for(const e of enemies){
      if(e.hp<=0 || e.state==='blinded' || e.state==='captured') continue;
      const dx2=player.x-e.x, dz2=player.z-e.z;
      if(dx2*dx2+dz2*dz2<20){prompt='>>> [G] НАДЕТЬ МЕШОК <<<';break;}
    }
  }
  if(!prompt && playerCuffs>0){
    for(const e of enemies){
      if(e.state!=='blinded') continue;
      const dx2=player.x-e.x, dz2=player.z-e.z;
      if(dx2*dx2+dz2*dz2<20){prompt='>>> [G] НАДЕТЬ НАРУЧНИКИ <<<';break;}
    }
  }
  if(!prompt){
    if(evacActive && cdx*cdx+cdz*cdz<16){
      prompt='Подойди ближе к машине для эвакуации!';
    } else {
      for(const m of moneyBags){
        if(!m.alive) continue;
        const dx2=player.x-m.x, dz2=player.z-m.z;
        if(dx2*dx2+dz2*dz2<9){prompt='Подойди ближе чтобы подобрать деньги';break;}
      }
      if(!prompt){
        for(const e of enemies){
          if(e.hp>0 || e.looted) continue;
          const dx2=player.x-e.x, dz2=player.z-e.z;
          if(dx2*dx2+dz2*dz2<6){prompt='[F] Обыскать труп';break;}
        }
      }
      if(!prompt){
        for(const a of allies){
          const dx2=player.x-a.x, dz2=player.z-a.z;
          if(dx2*dx2+dz2*dz2<6){
            if(a.hp<=0 && playerMedkits>0){prompt='[F] Оживить '+a.name+' (аптечка)';break;}
            else if(a.hp>0 && a.hp<a.maxHp && playerMedkits>0){prompt='[F] Вылечить '+a.name+' ('+Math.ceil(a.hp)+' HP)';break;}
          }
        }
      }
      // Door prompt
      if(!prompt){
        for(const door of doors){
          const dd=Math.sqrt((player.x-door.x)**2+(player.z-door.z)**2);
          if(dd<3){prompt='[F] '+(door.open?'Закрыть':'Открыть')+' дверь';break;}
        }
      }
    }
  }
  info.style.display=prompt?'block':'none';
  info.textContent=prompt;
  // Crouch/ADS/Sprint/Lean indicators
  const status=[];
  if(player.crouching) status.push('ПРИСЕЛ');
  if(player.ads) status.push('ПРИЦЕЛ');
  if(player.sprinting) status.push('БЕГ');
  if(leanAmount<-0.3) status.push('← НАКЛОН');
  else if(leanAmount>0.3) status.push('НАКЛОН →');
  const wpName=(WEAPONS[currentWeapon]||WEAPONS[0]).name;
  document.getElementById('ammoTxt').textContent=wpName+' | '+ammo+' / '+reserveAmmo+(status.length?' ['+status.join(' ')+']':'');
  // Weapon HUD
  const wHud=document.getElementById('weaponHud');
  if(wHud){
    let wt='[1]'+WEAPONS[0].name;
    if(hasShotgun) wt+=' [2]'+WEAPONS[1].name;
    if(hasPistol) wt+=' [3]'+WEAPONS[2].name;
    if(hasSniper) wt+=' [4]'+WEAPONS[3].name;
    if(hasGlitchWeapon) wt+=' [5]Глитч';
    if(player&&hasGravGun) wt+=' [6]Грав';
    wHud.textContent=wt;
    wHud.style.display=(hasShotgun||hasPistol||hasSniper||hasGlitchWeapon||(player&&hasGravGun))?'block':'none';
  }
  // XP bar
  const xpHud=document.getElementById('xpHud');
  if(xpHud){
    const xpNeeded=XP_PER_LEVEL*playerLevel;
    const xpPct=Math.min(100,playerXP/xpNeeded*100);
    document.getElementById('xpFill').style.width=xpPct+'%';
    document.getElementById('xpTxt').textContent='Ур.'+playerLevel+' '+playerXP+'/'+xpNeeded;
    xpHud.style.display='block';
  }
  // Shield HUD
  const shHud=document.getElementById('shieldHud');
  if(shHud){
    if(hasShield){shHud.style.display='block';shHud.textContent='Щит: '+Math.ceil(shieldHP)+'/200'+(shieldActive?' АКТИВЕН':'');}
    else shHud.style.display='none';
  }
  // Bullet time bar
  const btBar=document.getElementById('bulletTimeBar');
  const btFill=document.getElementById('bulletTimeFill');
  if(btBar&&btFill){
    if(hasBulletTime){
      btBar.style.display='block';
      if(bulletTimeLeft>0){btFill.style.width=(bulletTimeLeft/3*100)+'%';btFill.style.background='#0ff';}
      else if(bulletTimeCd>0){btFill.style.width=((1-bulletTimeCd/10)*100)+'%';btFill.style.background='#888';}
      else{btFill.style.width='100%';btFill.style.background='#0f0';}
    } else btBar.style.display='none';
  }
  // Stealth HUD
  // Neon mode indicator
  const nOv=document.getElementById('neonOverlay');
  if(nOv) nOv.style.display=neonMode?'block':'none';
  // Night vision
  const nvOv=document.getElementById('nightVisionOverlay');
  if(nvOv) nvOv.style.display=nightVision?'block':'none';
  // Flashlight indicator
  if(hasFlashlight && flashlightOn){
    // Show flashlight cone as a canvas effect below
  }
  // Stamina bar
  const stBar=document.getElementById('staminaBar');
  const stFill=document.getElementById('staminaFill');
  if(player.stamina<STAMINA_MAX){stBar.style.display='block';stFill.style.width=(player.stamina/STAMINA_MAX*100)+'%';}
  else stBar.style.display='none';
  // Medkit indicator + bags/cuffs
  const medEl=document.getElementById('medkitTxt');
  let medTxt='';
  if(playerMedkits>0) medTxt+='[H] Аптечка: '+playerMedkits;
  if(playerBags>0) medTxt+=(medTxt?'  ':'')+' Мешок: '+playerBags;
  if(playerCuffs>0) medTxt+=(medTxt?'  ':'')+' Наручники: '+playerCuffs;
  if(playerGrenades>0) medTxt+=(medTxt?'  ':'')+' [T] Граната: '+playerGrenades;
  if(capturedEnemy && capturedEnemy.hp>0) medTxt+=(medTxt?'  ':'')+'ПЛЕННЫЙ';
  if(medTxt){medEl.style.display='block';medEl.textContent=medTxt;}
  else medEl.style.display='none';
  // Scope overlay
  const scopeEl=document.getElementById('scopeOverlay');
  const crossEl=document.getElementById('crosshair');
  if(player.ads){
    scopeEl.style.display='block';
    crossEl.style.display='none';
    drawScope();
  } else {
    scopeEl.style.display='none';
    crossEl.style.display='';
  }
  // Ally name labels (3D projected to screen)
  const alc=document.getElementById('allyLabels');
  if(alc && state==='playing'){
    const vp=_lastVP; // stored from render()
    let html='';
    if(vp){
      for(const a of allies){
        const wx=a.x, wy=2.1, wz=a.z;
        const cx=vp[0]*wx+vp[4]*wy+vp[8]*wz+vp[12];
        const cy=vp[1]*wx+vp[5]*wy+vp[9]*wz+vp[13];
        const cw=vp[3]*wx+vp[7]*wy+vp[11]*wz+vp[15];
        if(cw<=0.1) continue; // behind camera
        const nx=cx/cw, ny=cy/cw;
        const sx=(nx+1)*0.5*canvas.width;
        const sy=(1-ny)*0.5*canvas.height;
        if(sx<-50||sx>canvas.width+50||sy<-50||sy>canvas.height+50) continue;
        const dist=Math.sqrt((a.x-player.x)**2+(a.z-player.z)**2);
        if(dist>40) continue;
        const cls=a.hp<=0?'dead':a.role;
        const hpPct=Math.max(0,Math.ceil(a.hp/a.maxHp*100));
        const roleTag=a.role==='medic'?' МЕДИК':a.role==='dumb'?'':' ЗАЩИТНИК';
        const stateTag=a.state==='heal'?' (лечит)':a.state==='combat'?' (бой)':'';
        html+='<div class="allyLabel '+cls+'" style="left:'+sx+'px;top:'+sy+'px">'+
          a.name+roleTag+(a.hp<=0?' МЕРТВ':stateTag)+
          '<div class="allyHpBar"><div class="allyHpFill" style="width:'+hpPct+'%"></div></div></div>';
      }
      // Math mode: numbers above enemy heads
      if(gameMode==='math'){
        for(const e of enemies){
          if(e.hp<=0 || e._mathAnswer===undefined) continue;
          const wx=e.x, wy=2.2, wz=e.z;
          const cx=vp[0]*wx+vp[4]*wy+vp[8]*wz+vp[12];
          const cy=vp[1]*wx+vp[5]*wy+vp[9]*wz+vp[13];
          const cw=vp[3]*wx+vp[7]*wy+vp[11]*wz+vp[15];
          if(cw<=0.1) continue;
          const nx2=cx/cw, ny2=cy/cw;
          const sx2=(nx2+1)*0.5*canvas.width;
          const sy2=(1-ny2)*0.5*canvas.height;
          if(sx2<-50||sx2>canvas.width+50||sy2<-50||sy2>canvas.height+50) continue;
          const dist2=Math.sqrt((e.x-player.x)**2+(e.z-player.z)**2);
          if(dist2>50) continue;
          const fontSize=Math.max(16,Math.min(48,200/dist2));
          html+='<div style="position:absolute;left:'+sx2+'px;top:'+sy2+'px;transform:translateX(-50%);'+
            'font-size:'+fontSize+'px;color:#fff;font-family:Courier New,monospace;font-weight:bold;'+
            'text-shadow:0 0 10px #0ff,0 0 20px #08f,0 2px 4px #000;pointer-events:none">'+
            e._mathAnswer+'</div>';
        }
      }
    }
    alc.innerHTML=html;
  }

  // Drone HUD
  const droneHudEl=document.getElementById('droneHud');
  const droneOvEl=document.getElementById('droneOverlay');
  if(droneActive){
    if(droneHudEl){droneHudEl.style.display='block';droneHudEl.textContent='ДРОН | Батарея: '+Math.ceil(droneBattery)+'с | WASD двигать | V выйти';}
    if(droneOvEl) droneOvEl.style.display='block';
  } else {
    if(droneHudEl) droneHudEl.style.display='none';
    if(droneOvEl) droneOvEl.style.display='none';
  }
  // Wound HUD
  const wHudEl=document.getElementById('woundHud');
  if(wHudEl){
    let wt='';
    if(woundLeg) wt+='ХРОМОТА ('+Math.ceil(woundLegTimer)+'с)\n';
    if(woundArm) wt+='РУКА РАНЕНА ('+Math.ceil(woundArmTimer)+'с)\n';
    if(woundBleed) wt+='КРОВОТЕЧЕНИЕ ('+Math.ceil(woundBleedTimer)+'с)';
    wHudEl.style.display=wt?'block':'none';
    wHudEl.textContent=wt;
  }
  // Equipment HUD
  const eqHudEl=document.getElementById('equipHud');
  if(eqHudEl){
    let et='';
    if(hasEquipHelmet) et+='Каска: '+Math.ceil(equipHelmet)+'HP ';
    if(hasEquipVest) et+='Жилет: '+Math.ceil(equipVest)+'HP ';
    if(hasEquipKnees) et+='Колени: '+Math.ceil(equipKnees)+'HP';
    eqHudEl.style.display=et?'block':'none';
    eqHudEl.textContent=et;
  }
  // Mine indicator
  const mineEl=document.getElementById('mineIndicator');
  if(mineEl){
    if(playerMines>0){mineEl.style.display='block';mineEl.textContent='[C] Мины: '+playerMines+' ('+mines.filter(m=>!m.exploded).length+'/'+maxMines+')';}
    else mineEl.style.display='none';
  }
  // Zone warning (Battle Royale)
  const zwEl=document.getElementById('zoneWarning');
  if(zwEl){
    if(gameMode==='battleroyale'){
      const dx=player.x-brZoneX,dz=player.z-brZoneZ;
      const dist=Math.sqrt(dx*dx+dz*dz);
      zwEl.style.display=dist>brZoneRadius?'block':'none';
    } else zwEl.style.display='none';
  }
  // Weather HUD
  const wthEl=document.getElementById('weatherHud');
  if(wthEl){
    const wNames={clear:'',fog:'ТУМАН',blizzard:'МЕТЕЛЬ',sandstorm:'ПЕСЧ. БУРЯ'};
    const wn=wNames[weatherType]||'';
    wthEl.style.display=wn?'block':'none';
    wthEl.textContent=wn;
  }
  // Gravity gun HUD
  const ggEl=document.getElementById('gravGunHud');
  if(ggEl){
    if(currentWeapon===5&&hasGravGun){ggEl.style.display='block';ggEl.textContent='ГРАВ-ПУШКА'+(gravHolding?' [УДЕРЖ]':' [ПКМ хват]');}
    else ggEl.style.display='none';
  }
  // Battle Royale / Wave Defense / Infection objectives
  if(gameMode==='battleroyale'){
    const alive=enemies.filter(e=>e.hp>0).length;
    document.getElementById('objTxt').innerText='КОРОЛЕВСКАЯ БИТВА\nФаза: '+(brPhase+1)+'\nВрагов: '+alive+'\nЗона сужается: '+Math.ceil(brShrinkTimer)+'с';
    if(alive===0){
      state='win';playSound('win');
      document.getElementById('winScreen').style.display='flex';
      document.getElementById('winScreen').querySelector('p').textContent='Все враги уничтожены!\nПобеда!';
      try{document.exitPointerLock();}catch(ex){}
    }
  }
  if(gameMode==='wavedefense'){
    const alive=enemies.filter(e=>e.hp>0).length;
    document.getElementById('objTxt').innerText='ВОЛНА ОБОРОНЫ\nВолна: '+wdWave+'/5\nВрагов: '+alive+'\nТочка HP: '+Math.ceil(wdPointHP);
    if(wdPointHP<=0){state='dead';playSound('death');document.getElementById('deathScreen').style.display='flex';document.getElementById('deathScreen').querySelector('p').textContent='Точка захвачена! Оборона провалена.';try{document.exitPointerLock();}catch(ex){}}
  }
  if(gameMode==='infection'){
    const zombies=enemies.filter(e=>e.hp>0&&e._infected).length;
    const humans=enemies.filter(e=>e.hp>0&&!e._infected).length;
    document.getElementById('objTxt').innerText='ЗАРАЖЕНИЕ\nЗомби: '+zombies+' | Люди: '+humans+'\nВремя: '+Math.ceil(infectionTimer)+'с\nВыживи!';
  }
  // Camera view
  if(cameraViewActive&&cameras.length>0&&cameras[cameraViewIndex]&&cameras[cameraViewIndex].alive){
    // Show camera view indicator
    document.getElementById('bodycamId').textContent='CAM-'+(cameraViewIndex+1)+' [Tab переключить]';
  }
  // Vehicle HUD
  if(inVehicle){
    document.getElementById('ammoTxt').textContent='ТРАНСПОРТ | '+Math.ceil(Math.abs(vehicleSpeed))+' км/ч | [F] выйти';
  }
  // Akimbo indicator
  if(akimboActive){
    const s2=status||[];s2.push('AKIMBO');
    document.getElementById('ammoTxt').textContent+=' [AKIMBO]';
  }
  // Parkour indicators
  if(wallRunning){document.getElementById('ammoTxt').textContent+=' [WALL RUN]';}
  if(isSliding){document.getElementById('ammoTxt').textContent+=' [SLIDE]';}
  // Ally command indicator
  const cmdNames={follow:'За мной',hold:'Стой',attack:'Атакуй',heal:'Лечи'};
  if(allies.length>0&&allyCommandMode!=='follow'){document.getElementById('ammoTxt').textContent+=' Приказ: '+cmdNames[allyCommandMode];}
  // Bodycam timestamp
  const bcTime=document.getElementById('bodycamTime');
  if(bcTime){
    const now=new Date();
    const pad=n=>String(n).padStart(2,'0');
    bcTime.textContent=pad(now.getHours())+':'+pad(now.getMinutes())+':'+pad(now.getSeconds())+' '+pad(now.getDate())+'.'+pad(now.getMonth()+1)+'.'+now.getFullYear();
  }
}

/* ============================================================
   SCOPE OVERLAY
   ============================================================ */
const scopeCanv=document.getElementById('scopeCanvas');
const sctx=scopeCanv.getContext('2d');
function drawScope(){
  const w=scopeCanv.width=window.innerWidth, h=scopeCanv.height=window.innerHeight;
  sctx.clearRect(0,0,w,h);
  const cx=w/2, cy=h/2;
  const r=Math.min(w,h)*0.38; // scope radius

  // Black mask outside scope circle
  sctx.fillStyle='#000';
  sctx.fillRect(0,0,w,h);
  sctx.globalCompositeOperation='destination-out';
  sctx.beginPath();sctx.arc(cx,cy,r,0,Math.PI*2);sctx.fill();
  sctx.globalCompositeOperation='source-over';

  // Scope ring (outer dark border)
  sctx.strokeStyle='#111';sctx.lineWidth=6;
  sctx.beginPath();sctx.arc(cx,cy,r,0,Math.PI*2);sctx.stroke();
  sctx.strokeStyle='#333';sctx.lineWidth=2;
  sctx.beginPath();sctx.arc(cx,cy,r-3,0,Math.PI*2);sctx.stroke();

  // Inner scope ring (lens edge)
  sctx.strokeStyle='rgba(100,200,255,0.15)';sctx.lineWidth=1;
  sctx.beginPath();sctx.arc(cx,cy,r-6,0,Math.PI*2);sctx.stroke();

  // Crosshair lines (thin, red/green dual)
  sctx.strokeStyle='rgba(0,255,0,0.8)';sctx.lineWidth=1;
  // Horizontal
  sctx.beginPath();sctx.moveTo(cx-r+20,cy);sctx.lineTo(cx-12,cy);sctx.stroke();
  sctx.beginPath();sctx.moveTo(cx+12,cy);sctx.lineTo(cx+r-20,cy);sctx.stroke();
  // Vertical
  sctx.beginPath();sctx.moveTo(cx,cy-r+20);sctx.lineTo(cx,cy-12);sctx.stroke();
  sctx.beginPath();sctx.moveTo(cx,cy+12);sctx.lineTo(cx,cy+r-20);sctx.stroke();

  // Center dot
  sctx.fillStyle='rgba(255,0,0,0.9)';
  sctx.beginPath();sctx.arc(cx,cy,2.5,0,Math.PI*2);sctx.fill();

  // Range markers (small ticks on vertical line)
  sctx.strokeStyle='rgba(0,255,0,0.5)';sctx.lineWidth=1;
  for(let i=1;i<=4;i++){
    const dy=i*30;
    sctx.beginPath();sctx.moveTo(cx-6,cy+dy);sctx.lineTo(cx+6,cy+dy);sctx.stroke();
    // Range numbers
    sctx.fillStyle='rgba(0,255,0,0.4)';sctx.font='8px monospace';
    sctx.fillText(i*100+'',cx+9,cy+dy+3);
  }

  // Chevron marks on horizontal line
  for(let i=1;i<=3;i++){
    const dx=i*40;
    sctx.beginPath();sctx.moveTo(cx-dx,cy-4);sctx.lineTo(cx-dx,cy+4);sctx.stroke();
    sctx.beginPath();sctx.moveTo(cx+dx,cy-4);sctx.lineTo(cx+dx,cy+4);sctx.stroke();
  }

  // Subtle lens tint
  const grad=sctx.createRadialGradient(cx,cy,0,cx,cy,r);
  grad.addColorStop(0,'rgba(0,20,40,0)');
  grad.addColorStop(0.85,'rgba(0,10,30,0.08)');
  grad.addColorStop(1,'rgba(0,0,0,0.2)');
  sctx.fillStyle=grad;
  sctx.beginPath();sctx.arc(cx,cy,r-4,0,Math.PI*2);sctx.fill();

  // Lens reflection highlight (top-left)
  const refGrad=sctx.createRadialGradient(cx-r*0.3,cy-r*0.3,0,cx-r*0.3,cy-r*0.3,r*0.5);
  refGrad.addColorStop(0,'rgba(150,200,255,0.06)');
  refGrad.addColorStop(1,'rgba(0,0,0,0)');
  sctx.fillStyle=refGrad;
  sctx.beginPath();sctx.arc(cx,cy,r-4,0,Math.PI*2);sctx.fill();
}

/* ============================================================
   INPUT
   ============================================================ */
document.addEventListener('keydown', e=>{
  keys[e.code]=true;
  if(state==='playing' && ['KeyW','KeyA','KeyS','KeyD','Space','KeyR','KeyQ','KeyE','KeyF','KeyG','KeyH','KeyV','KeyC','KeyB','KeyM','KeyX','Tab','F5','ControlLeft','ControlRight','ShiftLeft','ShiftRight'].includes(e.code)) e.preventDefault();
  if(e.code==='F5'&&state==='playing'){thirdPersonCam=!thirdPersonCam;}
  if(e.code==='F1'){e.preventDefault();window.open('help.html','_blank');}
});
document.addEventListener('keyup', e=>{keys[e.code]=false;});
document.addEventListener('mousedown', e=>{
  if(e.button===0) mouseDown=true;
  if(e.button===2) mouseRightDown=true;
  if(state==='playing' && !document.pointerLockElement) canvas.requestPointerLock();
});
document.addEventListener('mouseup', e=>{if(e.button===0) mouseDown=false;if(e.button===2) mouseRightDown=false;});
document.addEventListener('mousemove', e=>{
  if(document.pointerLockElement===canvas && state==='playing'){
    const sens=MOUSE_SENS*(player.ads?0.25:1);
    player.yaw+=e.movementX*sens;
    player.pitch-=e.movementY*sens;
    player.pitch=Math.max(-1.4,Math.min(1.4,player.pitch));
  }
});
document.addEventListener('contextmenu', e=>e.preventDefault());

/* ============================================================
   GAME CONTROL
   ============================================================ */
const game = {
  start(){
    try { initAudio(); } catch(e){ console.warn('Audio init failed:', e); }
    gameMode='normal';
    initGame();
    state='playing';
    document.getElementById('menuScreen').style.display='none';
    document.getElementById('settingsScreen').style.display='none';
    try { canvas.requestPointerLock(); } catch(e){ console.warn('Pointer lock failed:', e); }
  },
  startJuggernaut(){
    try { initAudio(); } catch(e){ console.warn('Audio init failed:', e); }
    gameMode='juggernaut';
    initJuggernaut();
    state='playing';
    document.getElementById('menuScreen').style.display='none';
    document.getElementById('settingsScreen').style.display='none';
    try { canvas.requestPointerLock(); } catch(e){ console.warn('Pointer lock failed:', e); }
  },
  startMath(){
    try { initAudio(); } catch(e){ console.warn('Audio init failed:', e); }
    gameMode='math';
    initMathMode();
    state='playing';
    document.getElementById('menuScreen').style.display='none';
    document.getElementById('settingsScreen').style.display='none';
    document.getElementById('mathHud').style.display='block';
    try { canvas.requestPointerLock(); } catch(e){ console.warn('Pointer lock failed:', e); }
  },
  startZombie(){
    try { initAudio(); } catch(e){}
    gameMode='zombie'; initZombieMode(); state='playing';
    document.getElementById('menuScreen').style.display='none';
    try { canvas.requestPointerLock(); } catch(e){}
  },
  startBattleRoyale(){
    try { initAudio(); } catch(e){}
    gameMode='battleroyale'; initBattleRoyale(); state='playing';
    document.getElementById('menuScreen').style.display='none';
    spawnCameras();
    try { canvas.requestPointerLock(); } catch(e){}
  },
  startWaveDefense(){
    try { initAudio(); } catch(e){}
    gameMode='wavedefense'; initWaveDefense(); state='playing';
    document.getElementById('menuScreen').style.display='none';
    spawnCameras();
    try { canvas.requestPointerLock(); } catch(e){}
  },
  startInfection(){
    try { initAudio(); } catch(e){}
    gameMode='infection'; initInfection(); state='playing';
    document.getElementById('menuScreen').style.display='none';
    try { canvas.requestPointerLock(); } catch(e){}
  },
  restart(){
    if(gameMode==='math') initMathMode();
    else if(gameMode==='juggernaut') initJuggernaut();
    else if(gameMode==='zombie') initZombieMode();
    else if(gameMode==='boss') initBossMode();
    else if(gameMode==='battleroyale') initBattleRoyale();
    else if(gameMode==='wavedefense') initWaveDefense();
    else if(gameMode==='infection') initInfection();
    else initGame();
    // Reset new feature states
    droneActive=false;inVehicle=false;cameraViewActive=false;commandWheelOpen=false;
    woundLeg=false;woundArm=false;woundBleed=false;isSliding=false;wallRunning=false;
    gravHolding=null;mines.length=0;cameras.length=0;weatherType='clear';weatherTimer=20;
    state='playing';
    document.getElementById('deathScreen').style.display='none';
    document.getElementById('winScreen').style.display='none';
    document.getElementById('shopScreen').style.display='none';
    document.getElementById('tradeScreen').style.display='none';
    document.getElementById('timerTxt').style.display='none';
    document.getElementById('bloodOverlay').style.opacity='0';
    document.getElementById('deathScreen').querySelector('p').textContent='Ты умер от выстрелов, машина уехала и оставила тебя помирать';
    document.getElementById('deathKills').style.display='none';
    document.getElementById('mathHud').style.display=gameMode==='math'?'block':'none';
    try { canvas.requestPointerLock(); } catch(e){ console.warn('Pointer lock failed:', e); }
  },
  toMenu(){
    state='menu';
    gameMode='normal';
    skeletonMode=false; thirdPersonCam=false;
    document.getElementById('deathScreen').style.display='none';
    document.getElementById('winScreen').style.display='none';
    document.getElementById('shopScreen').style.display='none';
    document.getElementById('tradeScreen').style.display='none';
    document.getElementById('settingsScreen').style.display='none';
    document.getElementById('timerTxt').style.display='none';
    document.getElementById('bloodOverlay').style.opacity='0';
    document.getElementById('deathScreen').querySelector('p').textContent='Ты умер от выстрелов, машина уехала и оставила тебя помирать';
    document.getElementById('deathKills').style.display='none';
    document.getElementById('mathHud').style.display='none';
    document.getElementById('nightVisionOverlay').style.display='none';
    document.getElementById('neonOverlay').style.display='none';
    document.getElementById('rainCanvas').style.display='none';
    currentWeapon=0;
    droneActive=false;inVehicle=false;cameraViewActive=false;commandWheelOpen=false;
    woundLeg=false;woundArm=false;woundBleed=false;isSliding=false;wallRunning=false;
    gravHolding=null;mines.length=0;cameras.length=0;weatherType='clear';weatherFogMult=1;weatherSpeedMult=1;
    document.getElementById('commandWheel').style.display='none';
    document.getElementById('droneOverlay').style.display='none';
    document.getElementById('droneHud').style.display='none';
    document.getElementById('mapEditorScreen').style.display='none';
    gl.clearColor(0.05,0.05,0.12,1); // reset clear color from boss mode
    document.getElementById('menuScreen').style.display='flex';
    updateShopCoins();
    if(jugUnlocked) document.getElementById('btnJuggernaut').style.display='inline-block';
    try { document.exitPointerLock(); } catch(e){}
  }
};

function updateShopCoins(){
  const t='Монеты: '+playerCoins;
  ['menuCoins','shopCoins','tradeCoins'].forEach(id=>{const el=document.getElementById(id);if(el)el.textContent=t;});
}
function openShop(){
  document.getElementById('menuScreen').style.display='none';
  document.getElementById('shopScreen').style.display='flex';
  document.getElementById('shopMsg').textContent='';
  updateShopCoins();
  const ad=document.getElementById('armorDesc');
  if(ad) ad.textContent=jugUnlocked?'+50 макс HP':'+50 макс HP ('+armorBuyCount+'/5 до Джаггернаута)';
  // Show glitch weapon if boss defeated
  const ge=document.getElementById('buy_glitch');
  if(ge) ge.style.display=bossDefeated?'block':'none';
}
function openTrade(){
  document.getElementById('menuScreen').style.display='none';
  document.getElementById('tradeScreen').style.display='flex';
  document.getElementById('tradeMsg').textContent='';
  updateShopCoins();
  const ti=document.getElementById('tradeItems');
  const sb=document.getElementById('btnSellAll');
  if(lootCount>0){
    ti.innerHTML='<p style="color:#ff0;font-size:16px">Оружие врагов: <b>'+lootCount+'</b> шт.<br>Стоимость: <b>'+lootCount*8+'</b> монет</p>';
    sb.style.display='inline-block';
  } else {
    ti.innerHTML='<p style="color:#888">Нет лута. Обыскивай трупы [F] в бою!</p>';
    sb.style.display='none';
  }
}
function buyItem(id){
  const items={ammo:{price:5,msg:'Патроны +60'},medkit:{price:10,msg:'Аптечка куплена'},armor:{price:15,msg:'Броня +50 HP'},weapon:{price:25,msg:'Урон улучшен!'},bag:{price:8,msg:'Мешок куплен'},cuffs:{price:12,msg:'Наручники куплены'},double:{price:15,msg:'Двойная награда активирована!'},freeze:{price:12,msg:'Заморозка куплена!'},grenade:{price:10,msg:'Гранаты +3'},pierce:{price:20,msg:'Бронебойные активированы!'},gold:{price:50,msg:'Золотой скин!'},camo:{price:15,msg:'Камуфляж активирован!'},shotgun:{price:30,msg:'Дробовик куплен! [2]'},pistol:{price:10,msg:'Пистолет куплен! [3]'},sniper:{price:40,msg:'Снайперка куплена! [4]'},shield:{price:20,msg:'Щит куплен!'},bullettime:{price:15,msg:'Замедление куплено! [Z]'},nvg:{price:18,msg:'Ночное зрение! [N]'},flashlight:{price:8,msg:'Фонарик куплен! [F+удерж]'},glitch:{price:500,msg:'Глитч-пушка куплена! [5]'},mine:{price:12,msg:'Мины +3! [C]'},akimbo:{price:25,msg:'Двойные пистолеты! [M]'},eqhelmet:{price:20,msg:'Каска куплена!'},eqvest:{price:25,msg:'Бронежилет куплен!'},eqknees:{price:15,msg:'Наколенники куплены!'},drone:{price:30,msg:'Дрон куплен! [V]'},gravgun:{price:35,msg:'Грав-пушка! [6]'}};
  const it=items[id];if(!it)return;
  if(playerCoins<it.price){
    document.getElementById('shopMsg').textContent='Недостаточно монет!';
    document.getElementById('shopMsg').style.color='#f44';return;
  }
  playerCoins-=it.price;
  if(id==='ammo')reserveAmmo+=60;
  if(id==='medkit')playerMedkits++;
  if(id==='armor'){armorBonus+=50;armorBuyCount++;if(armorBuyCount>=5&&!jugUnlocked){jugUnlocked=true;document.getElementById('shopMsg').textContent='ДЖАГГЕРНАУТ РАЗБЛОКИРОВАН!';document.getElementById('shopMsg').style.color='#fa0';document.getElementById('btnJuggernaut').style.display='inline-block';updateShopCoins();return;}}
  if(id==='weapon')weaponBonus+=15;
  if(id==='bag')playerBags++;
  if(id==='cuffs')playerCuffs++;
  if(id==='double'){if(mathDoubleReward){document.getElementById('shopMsg').textContent='Уже активировано!';document.getElementById('shopMsg').style.color='#fa0';playerCoins+=it.price;updateShopCoins();return;}mathDoubleReward=true;}
  if(id==='freeze'){if(mathFreezeTimer>0){document.getElementById('shopMsg').textContent='Уже куплено!';document.getElementById('shopMsg').style.color='#fa0';playerCoins+=it.price;updateShopCoins();return;}mathFreezeTimer=15;}
  if(id==='grenade')playerGrenades+=3;
  if(id==='pierce'){if(armorPiercing){document.getElementById('shopMsg').textContent='Уже активировано!';document.getElementById('shopMsg').style.color='#fa0';playerCoins+=it.price;updateShopCoins();return;}armorPiercing=true;}
  if(id==='gold'){if(goldSkin){document.getElementById('shopMsg').textContent='Уже куплено!';document.getElementById('shopMsg').style.color='#fa0';playerCoins+=it.price;updateShopCoins();return;}goldSkin=true;}
  if(id==='camo'){if(enemyCamo){document.getElementById('shopMsg').textContent='Уже куплено!';document.getElementById('shopMsg').style.color='#fa0';playerCoins+=it.price;updateShopCoins();return;}enemyCamo=true;}
  if(id==='shotgun'){if(hasShotgun){document.getElementById('shopMsg').textContent='Уже есть!';document.getElementById('shopMsg').style.color='#fa0';playerCoins+=it.price;updateShopCoins();return;}hasShotgun=true;}
  if(id==='pistol'){if(hasPistol){document.getElementById('shopMsg').textContent='Уже есть!';document.getElementById('shopMsg').style.color='#fa0';playerCoins+=it.price;updateShopCoins();return;}hasPistol=true;}
  if(id==='sniper'){if(hasSniper){document.getElementById('shopMsg').textContent='Уже есть!';document.getElementById('shopMsg').style.color='#fa0';playerCoins+=it.price;updateShopCoins();return;}hasSniper=true;}
  if(id==='shield'){if(hasShield){document.getElementById('shopMsg').textContent='Уже есть!';document.getElementById('shopMsg').style.color='#fa0';playerCoins+=it.price;updateShopCoins();return;}hasShield=true;shieldHP=200;}
  if(id==='bullettime'){if(hasBulletTime){document.getElementById('shopMsg').textContent='Уже есть!';document.getElementById('shopMsg').style.color='#fa0';playerCoins+=it.price;updateShopCoins();return;}hasBulletTime=true;}
  if(id==='nvg'){if(hasNightVision){document.getElementById('shopMsg').textContent='Уже есть!';document.getElementById('shopMsg').style.color='#fa0';playerCoins+=it.price;updateShopCoins();return;}hasNightVision=true;}
  if(id==='flashlight'){if(hasFlashlight){document.getElementById('shopMsg').textContent='Уже есть!';document.getElementById('shopMsg').style.color='#fa0';playerCoins+=it.price;updateShopCoins();return;}hasFlashlight=true;}
  if(id==='glitch'){if(hasGlitchWeapon&&currentWeapon===4){document.getElementById('shopMsg').textContent='Уже есть!';document.getElementById('shopMsg').style.color='#fa0';playerCoins+=it.price;updateShopCoins();return;}hasGlitchWeapon=true;}
  if(id==='mine')playerMines+=3;
  if(id==='akimbo'){if(hasAkimbo){document.getElementById('shopMsg').textContent='Уже есть!';document.getElementById('shopMsg').style.color='#fa0';playerCoins+=it.price;updateShopCoins();return;}hasAkimbo=true;if(!hasPistol)hasPistol=true;}
  if(id==='eqhelmet'){hasEquipHelmet=true;equipHelmet=100;}
  if(id==='eqvest'){hasEquipVest=true;equipVest=150;}
  if(id==='eqknees'){hasEquipKnees=true;equipKnees=80;}
  if(id==='drone'){hasDrone=true;}
  if(id==='gravgun'){hasGravGun=true;if(!WEAPONS[5])WEAPONS[5]={name:'Грав-пушка',mag:999,reserve:0,reload:0,firerate:0.5,dmg:0,spread:0,pellets:0,zoom:0};}
  document.getElementById('shopMsg').textContent=it.msg;
  document.getElementById('shopMsg').style.color='#0f0';
  updateShopCoins();
}
function sellAll(){
  if(lootCount<=0)return;
  const earned=lootCount*8;
  playerCoins+=earned;
  document.getElementById('tradeMsg').textContent='Продано! +'+earned+' монет';
  lootCount=0;
  updateShopCoins();
  openTrade();
}

document.getElementById('btnStart').addEventListener('click',()=>{updateShopCoins();game.start();});
document.getElementById('btnRetry').addEventListener('click',()=>{updateShopCoins();game.restart();});
document.getElementById('btnNext').addEventListener('click',()=>{updateShopCoins();game.restart();});
document.getElementById('btnDeathMenu').addEventListener('click',()=>{game.toMenu();});
document.getElementById('btnWinMenu').addEventListener('click',()=>{game.toMenu();});
document.getElementById('btnJuggernaut').addEventListener('click',()=>{updateShopCoins();game.startJuggernaut();});
document.getElementById('btnMath').addEventListener('click',()=>{updateShopCoins();game.startMath();});
document.getElementById('btnZombie').addEventListener('click',()=>{updateShopCoins();game.startZombie();});
document.getElementById('btnBattleRoyale').addEventListener('click',()=>{updateShopCoins();game.startBattleRoyale();});
document.getElementById('btnWaveDefense').addEventListener('click',()=>{updateShopCoins();game.startWaveDefense();});
document.getElementById('btnInfection').addEventListener('click',()=>{updateShopCoins();game.startInfection();});
document.getElementById('btnShop').addEventListener('click',openShop);
document.getElementById('btnTrade').addEventListener('click',openTrade);
document.getElementById('btnShopBack').addEventListener('click',()=>{document.getElementById('shopScreen').style.display='none';document.getElementById('menuScreen').style.display='flex';updateShopCoins();});
document.getElementById('btnTradeBack').addEventListener('click',()=>{document.getElementById('tradeScreen').style.display='none';document.getElementById('menuScreen').style.display='flex';updateShopCoins();});
document.getElementById('btnSellAll').addEventListener('click',sellAll);
document.getElementById('buy_ammo').addEventListener('click',()=>buyItem('ammo'));
document.getElementById('buy_medkit').addEventListener('click',()=>buyItem('medkit'));
document.getElementById('buy_armor').addEventListener('click',()=>buyItem('armor'));
document.getElementById('buy_weapon').addEventListener('click',()=>buyItem('weapon'));
document.getElementById('buy_bag').addEventListener('click',()=>buyItem('bag'));
document.getElementById('buy_cuffs').addEventListener('click',()=>buyItem('cuffs'));
document.getElementById('buy_double').addEventListener('click',()=>buyItem('double'));
document.getElementById('buy_freeze').addEventListener('click',()=>buyItem('freeze'));
document.getElementById('buy_grenade').addEventListener('click',()=>buyItem('grenade'));
document.getElementById('buy_pierce').addEventListener('click',()=>buyItem('pierce'));
document.getElementById('buy_gold').addEventListener('click',()=>buyItem('gold'));
document.getElementById('buy_camo').addEventListener('click',()=>buyItem('camo'));
document.getElementById('buy_shotgun').addEventListener('click',()=>buyItem('shotgun'));
document.getElementById('buy_pistol').addEventListener('click',()=>buyItem('pistol'));
document.getElementById('buy_sniper').addEventListener('click',()=>buyItem('sniper'));
document.getElementById('buy_shield').addEventListener('click',()=>buyItem('shield'));
document.getElementById('buy_bullettime').addEventListener('click',()=>buyItem('bullettime'));
document.getElementById('buy_nvg').addEventListener('click',()=>buyItem('nvg'));
document.getElementById('buy_flashlight').addEventListener('click',()=>buyItem('flashlight'));
document.getElementById('buy_glitch').addEventListener('click',()=>buyItem('glitch'));
document.getElementById('buy_mine').addEventListener('click',()=>buyItem('mine'));
document.getElementById('buy_akimbo').addEventListener('click',()=>buyItem('akimbo'));
document.getElementById('buy_eqhelmet').addEventListener('click',()=>buyItem('eqhelmet'));
document.getElementById('buy_eqvest').addEventListener('click',()=>buyItem('eqvest'));
document.getElementById('buy_eqknees').addEventListener('click',()=>buyItem('eqknees'));
document.getElementById('buy_drone').addEventListener('click',()=>buyItem('drone'));
document.getElementById('buy_gravgun').addEventListener('click',()=>buyItem('gravgun'));
document.getElementById('btnSettings').addEventListener('click',()=>{document.getElementById('menuScreen').style.display='none';document.getElementById('settingsScreen').style.display='flex';updateGfxUI();});
document.getElementById('btnSettingsBack').addEventListener('click',()=>{document.getElementById('settingsScreen').style.display='none';document.getElementById('menuScreen').style.display='flex';});
// Graphics preset cycle
document.getElementById('btnGfxPreset').addEventListener('click',()=>{
  const order=['low','medium','high','ultra'];
  const i=(order.indexOf(gfxPreset)+1)%order.length;
  applyGfxPreset(order[i]);
});
// Individual sliders
document.getElementById('gfxResRange').addEventListener('input',(ev)=>{gfxResScale=parseInt(ev.target.value)/100;resizeGfx();applyGfxVisuals();gfxPreset='custom';updateGfxUI();});
document.getElementById('gfxPartRange').addEventListener('input',(ev)=>{gfxMaxParticles=parseInt(ev.target.value);gfxPreset='custom';updateGfxUI();});
document.getElementById('gfxFogRange').addEventListener('input',(ev)=>{gfxFogDist=parseInt(ev.target.value);gfxPreset='custom';updateGfxUI();});
document.getElementById('gfxDecalRange').addEventListener('input',(ev)=>{gfxDecalCap=parseInt(ev.target.value);gfxPreset='custom';updateGfxUI();});
document.getElementById('gfxGibRange').addEventListener('input',(ev)=>{gfxGibletCap=parseInt(ev.target.value);gfxPreset='custom';updateGfxUI();});
document.getElementById('btnGfxShadows').addEventListener('click',()=>{gfxShadows=!gfxShadows;gfxPreset='custom';updateGfxUI();});
// Visual effect sliders
document.getElementById('gfxBrightRange').addEventListener('input',(ev)=>{gfxBrightness=parseInt(ev.target.value)/100;applyGfxVisuals();gfxPreset='custom';updateGfxUI();});
document.getElementById('gfxContrastRange').addEventListener('input',(ev)=>{gfxContrast=parseInt(ev.target.value)/100;applyGfxVisuals();gfxPreset='custom';updateGfxUI();});
document.getElementById('gfxSatRange').addEventListener('input',(ev)=>{gfxSaturation=parseInt(ev.target.value)/100;applyGfxVisuals();gfxPreset='custom';updateGfxUI();});
document.getElementById('gfxVigRange').addEventListener('input',(ev)=>{gfxVignette=parseInt(ev.target.value)/100;applyGfxVisuals();gfxPreset='custom';updateGfxUI();});
document.getElementById('confirmGoreYes').addEventListener('click',()=>{goreEnabled=true;document.getElementById('confirmGore').style.display='none';
  const cm=document.getElementById('cheatMsg');if(cm){cm.textContent='КРОВЬ АКТИВИРОВАНА!';cm.style.color='#f44';}
});
document.getElementById('confirmGoreNo').addEventListener('click',()=>{document.getElementById('confirmGore').style.display='none';});
// Cheat code system
function activateCheat(code){
  const c=code.trim().toLowerCase();
  const cm=document.getElementById('cheatMsg');
  if(c==='blood a not 5 yers old a 18 yers old'){
    document.getElementById('confirmGore').style.display='flex';
    return;
  }
  if(c==='free pls 150'){
    playerCoins+=150;
    updateShopCoins();
    if(cm){cm.textContent='ЧИТКОД АКТИВИРОВАН: +150 монет!';cm.style.color='#ff0';}
    return;
  }
  if(c==='skelet with black gun plssss'){
    skeletonMode=true;thirdPersonCam=true;
    if(cm){cm.textContent='РЕЖИМ СКЕЛЕТА АКТИВИРОВАН!';cm.style.color='#a0f';}
    return;
  }
  if(c==='black world spawn'){
    if(state!=='playing'){
      // Start a game first then boss mode
      try { initAudio(); } catch(ex){}
      gameMode='boss';initBossMode();state='playing';
      document.getElementById('settingsScreen').style.display='none';
      document.getElementById('menuScreen').style.display='none';
      try { canvas.requestPointerLock(); } catch(ex){}
    } else {
      gameMode='boss';initBossMode();
    }
    if(cm){cm.textContent='ЧЁРНЫЙ МИР АКТИВИРОВАН!';cm.style.color='#f0f';}
    return;
  }
  if(cm){cm.textContent='НЕИЗВЕСТНЫЙ КОД';cm.style.color='#f44';}
}
document.getElementById('btnCheat').addEventListener('click',()=>{
  const inp=document.getElementById('cheatInput');
  if(inp&&inp.value) activateCheat(inp.value);
});
document.getElementById('cheatInput').addEventListener('keydown',(ev)=>{
  if(ev.key==='Enter'){const inp=document.getElementById('cheatInput');if(inp&&inp.value)activateCheat(inp.value);}
  ev.stopPropagation(); // prevent game controls from firing
});
document.getElementById('cheatInput').addEventListener('keyup',(ev)=>{ev.stopPropagation();});
document.getElementById('btnNeon').addEventListener('click',()=>{neonMode=!neonMode;document.getElementById('btnNeon').textContent='НЕОН: '+(neonMode?'ВКЛ':'ВЫКЛ');});
document.getElementById('btnRain').addEventListener('click',()=>{rainEnabled=!rainEnabled;if(!rainEnabled){const rc=document.getElementById('rainCanvas');if(rc)rc.style.display='none';rainParticles.length=0;}document.getElementById('btnRain').textContent='ДОЖДЬ: '+(rainEnabled?'ВКЛ':'ВЫКЛ');});
// Map editor buttons
document.getElementById('btnMapEditor').addEventListener('click',()=>{
  document.getElementById('menuScreen').style.display='none';
  document.getElementById('mapEditorScreen').style.display='flex';
  initMapEditor();
});
document.getElementById('btnEdBack').addEventListener('click',()=>{
  document.getElementById('mapEditorScreen').style.display='none';
  document.getElementById('menuScreen').style.display='flex';
});
document.getElementById('btnEdSave').addEventListener('click',saveEditorMap);
document.getElementById('btnEdLoad').addEventListener('click',loadEditorMap);
document.getElementById('btnEdReset').addEventListener('click',()=>{
  for(let z=0;z<MAP_H;z++) for(let x=0;x<MAP_W;x++) editorMap[z][x]=MAP[z][x];
  drawEditorMap();
  const msg=document.getElementById('editorMsg');if(msg){msg.textContent='Сброшено!';msg.style.color='#f44';}
});
document.getElementById('btnEdPlay').addEventListener('click',playEditorMap);
document.getElementById('editorCanvas').addEventListener('mousedown',(ev)=>{editorClick(ev.clientX,ev.clientY);});
document.getElementById('editorCanvas').addEventListener('mousemove',(ev)=>{if(ev.buttons)editorClick(ev.clientX,ev.clientY);});
// Editor tool selection
document.querySelectorAll('.edTool').forEach(el=>{
  el.addEventListener('click',()=>{
    document.querySelectorAll('.edTool').forEach(t=>t.classList.remove('active'));
    el.classList.add('active');
    editorTool=parseInt(el.dataset.t);
  });
});
// Command wheel click handlers
document.querySelectorAll('.cmdOpt').forEach(el=>{
  el.addEventListener('click',()=>{
    allyCommandMode=el.dataset.cmd;
    commandWheelOpen=false;
    document.getElementById('commandWheel').style.display='none';
  });
});

/* ============================================================
   RAIN + FLASHLIGHT EFFECTS
   ============================================================ */
function drawRain(dt){
  if(!rainEnabled) return;
  const rc=document.getElementById('rainCanvas');
  if(!rc) return;
  rc.style.display='block';
  const rctx=rc.getContext('2d');
  rc.width=window.innerWidth; rc.height=window.innerHeight;
  rctx.clearRect(0,0,rc.width,rc.height);
  // Spawn rain drops
  if(rainParticles.length<300){
    for(let i=0;i<5;i++){
      rainParticles.push({x:Math.random()*rc.width,y:-10,speed:800+Math.random()*400,len:15+Math.random()*20});
    }
  }
  // Update & draw
  rctx.strokeStyle='rgba(150,180,255,0.3)';
  rctx.lineWidth=1;
  for(let i=rainParticles.length-1;i>=0;i--){
    const r=rainParticles[i];
    r.y+=r.speed*dt;
    if(r.y>rc.height){rainParticles.splice(i,1);continue;}
    rctx.beginPath();
    rctx.moveTo(r.x,r.y);
    rctx.lineTo(r.x-2,r.y-r.len);
    rctx.stroke();
  }
  // Occasional lightning flash
  if(Math.random()<0.001){
    rctx.fillStyle='rgba(200,200,255,0.15)';
    rctx.fillRect(0,0,rc.width,rc.height);
    // Thunder sound after delay
    setTimeout(()=>{if(audioCtx){
      const n=audioCtx.createBufferSource();
      const buf=audioCtx.createBuffer(1,audioCtx.sampleRate*0.5,audioCtx.sampleRate);
      const d=buf.getChannelData(0);
      for(let j=0;j<d.length;j++) d[j]=(Math.random()*2-1)*Math.exp(-j/d.length*3)*0.3;
      n.buffer=buf;n.connect(audioCtx.destination);n.start();
    }},500+Math.random()*2000);
  }
}

function drawFlashlight(){
  if(!flashlightOn||!hasFlashlight) return;
  const rc=document.getElementById('rainCanvas');
  if(!rc) return;
  const rctx=rc.getContext('2d');
  if(!rainEnabled){rc.style.display='block';rc.width=window.innerWidth;rc.height=window.innerHeight;rctx.clearRect(0,0,rc.width,rc.height);}
  // Dark vignette with bright center cone
  const cx=rc.width/2, cy=rc.height/2;
  // Darken everything first
  rctx.fillStyle='rgba(0,0,0,0.6)';
  rctx.fillRect(0,0,rc.width,rc.height);
  // Cut out flashlight cone
  rctx.globalCompositeOperation='destination-out';
  const grad=rctx.createRadialGradient(cx,cy*0.9,0,cx,cy*0.9,rc.height*0.5);
  grad.addColorStop(0,'rgba(0,0,0,1)');
  grad.addColorStop(0.5,'rgba(0,0,0,0.8)');
  grad.addColorStop(1,'rgba(0,0,0,0)');
  rctx.fillStyle=grad;
  rctx.fillRect(0,0,rc.width,rc.height);
  rctx.globalCompositeOperation='source-over';
  // Warm tint in cone center
  const grad2=rctx.createRadialGradient(cx,cy*0.9,0,cx,cy*0.9,rc.height*0.3);
  grad2.addColorStop(0,'rgba(255,240,200,0.06)');
  grad2.addColorStop(1,'rgba(0,0,0,0)');
  rctx.fillStyle=grad2;
  rctx.fillRect(0,0,rc.width,rc.height);
}

/* ============================================================
   MAIN LOOP
   ============================================================ */
let lastTime=0;

function frame(time){
  try {
    let dt=Math.min((time-lastTime)/1000, 0.05);
    lastTime=time;
    // Bullet time: slow enemies/physics but keep player responsive
    const btActive=bulletTimeLeft>0;
    const gameDt=btActive?dt*0.3:dt;

    if(state==='playing'){
      updatePlayer(dt); // player always normal speed
      updateEnemies(gameDt);
      updateAllies(gameDt);
      updateGrenades(gameDt);
      updateParticles(dt);
      updateGiblets(dt);
      updateMines(gameDt);
      updateWounds(dt);
      updateWeather(dt);
      updateGravGun(dt);
      // Juggernaut wave spawning
      if(gameMode==='juggernaut'){
        jugWaveTimer-=dt;
        const alive=enemies.filter(e=>e.hp>0).length;
        if(jugWaveTimer<=0 && alive<5){
          jugWave++;
          spawnJugWave(jugWave);
          jugWaveTimer=15+jugWave*2;
        }
      }
      // Math mode timer
      if(gameMode==='math'){
        if(mathFreezeTimer>0) mathFreezeTimer-=dt;
        mathTimer-=dt;
        if(mathTimer<=0){
          state='dead';
          playSound('death');
          document.getElementById('deathScreen').style.display='flex';
          document.getElementById('deathScreen').querySelector('p').textContent='Время вышло! Правильный ответ: '+mathA+' \u00d7 '+mathB+' = '+mathAnswer;
          document.getElementById('deathKills').style.display='block';
          document.getElementById('deathKills').textContent='Ваши монеты: '+playerCoins;
          document.getElementById('mathHud').style.display='none';
          try { document.exitPointerLock(); } catch(e){}
        }
      }
      // Zombie mode: wave spawning
      if(gameMode==='zombie'){
        if(!window._zombieWave) window._zombieWave=1;
        if(!window._zombieWaveTimer) window._zombieWaveTimer=3;
        window._zombieWaveTimer-=dt;
        const zAlive=enemies.filter(e=>e.hp>0).length;
        if(zAlive===0 && window._zombieWaveTimer<=0){
          window._zombieWave++;
          spawnZombieWave(window._zombieWave);
          window._zombieWaveTimer=5;
          playerCoins+=10*window._zombieWave;
        }
      }
      // Battle Royale zone
      if(gameMode==='battleroyale') updateBRZone(dt);
      // Wave Defense
      if(gameMode==='wavedefense'){
        wdWaveTimer-=dt;
        const alive=enemies.filter(e=>e.hp>0).length;
        if(alive===0&&wdWaveTimer<=0&&wdWave<5){
          wdWave++;spawnWDWave(wdWave);wdWaveTimer=15;
          playerCoins+=15*wdWave;
        }
        if(wdWave>=5&&alive===0){
          state='win';playSound('win');playerCoins+=100;
          document.getElementById('winScreen').style.display='flex';
          document.getElementById('winScreen').querySelector('p').textContent='Все 5 волн отражены!\n+100 монет';
          try{document.exitPointerLock();}catch(ex){}
        }
        // Enemies near defense point damage it
        for(const e of enemies){
          if(e.hp<=0) continue;
          const dd=Math.sqrt((e.x-wdPoint.x)**2+(e.z-wdPoint.z)**2);
          if(dd<4) wdPointHP-=5*dt;
        }
      }
      // Infection mode
      if(gameMode==='infection'){
        infectionTimer-=dt;
        // Zombie enemies can infect normal enemies on contact
        for(const e of enemies){
          if(e.hp<=0||!e._infected) continue;
          for(const e2 of enemies){
            if(e2===e||e2.hp<=0||e2._infected) continue;
            const dd=Math.sqrt((e.x-e2.x)**2+(e.z-e2.z)**2);
            if(dd<1.5){
              e2._infected=true;e2._zombie=true;e2.state='combat';
              e2.speed=2+Math.random();e2.shootTimer=999;
              infectedCount++;
              // Green flash
              for(let p=0;p<5;p++) particles.push({x:e2.x+(Math.random()-.5),y:1+Math.random(),z:e2.z+(Math.random()-.5),vx:(Math.random()-.5)*3,vy:2+Math.random()*2,vz:(Math.random()-.5)*3,life:0.5+Math.random()*0.3,r:0.2,g:0.7,b:0.1,a:1,size:0.06});
            }
          }
        }
        if(infectionTimer<=0){
          state='win';playSound('win');playerCoins+=50;
          document.getElementById('winScreen').style.display='flex';
          document.getElementById('winScreen').querySelector('p').textContent='Ты выжил 90 секунд!\n+50 монет';
          try{document.exitPointerLock();}catch(ex){}
        }
        // If all enemies become zombies and touch player => death
        const allZombie=enemies.filter(e=>e.hp>0).every(e=>e._infected);
        if(allZombie&&enemies.filter(e=>e.hp>0).length>0){
          // All infected - bonus win
        }
      }
      // Weather visual effects
      if(weatherType==='fog') gfxFogDist=Math.max(10,gfxFogDist*0.98+10*0.02);
      else if(weatherType==='blizzard') gfxFogDist=Math.max(15,gfxFogDist*0.98+15*0.02);
      else if(weatherType==='sandstorm') gfxFogDist=Math.max(8,gfxFogDist*0.98+8*0.02);
      else gfxFogDist=gfxFogDist*0.98+55*0.02;
      // Bullet time
      if(bulletTimeLeft>0){
        bulletTimeLeft-=dt;
        if(bulletTimeLeft<=0){bulletTimeCd=10;}
      }
      if(bulletTimeCd>0) bulletTimeCd-=dt;
      // Shield regeneration
      if(hasShield && !shieldActive && shieldHP<200) shieldHP=Math.min(200,shieldHP+5*dt);
      // Flashlight toggle (L key)
      if(keys['KeyL']&&hasFlashlight&&!player._flHeld){flashlightOn=!flashlightOn;player._flHeld=true;}
      if(!keys['KeyL']) player._flHeld=false;
    }

    if(state==='menu'){
      drawMenuCharacter(dt);
    } else {
      render();
      drawMinimap();
      updateHUD();

      drawScreenBlood(dt);
      drawRain(dt);
      drawFlashlight();
      // Weather particles overlay (blizzard/sandstorm)
      if(weatherType==='blizzard'||weatherType==='sandstorm'){
        const rc=document.getElementById('rainCanvas');
        if(rc){rc.style.display='block';const rctx=rc.getContext('2d');
          if(!rainEnabled){rc.width=window.innerWidth;rc.height=window.innerHeight;}
          const col=weatherType==='blizzard'?'rgba(200,220,255,0.35)':'rgba(180,150,100,0.25)';
          rctx.fillStyle=col;
          for(let i=0;i<15;i++){rctx.fillRect(Math.random()*rc.width,Math.random()*rc.height,3+Math.random()*5,1+Math.random()*2);}
          if(weatherType==='sandstorm'){rctx.fillStyle='rgba(120,90,40,0.08)';rctx.fillRect(0,0,rc.width,rc.height);}
        }
      }
      // Bullet time visual feedback
      if(bulletTimeLeft>0){
        const btOv=document.getElementById('neonOverlay');
        if(btOv){btOv.style.display='block';btOv.style.background='rgba(0,100,255,0.08)';}
      } else if(!neonMode){
        const btOv=document.getElementById('neonOverlay');
        if(btOv) btOv.style.display='none';
      }
    }
    // Bodycam overlay visibility
    const bcOv=document.getElementById('bodycamOverlay');
    const slOv=document.getElementById('scanLines');
    if(bcOv) bcOv.style.display=(state==='playing'||state==='dead'||state==='win')?'block':'none';
    if(slOv) slOv.style.display=(state==='playing')?'block':'none';
    const alcOv=document.getElementById('allyLabels');
    if(alcOv) alcOv.style.display=(state==='playing')?'block':'none';
  } catch(e) {
    console.error('Frame error:', e);
    document.title = 'ERROR: ' + e.message;
  }
  requestAnimationFrame(frame);
}

// Init player for menu view
initGame();
applyGfxVisuals();
requestAnimationFrame(frame);

</script>
</body>
</html>
